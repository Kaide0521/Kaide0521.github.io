---
title: 并查集及其应用
date: 2020-01-05 21:15:59
comments: true
toc: true
categories:
- 算法练习
tags: 
- 并查集

---
## **并查集及其应用**

- 什么是并查集
- 如何构建并查集
- 案例分析
- 改进有怀

HDOJ-1232
HDOJ-1829
HDOJ-1213
HDOJ-3635

### **什么是并查集？**

并查集是在解决动态连通性一类问题的一种算法，使用到了一种叫做并查集的数据结构，并查集是一种树型的数据结构，用于处理一些不相交集合的合并问题

### **如何构建并查集？**

并查集的主要操作有：
1－合并两个不相交集合      
2－判断两个元素是否属于同一个集合       
3－路径压缩

#### **方式一**


```
定义：set[i]表示节点i的父亲节点， 1=< i <=N
```

```
/**
 * 查找，O(1)
 * @param x
 * @return
 */
int find_0(int x){
    return set[x];
}

/**
 * 合并时候搜索所有的元素 ; O(N)
 * @param x
 * @param y
 */
void merge_0(int x,int y){
    int rx = find_0(x);
    int ry = find_0(y);

    if(rx == ry) return;

    for(int i = 1; i <= n ; i++){
        if(set[i] == rx){
            set[i] = ry;
        }
    }
}
```

#### **方式二**


```
/**
 * 循环的查找父节点
 * <p>最坏情况：O(N)</p>
 * <p>一般情况：O(logN)</p>
 * @param x
 * @return
 */
int find_1(int x){
    int r = x;
    while(set[r] != r){
        r = set[r];
    }
    return r;
}

/**
 * 简单的合并，以小的为父节点,O(1)
 * @param x
 * @param y
 */
void merge_1(int x ,int y){
    int rx = x;
    int ry = y;
    if(rx < ry){
        set[ry] = rx;
    }else {
        set[rx] = ry;
    }
}
```
### **方式三**

```
/**
 * 循环的查找父节点
 * <p>最坏情况：O(logN)</p>
 * <p>一般情况：O(1)</p>
 * @param x
 * @return
 */
int find_2(int x){
    int r = x;
    while(set[r] != r){
        r = set[r];
    }
    return r;
}

/**
 * 利用平衡二叉树的思想对子节点进行平衡处理，使用数组rank[i]记录节点i的子节点的个数
 * <p>时间复杂度：O(1)</p>
 * @param x
 * @param y
 */
void merge_2(int x,int y){
    if(rank[x] >= rank[y]){
        set[y] = x;
        rank[x] += rank[y];
    }else{
        set[x] = y;
        rank[y] += rank[x];
    }
}

```
### **方式四**

思路：每次查找的时候如果路径较长，则修改路径上的节点信息，使其都指向根节点

```
/**
 * 带路径压缩的非递归找根节点
 *
 * @param x
 * @return
 */
int find_3(int x){
    int t = x;
    while(set[t] != t){
        t = set[t];
    }
    int i = x;
    int temp;
    while( i != t){
        temp = set[i];
        set[i] = t;
        i = temp;
    }
    return t;
}

/**
 * 带路径压缩的递归找根节点
 * @param x
 * @return
 */
int find_3recursion(int x){

    if(set[x] != x){
        set[x] = find_3recursion(set[x]);
    }
    return set[x];
}

/**
 * 利用平衡二叉树的思想对子节点进行平衡处理，使用数组rank[i]记录节点i的子节点的个数
 * <p>时间复杂度：O(1)</p>
 * @param x
 * @param y
 */
void merge_3(int x, int y){
    if(rank[x] > rank[y]){
        set[y] = x;
    }else{
        if(rank[x] == rank[y]){
            rank[y]++;
        }
        set[x] = y;
    }
}

```