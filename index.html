<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="6YFc09u3uc">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.kaide0521.cn').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="芝麻酱的技术学习踩坑记">
<meta property="og:type" content="website">
<meta property="og:title" content="芝麻酱">
<meta property="og:url" content="https://blog.kaide0521.cn/index.html">
<meta property="og:site_name" content="芝麻酱">
<meta property="og:description" content="芝麻酱的技术学习踩坑记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="芝麻酱">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.kaide0521.cn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>芝麻酱</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="芝麻酱" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
	<a href="https://github.com/Kaide0521" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	</div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">芝麻酱</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">踩坑记</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">IDA Pro脱dex壳过反调试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-07 21:47:34 / 修改时间：21:48:14" itemprop="dateCreated datePublished" datetime="2020-01-07T21:47:34+08:00">2020-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">移动安全</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/" class="post-meta-item leancloud_visitors" data-flag-title="IDA Pro脱dex壳过反调试" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="IDA-Pro脱dex壳过反调试"><a href="#IDA-Pro脱dex壳过反调试" class="headerlink" title="IDA Pro脱dex壳过反调试"></a>IDA Pro脱dex壳过反调试</h3><p>标签（空格分隔）： Apk逆向</p>
<hr>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a><strong>1. 前言</strong></h3><p>之前总结了IDA pro脱壳的基本步骤，包括调试步骤和在libdvm.so的dvmDexFileOpenPartial函数出下断点，从内存中dump出dex文件。<br>这次以360一代加壳为例，试着在mmap出下断点和过一些基本的反调试技术。</p>
<h3 id="2-脱壳环境搭建"><a href="#2-脱壳环境搭建" class="headerlink" title="2. 脱壳环境搭建"></a><strong>2. 脱壳环境搭建</strong></h3><p>这里的环境搭建和上一篇博客一样<a href="http://blog.csdn.net/daide2012/article/details/75675210" target="_blank" rel="noopener">http://blog.csdn.net/daide2012/article/details/75675210</a><br>启动android_server<br>端口转发<br>以调试模式启动应用<br>打开IDA附件进程<br>设置Debugger Option选项<br>运行jdb调试</p>
<h3 id="3-开始脱壳"><a href="#3-开始脱壳" class="headerlink" title="3. 开始脱壳"></a><strong>3. 开始脱壳</strong></h3><p><strong>3.1 下断点</strong></p>
<p>找到mmap函数，在此下断点，一般我们读取文件都是使用fopen和fgets函数，但是360壳通过mmap函数读取/proc/pid/status，来检查TracerPid，因此我们应该在mmap函数处下断点</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MjUwODY5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MzA5NDky?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>单步调试过程中发现一直重复执行一段代码如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MzIxMDMz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>我们发现，这是一段循环，测试是增加破解难度，故意设置的，因此我们将循环条件的寄存器值进行更改，让其跳出循环，否则要进行多次单步，按F8按的手痛</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MzM3MjI1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>在寄存器列表中点击鼠标右键，修改寄存器R11的值为Ox000000A7,提早退出循环，然后单步调试<br>注意单步都标号为loc_760BF08C处的时候，要进入该函数，然后继续单独调试，我试了好几次，每次执行到此处的代码，自动退出了，因此反调试的实现肯定是由该段代码实现，所以要进入调试</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MzU3MjUw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>继续单独调试</p>
<p>过程中会发现程序读取/proc/pid/status的内容，比较TracerPid的值与0的大小</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1NDEzOTEz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>此时R0寄存器的值恰好是16进制的值11EF,对应的TracerPid为4591，因此要修改R0寄存器的值为0,绕过范调试检测，然后继续单步<br>执行完后，按F9继续运行mmap函数，因为此时读取的并不一定是dex文件，动态库在装载的时候很多都调用了mmap函数，所以回到mmap继续调试</p>
<p>注意，程序会多次进行反调试检测，所以在进入反调试的函数处建议下断点，这样可以快速的F9到反调试检测的位置。我在调试的过程中一共按了6,7次才把反调试检测过完，中间按错了好几次，每次都得重头再来，耐心很重要啊！！!</p>
<p>过了反调试之后，在memcmp处下断点，不断的F9，同时在Hex View窗口主要出现dex.035的字符</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1NDI5MzU0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>终于看到dex.035这个字样了，下面的工作使用脚本将dex文件从内存中dump出</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1NDQ0MTg0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>之后即可直接采用脚本dump出dex文件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">IDA Pro脱dex壳初探</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-07 21:45:43 / 修改时间：21:55:34" itemprop="dateCreated datePublished" datetime="2020-01-07T21:45:43+08:00">2020-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">移动安全</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E5%88%9D%E6%8E%A2/" class="post-meta-item leancloud_visitors" data-flag-title="IDA Pro脱dex壳初探" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E5%88%9D%E6%8E%A2/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E5%88%9D%E6%8E%A2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="IDA-Pro脱dex壳初探"><a href="#IDA-Pro脱dex壳初探" class="headerlink" title="IDA Pro脱dex壳初探"></a>IDA Pro脱dex壳初探</h3><p>标签（空格分隔）： Apk逆向</p>
<hr>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>关于IDA Pro的介绍，已不用多说了，是目前最棒的一个静态反编译软件，编程天才的杰作。这里的脱壳实战我们以阿里比赛样本AliCrackme_3.apk样本为例。</p>
<h3 id="2-调试环境的搭建"><a href="#2-调试环境的搭建" class="headerlink" title="2. 调试环境的搭建"></a>2. 调试环境的搭建</h3><h4 id="2-1-安装IDA-Pro"><a href="#2-1-安装IDA-Pro" class="headerlink" title="2.1 安装IDA Pro"></a><strong>2.1 安装IDA Pro</strong></h4><p>[下载地址][1]<br>直接解压运行</p>
<h4 id="2-2-使用IDA进行调试设置"><a href="#2-2-使用IDA进行调试设置" class="headerlink" title="2.2 使用IDA进行调试设置"></a><strong>2.2 使用IDA进行调试设置</strong></h4><p>在IDA安装目录dbgsrv下获取android_server命令文件<br>运行命令：</p>
<pre><code>adb root
adb remount
adb push android_server /data   #将文件拷贝到手机data目录
adb shell
cd /data
chmod 755 android_server    #更改权限，赋予可执行权限
./android_server            #运行
root@Che1:/data # ./android_server
IDA Android 32-bit remote debug server(ST) v1.17. Hex-Rays (c)     2004-2014
Listening on port #23946...</code></pre><p>错误1：error: only position independent executables (PIE) are supported<br>这个主要是Android5.0以上的编译选项默认开启了pie，在5.0以下编译的原生应用不能运行，有两种解决办法，一种是用Android5.0以下的手机进行操作，还有一种就是用IDA6.6+版本即可。</p>
<h4 id="2-3-配置端口转发"><a href="#2-3-配置端口转发" class="headerlink" title="2.3 配置端口转发"></a><strong>2.3 配置端口转发</strong></h4><p>这里开始监听了设备的23946端口，那么如果要想让IDA和这个android_server进行通信，那么必须让PC端的IDA也连上这个端口，那么这时候就需要借助于adb的一个命令了：<br><strong>adb forward tcp:远端设备端口号(进行调试程序端) tcp:本地设备端口(被调试程序端)</strong><br>另起一个cmd,运行命令<br>    adb forward tcp:23946 tcp:23946</p>
<h4 id="2-4-以debug模式启动apk"><a href="#2-4-以debug模式启动apk" class="headerlink" title="2.4 以debug模式启动apk"></a><strong>2.4 以debug模式启动apk</strong></h4><pre><code>adb shell am start -D -n com.ali.tg.testapp/.MainActivity</code></pre><h4 id="2-5-使用IDA进行连接"><a href="#2-5-使用IDA进行连接" class="headerlink" title="2.5 使用IDA进行连接"></a><strong>2.5 使用IDA进行连接</strong></h4><p>选择Debugger-&gt;Attach-&gt;Remote ARMLinux/Android debugger</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMjIxMDc3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>点击OK按钮，按ctrl+F搜索com.ali进行进程附加操作</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMjM0MjQx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h4 id="2-6-启动jdb调试器"><a href="#2-6-启动jdb调试器" class="headerlink" title="2.6 启动jdb调试器"></a><strong>2.6 启动jdb调试器</strong></h4><pre><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></pre><p>处于等待状态</p>
<p><img src="https://img-blog.csdnimg.cn/20200107215447785.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-7-下断点"><a href="#2-7-下断点" class="headerlink" title="2.7 下断点"></a><strong>2.7 下断点</strong></h4><p>给dvmDexFileOpenPartial函数下断点，原因如下：<br>dvmDexFileOpenPartial这个函数是最终分析dex文件，加载到内存中的函：</p>
<pre><code>int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex);</code></pre><p>第一个参数就是dex内存起始地址，第二个参数就是dex大小。</p>
<p>找到dvmDexFileOpenPartial的函数地址<br>IDA静态分析libdvm.so得到这个函数的相对地址为Ox46CCC</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMzA1OTg0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>按Ctrl + S查看libdvm.so在虚拟内存中的映射位置</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMzI2MDUx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>然后将两者相加得到绝对地址：Ox46CCC + Ox415CA000 = Ox41610CCC，使用G键，跳转：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMzQxNzQ4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h4 id="2-8-点击运行按钮或者F9-然后按F8进行单步调试"><a href="#2-8-点击运行按钮或者F9-然后按F8进行单步调试" class="headerlink" title="2.8 点击运行按钮或者F9,然后按F8进行单步调试"></a><strong>2.8 点击运行按钮或者F9,然后按F8进行单步调试</strong></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMzU0OTg5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>其中R0和R1就是传递给dvmDexFileOpenPartial的参数，R0对应于addr，R1对应于len,也就是dex文件的长度</p>
<p>然后按下Shirt+F2 调出IDA的脚本运行界面</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzNDIwOTM5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>然后使用jeb工具打开dump到的dex文件</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzNDM3MDQ2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>于是得到了被加固的dex文件</p>
<h4 id="2-9-总结"><a href="#2-9-总结" class="headerlink" title="2.9 总结"></a><strong>2.9 总结</strong></h4><p>该样本直接使用dvmDexFileOpenPartial函数实现dex的文件加载，我们直接可在改函数出下断点，然后从内存中直接dump出dex文件，是一个比较简单样例，也算是复习下IDA pro调试的基本步骤，然后真正的现实情况并没有这么简单，很多多应用会采取一系列额反调试手段，比如：</p>
<p><strong>SO的反调试</strong><br>IDA是使用android_server在root环境下注入到被调试的进程中，那么这里用到一个技术就是Linux中的ptrace<br>那么Android中如果一个进程被另外一个进程ptrace了之后，在他的status文件中有一个字段：TracerPid 可以标识是被哪个进程trace了，我们可以使用命令查看我们的被调试的进行信息：<br>status文件在：/proc/[pid]/status<br>如果检测到这个字段不为0，说明当前so文件正在被调试，这是一种常用的反调试技术</p>
<p>还有有些加固的apk对dex文件的加载不一定就走dvmDexFileOpenPartial进行加载，会自己实现dex文件的加载函数，但不管怎么样，最终还是会使用mmap内存映射函数，所以下断点的地方又有所区别。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/07/App%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/App%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">App虚拟化技术初探</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-07 21:43:45 / 修改时间：21:44:26" itemprop="dateCreated datePublished" datetime="2020-01-07T21:43:45+08:00">2020-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">移动安全</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/07/App%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/" class="post-meta-item leancloud_visitors" data-flag-title="App虚拟化技术初探" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/07/App%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/07/App%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Plugin-Technology-Background"><a href="#Plugin-Technology-Background" class="headerlink" title="Plugin Technology Background"></a><strong>Plugin Technology Background</strong></h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAyOTM3MTA1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>App插件开发技术或App虚拟化技术以及App热修复技术，最近几年非常火热和流行，图中列举了两种主要的需求，第一种需求是很多时候我们想在Android手机上同时登陆多个社交应用，比如QQ或者微信，在Android原生系统中肯定是无法支持的，只有登出一个账号后然后在换另外一个，因此衍生APP虚拟化技术；另外一种需求是一个大的APK文件我想分批次发布，防止一次性发布下载时间过长而损害用户体验，因此我把不同的功能以插件的形式发布，这个插件同样是APK文件，同样对于某一种功能的升级或者bug的修复都可以采用这种技术来实现。</p>
<h3 id="What-is-Android-Plugin-Technology"><a href="#What-is-Android-Plugin-Technology" class="headerlink" title="What is Android Plugin Technology?"></a><strong>What is Android Plugin Technology?</strong></h3><ul>
<li>Launch an APK file within an Android app.<br>在一个APP内部启动一个APP</li>
<li>In the unrooted device.<br>不需要root手机</li>
<li>“Host App” = Android app.</li>
<li>“Plugin” = APK file.</li>
<li>No need to install the plugin.<br>这里的无需安装主要是指对系统来说，并没有实地安装，，创建沙箱环境，以用户的视角来看还是与host app一样，点击安装，然后正常运行</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzMjAzNTQw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h3 id="现有的插件框架"><a href="#现有的插件框架" class="headerlink" title="现有的插件框架"></a><strong>现有的插件框架</strong></h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzMjMxODQ1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>现有的能够实现上述需求的框架主要有DroidPlugin、VirtualApp、DynamicAPK<br>典型的应用有Parallel Space，截止2017年下载了达到千万级别<br>虽然很多类型的这种框架，但是他们得底层实现机制基本相同</p>
<h3 id="Demystify-Plugin-Technology"><a href="#Demystify-Plugin-Technology" class="headerlink" title="Demystify Plugin Technology"></a><strong>Demystify Plugin Technology</strong></h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzMzM5NTE0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>插件技术最主要的中原理就是，为了让插件中的方法能够正确的调用。Host APP把所有的插件和系统（Android Framework交互）的方法都在内部Hook并替换掉了。</p>
<p><strong>为什么这样做呢？</strong> </p>
<p>因为，这个是一个插件系统，Activity是虚拟Proxy出来的。四大组件，并不是真正的，即Context拿到不一定是真的。系统也不会有此类的回调。所以，很多单例都需要执行Context才能使用。比如：InputMethodManager.getInstance(Context context)；这时，插件中的代码将不能够直接运行。当然，还有其他原因。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNDA5NDM3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h3 id="动态加载运行一个Activity的基本机制"><a href="#动态加载运行一个Activity的基本机制" class="headerlink" title="动态加载运行一个Activity的基本机制"></a><strong>动态加载运行一个Activity的基本机制</strong></h3><p>为了进一步的理解这种插件运行机制中的HOOK技术，我们来看一个简单的实例，即如何动态加载运行一个Apk中的Activity,</p>
<p>既然说到动态加载，我们很容易想到Davilk虚拟机中的类加载器</p>
<p>(1) DexClassLoader可以加载任何路径的apk/dex/jar/zip<br>(2) PathClassLoader只能加载缓存在/data/app中的apk，也就是已经安装到手机中的apk</p>
<p>那么如何加载一个apk并运行其中的Activity呢？我们很容易想到使用如下代码实现</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNTAzMTc2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>这样显然是不行的<br>因为Android中的四大组件都有一个特点就是他们有自己的启动流程和生命周期，我们使用DexClassLoader加载进来的Activity是不会涉及到任何启动流程和生命周期的概念，说白了，就是一个普普通通的类，所以启动肯定会出错。<br>那么如何解决呢？</p>
<h4 id="思路一：替换LoadedApk中mClassLoader"><a href="#思路一：替换LoadedApk中mClassLoader" class="headerlink" title="思路一：替换LoadedApk中mClassLoader"></a><strong>思路一：替换LoadedApk中mClassLoader</strong></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNjIxMDQ4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>由于这个mClassLoader是非static类型的引用，因此我们通过反射的机制无法更改当前运行时数据，那么该怎么办呢？我们再看ActivityThread这个类</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNjQzODYz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>这个类中有一个静态变量，我们可以通过反射这个类，来获取LoadedApk对象，然后更改其mClassLoader</p>
<h4 id="思路二：更新DexPathList数据结构"><a href="#思路二：更新DexPathList数据结构" class="headerlink" title="思路二：更新DexPathList数据结构"></a><strong>思路二：更新DexPathList数据结构</strong></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNzMwMjM3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>APK在启动的过程中加载的dex文件都存放在一个叫dexElements的数据结构中，我们通过将插件APK的dex文件解析后的数据结构也放入此数据中，使其成为host App的一部分，那么host app在启动其中的Activity的时候就具有上下文环境了，相应的组件也会有生命周期</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNzUxODI1?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h4 id="思路三：使用静态代理"><a href="#思路三：使用静态代理" class="headerlink" title="思路三：使用静态代理"></a><strong>思路三：使用静态代理</strong></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzODI0NTIz?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>基本思路是使用一个在host app中具有生命周期和执行上下文的Activity代理插件Activity执行其各个生命周期的回调函数</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzODQ5NzQw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h4 id="之前三种方式共有的缺陷"><a href="#之前三种方式共有的缺陷" class="headerlink" title="之前三种方式共有的缺陷"></a><strong>之前三种方式共有的缺陷</strong></h4><p>(1) 需要在宿主应用的Manifest文件中注册要启动的Plugin中的组件，权限等信息，只能加载运行特定已知的apk，因此不可能将所有需要以插件方式进行运行的APK中的组件全部进行注册</p>
<h4 id="思路四：使用hook技术代理实现"><a href="#思路四：使用hook技术代理实现" class="headerlink" title="思路四：使用hook技术代理实现"></a><strong>思路四：使用hook技术代理实现</strong></h4><p>我们先看下启动一个Activity的基本过程，图中已说明详细，这里不再赘述了</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzOTQ0NzY4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>由于前三种方式的缺陷，第四重方式通过预先在Host APP的Manifest文件中预注册一些启动插件app会用到的一些Dummy 组件，也就是图中的StubActivity，当使用intent启动一个PluginActivity的时候，使用Hook拦截此消息，将PluginActivity更换为StubActivity，通过Binder系统调用进行进程间过程调用，ActivityManngerService执行Activity的栈管理、验证等过程，由于我们使用将PluginActivity更换为StubActivity，而StubActivity又在Host APP的Manifest文件中预注册了。所以验证会通过，然后ActivityManngerService将控制权移交给APP进程（同样通过进程间的RPC调用），然后APP进程开始执行真正创建Activity的过程，这创建之前又通过hook将StubActivity更换为PluginActivity，启动真正要启动的Activity，因此这样就可以瞒天过海，欺上瞒下，骗过System_server进程，同时使得启动的Activity又具有相应的生命周期，整个过程还是比较直观的。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTA0MDE4Mjg0?x-oss-process=image/format,png" alt="这里写图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/07/%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">基于函数加密的.so加固学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-07 21:41:53 / 修改时间：21:42:22" itemprop="dateCreated datePublished" datetime="2020-01-07T21:41:53+08:00">2020-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">移动安全</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/07/%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="基于函数加密的.so加固学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/07/%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/07/%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>标签（空格分隔）： Apk逆向与保护</p>
<hr>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a><strong>1. 前言</strong></h3><p>之前学习了简单对ELF文件中的Section进行加密实现简单暴力的加固，这个section是自定义的，一般很容易被识别出来，更好的做法是对函数进行加密。既然是对函数加密，我们就需要找到函数的地址和大小。既然是找到函数的地址，必然是基于ELF文件的转载视图来进行操作的。</p>
<h3 id="2-基本思路"><a href="#2-基本思路" class="headerlink" title="2. 基本思路"></a><strong>2. 基本思路</strong></h3><h3 id="2-1-如何找到要加密的函数"><a href="#2-1-如何找到要加密的函数" class="headerlink" title="2.1 如何找到要加密的函数"></a><strong>2.1 如何找到要加密的函数</strong></h3><p>基于section的加密，我们很容易根据elf文件的header找到.shstrtab节区，从而找到我们要对其进行加密的section，此处我们该如何找到函数的定义呢？这就要求对ELF文件的结构要有进一步较深的认识，通过ELF文件的格式我们知道，ELF文件中存在.dynsym和.dynstr这两个节区，.dynsym主要是描述动态链接的符号或者函数结构信息，.dynstr主要描述动态链接的符号字符串或函数名称。</p>
<p>那么我们可以通过type来获取.dynsym和.dynstr吗？</p>
<p>答案是否定的，因为不同的section的type可能相同，比如.dynstr和.shstrtab的type都是STRTAB<br>在ELF中，每个函数的结构描述放在.dynsym中，函数的名称放在.dynstr中，我们怎么去查找它们的对应关系呢？<br>有一个叫.hash的section，这个节描述的是一个hash表，其结构图如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MjA0ODM4MDY2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>bucket 数组包含 nbucket 个项目,chain 数组包含 nchain 个项目,下标都是从 0 开始。bucket 和 chain 中都保存符号表索引。chain 表项和符号表存在对应。符号表项的数目应该和 nchain 相等,所以符号表的索引也可用来选取 chain 表项。</p>
<p>假如符号s = “aaaa”,hash(s) = 5,则index = bucket[5 % 10] = 5;<br>则给出其存放的初始索引为5，如果发现索引为index出的符号不是s,那么chain[index]则给出与s具有相同哈希值的符号的索引（可以理解为不同字符串通过哈希映射取模会产生冲突），因此一直这么搜索下去，知道找到符号s所在的索引为止。</p>
<h3 id="2-1-如何找到-hash节区"><a href="#2-1-如何找到-hash节区" class="headerlink" title="2.1 如何找到.hash节区"></a><strong>2.1 如何找到.hash节区</strong></h3><p>通过对ELF文件的研究，我们发现，当so被加载后，其section结构对于加载视图来说是无意义的，so的加载视图中有个段叫做.dynmic，此段包含了动态链接信息，因此.dynsym和.dynstr，.hash节区肯定包含在这里（一个段可以包含多个节区）,因此我们只要找到装载视图中的.dynamic段，然后解析成dynmic结构信息，然后根据type类型找到.dynsym和.dynstr，.hash节区<br><strong>具体过程：</strong><br>(1) 找到.dynamic段；.dynamic段的描述可根据程序头部表来找到，该段在程序头部表中用符号DYNAMIC来标记</p>
<p>(2) 找到.dynamic段之后解析成相关的数据结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dynamic &#123;</span><br><span class="line">  Elf32_Sword d_tag;    &#x2F;* Dynamic entry type *&#x2F;</span><br><span class="line">  &#x2F;* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS *&#x2F;</span><br><span class="line">  union &#123;</span><br><span class="line">    Elf32_Sword d_val;</span><br><span class="line">    Elf32_Addr d_ptr;</span><br><span class="line">  &#125; d_un;</span><br><span class="line">  &#x2F;* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS *&#x2F;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<p>对于每个这种类型的结构，d_tag控制了d_un的解释含义：</p>
<ul>
<li>d_val 此 Elf32_Word 对象表示一个整数值，可以有多种解释。</li>
<li>d_ptr 此 Elf32_Addr 对象代表程序的虚拟地址。如前所述，文件的虚拟地址可能与执行过程中的内存虚地址不匹配。在解释包含于动态结构中的地址时，动态链接程序基于原来文件值和内存基地址计算实际地址。为了保持一致性，文件中不包含用来“纠正”动态结构中重定位项地址的重定位项目。</li>
</ul>
<p>(3) 根据d_tag标志，找到.dynsym和.dynstr，.hash节区</p>
<p>为什么这里又可以根据type类型来找到相应的节区呢？因为此时我们在.dynamic段里面进行匹配，type相对来说是唯一的</p>
<h3 id="2-加密具体过程"><a href="#2-加密具体过程" class="headerlink" title="2. 加密具体过程"></a><strong>2. 加密具体过程</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 实现对so的函数进行加密操作</span><br><span class="line">     *</span><br><span class="line">     * @param elfFilePath  输入的ELF文件路径</span><br><span class="line">     * @param outPath      加密操作完成后输出路径</span><br><span class="line">     * @param functionName 要进行加密的函数名称</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void doFunctionEncryption(String elfFilePath, String outPath, String functionName) &#123;</span><br><span class="line">        byte[] fileContent &#x3D; Utils.readFile(elfFilePath);</span><br><span class="line">        if (fileContent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;read file byte failed...&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 首先将ELF文件解析成 ElfType32的对象格式，ElfType32封装了ELF文件各个部分的属性信息 *&#x2F;</span><br><span class="line">        ElfType32 type_32 &#x3D; ELFParser.parseElfToType32(fileContent);</span><br><span class="line">        &#x2F;** 对我们指定的section进行加密操作 *&#x2F;</span><br><span class="line">        doEncryptionFunction(fileContent, type_32, functionName);</span><br><span class="line"></span><br><span class="line">        ElfType32 otype_32 &#x3D; ELFParser.parseElfToType32(fileContent);</span><br><span class="line"></span><br><span class="line">        Utils.saveFile(outPath, fileContent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现加密操作：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">private static void doEncryptionFunction(byte[] fileByteArys, ElfType32 type_32, String functionName) &#123;</span><br><span class="line">        &#x2F;** 得到Dynamic段的偏移值和大小**&#x2F;</span><br><span class="line">        int dy_offset &#x3D; 0, dy_size &#x3D; 0;</span><br><span class="line">        for (elf32_phdr phdr : type_32.phdrList) &#123;</span><br><span class="line">            if (Utils.byte2Int(phdr.p_type) &#x3D;&#x3D; ElfType32.PT_DYNAMIC) &#123;</span><br><span class="line">                dy_offset &#x3D; Utils.byte2Int(phdr.p_offset);</span><br><span class="line">                dy_size &#x3D; Utils.byte2Int(phdr.p_filesz);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;dy_size:&quot; + dy_size);</span><br><span class="line">        &#x2F;** 解析得到Dynamic段中的每个节区**&#x2F;</span><br><span class="line">        ELFParser.getDynamicTableList(fileByteArys, dy_size, dy_offset, type_32);</span><br><span class="line">        &#x2F;** .dynstr的大小和偏移**&#x2F;</span><br><span class="line">        int dynstr_size &#x3D; 0, dynstr_offset &#x3D; 0;</span><br><span class="line">        &#x2F;** .dynsym的偏移**&#x2F;</span><br><span class="line">        int dynsym_offset &#x3D; 0;</span><br><span class="line">        &#x2F;** .hash的偏移**&#x2F;</span><br><span class="line">        int hash_offset &#x3D; 0;</span><br><span class="line">        &#x2F;** 根据type解析每个字段的值 **&#x2F;</span><br><span class="line">        for (Elf32_dyn dyn : type_32.dynList) &#123;</span><br><span class="line">            if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_HASH) &#123;</span><br><span class="line">                hash_offset &#x3D; Utils.byte2Int(dyn.d_ptr);</span><br><span class="line">            &#125; else if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_STRTAB) &#123;</span><br><span class="line">                System.out.println(&quot;strtab:&quot; + dyn);</span><br><span class="line">                dynstr_offset &#x3D; Utils.byte2Int(dyn.d_ptr);</span><br><span class="line">            &#125; else if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_SYMTAB) &#123;</span><br><span class="line">                System.out.println(&quot;systab:&quot; + dyn);</span><br><span class="line">                dynsym_offset &#x3D; Utils.byte2Int(dyn.d_ptr);</span><br><span class="line">            &#125; else if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_STRSZ) &#123;</span><br><span class="line">                System.out.println(&quot;strsz:&quot; + dyn);</span><br><span class="line">                dynstr_size &#x3D; Utils.byte2Int(dyn.d_val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 获取.dynstr节的字节数组，也就是符号字符数据集合 **&#x2F;</span><br><span class="line">        byte[] dynstr &#x3D; Utils.copyBytes(fileByteArys, dynstr_offset, dynstr_size);</span><br><span class="line">        int funcIndex &#x3D; 0;</span><br><span class="line">        for (Elf32_dyn dyn : type_32.dynList) &#123;</span><br><span class="line">            if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_HASH) &#123;</span><br><span class="line">                int nbucket &#x3D; Utils.byte2Int(Utils.copyBytes(fileByteArys, hash_offset, 4));</span><br><span class="line">                int nchian &#x3D; Utils.byte2Int(Utils.copyBytes(fileByteArys, hash_offset + 4, 4));</span><br><span class="line">                int hash &#x3D; (int) Utils.getElfHash(functionName.getBytes());</span><br><span class="line">                hash &#x3D; (hash % nbucket);</span><br><span class="line">                &#x2F;** 得到函数的索引值，这里的8是读取nbucket和nchian的两个值**&#x2F;</span><br><span class="line">                funcIndex &#x3D; Utils.byte2Int(Utils.copyBytes(fileByteArys, hash_offset + hash * 4 + 8, 4));</span><br><span class="line">                System.out.println(&quot;nbucket:&quot; + nbucket + &quot;,hash:&quot; + hash + &quot;,funcIndex:&quot; + funcIndex + &quot;,chian:&quot; + nchian);</span><br><span class="line">                System.out.println(&quot;sym:&quot; + Utils.bytes2HexString(Utils.int2Byte(dynsym_offset)));</span><br><span class="line">                System.out.println(&quot;hash:&quot; + Utils.bytes2HexString(Utils.int2Byte(hash_offset)));</span><br><span class="line">                int dynsym_size &#x3D; 16;</span><br><span class="line">                byte[] des &#x3D; new byte[dynsym_size];</span><br><span class="line">                &#x2F;** 根据函数的索引值在.dynsym节中找到其具体的描述结构信息**&#x2F;</span><br><span class="line">                System.arraycopy(fileByteArys, dynsym_offset + funcIndex * dynsym_size, des, 0, dynsym_size);</span><br><span class="line">                Elf32_Sym sym &#x3D; ELFParser.parseSymbolTable(des);</span><br><span class="line">                System.out.println(&quot;sym:&quot; + sym);</span><br><span class="line">                boolean isFindFunc &#x3D; Utils.isEqualByteAry(dynstr, Utils.byte2Int(sym.st_name), functionName);</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    if(isFindFunc)&#123;</span><br><span class="line">                        System.out.println(&quot;find func...&quot;);</span><br><span class="line">                        &#x2F;** 得到函数体的字节大小 **&#x2F;</span><br><span class="line">                        int functionSize &#x3D; Utils.byte2Int(sym.st_size);</span><br><span class="line">                        &#x2F;** 得到函数体的偏移量 **&#x2F;</span><br><span class="line">                        int functionOffset &#x3D; Utils.byte2Int(sym.st_value);</span><br><span class="line">                        System.out.println(&quot;size:&quot; + functionSize + &quot;,funcOffset:&quot; + functionOffset);</span><br><span class="line">                        &#x2F;** 进行目标函数代码部分进行加密 **&#x2F;</span><br><span class="line">                        byte[] funcAry &#x3D; Utils.copyBytes(fileByteArys, functionOffset - 1, functionSize);</span><br><span class="line">                        for (int i &#x3D; 0; i &lt; funcAry.length - 1; i++) &#123;</span><br><span class="line">                            funcAry[i] &#x3D; (byte) (funcAry[i] ^ 0xFF);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;** 将加密后的函数体替换回去 **&#x2F;</span><br><span class="line">                        Utils.replaceByteAry(fileByteArys, functionOffset - 1, funcAry);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;** 如果没有找到，则通过chain[index]找到具有相同hash值的下个符号索引 **&#x2F;</span><br><span class="line">                    funcIndex &#x3D; Utils.byte2Int(Utils.copyBytes(fileByteArys, hash_offset + 4 * ( 2 + nbucket + funcIndex), 4));</span><br><span class="line">                    System.out.println(&quot;funcIndex:&quot;+funcIndex);</span><br><span class="line">                    System.arraycopy(fileByteArys, dynsym_offset + funcIndex*dynsym_size, des, 0, dynsym_size);</span><br><span class="line">                    sym &#x3D; ELFParser.parseSymbolTable(des);</span><br><span class="line">                    isFindFunc &#x3D; Utils.isEqualByteAry(dynstr, Utils.byte2Int(sym.st_name), functionName);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-解密具体过程"><a href="#3-解密具体过程" class="headerlink" title="3. 解密具体过程"></a><strong>3. 解密具体过程</strong></h3><p><strong>定义解密函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 定义解密函数为__attribute__((constructor))，在Main函数之前执行 **&#x2F;</span><br><span class="line">void init_decryption() __attribute__((constructor));</span><br></pre></td></tr></table></figure>
<p><strong>执行解密操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 执行解密操作 **&#x2F;</span><br><span class="line">void init_decryption() &#123;</span><br><span class="line">    const char *functionName &#x3D; &quot;Java_idc_hust_edu_cn_functionso_JNIDemo_stringFromJNI&quot;;</span><br><span class="line">    unsigned int base_addr &#x3D; getLibVPAddr();</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;base addr &#x3D;  0x%x&quot;, base_addr);</span><br><span class="line">    &#x2F;** 用来保存函数的结构信息 **&#x2F;</span><br><span class="line">    funcInfo info;</span><br><span class="line">    if (getTargetFuncInfo(base_addr, functionName, &amp;info) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        print_debug(&quot;Find Java_com_example_shelldemo2_MainActivity_getString failed&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 函数体占的物理页块数目 **&#x2F;</span><br><span class="line">    unsigned int npage &#x3D; info.st_size &#x2F; PAGE_SIZE + ((info.st_size % PAGE_SIZE &#x3D;&#x3D; 0) ? 0 : 1);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;npage &#x3D;  0x%d&quot;, npage);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;npage &#x3D;  0x%d&quot;, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 修改内存的操作权限，因为不同的虚拟地址空间的内存段是有权限限制的，比如代码段是只读，数据段：可读可写**&#x2F;</span><br><span class="line">    if (mprotect((void *) ((base_addr + info.st_value) &#x2F; PAGE_SIZE * PAGE_SIZE), 4096 * npage,</span><br><span class="line">                 PROT_READ | PROT_EXEC | PROT_WRITE) !&#x3D; 0) &#123;</span><br><span class="line">        print_debug(&quot;mem privilege change failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 执行具体的解密操作 **&#x2F;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; info.st_size - 1; i++) &#123;</span><br><span class="line">        char *addr &#x3D; (char *) (base_addr + info.st_value - 1 + i);</span><br><span class="line">        *addr &#x3D; ~(*addr);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 解密完成后，要修改回权限 **&#x2F;</span><br><span class="line">    if (mprotect((void *) ((base_addr + info.st_value) &#x2F; PAGE_SIZE * PAGE_SIZE), 4096 * npage,</span><br><span class="line">                 PROT_READ | PROT_EXEC) !&#x3D; 0) &#123;</span><br><span class="line">        print_debug(&quot;mem privilege change failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 获得指定函数的符号表结构，整个过程和加密过程定位符号表基本类似</span><br><span class="line"> *</span><br><span class="line"> * @param base_addr  虚拟基址</span><br><span class="line"> * @param funcName 目标函数</span><br><span class="line"> * @param info  函数的结构信息</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">static char getTargetFuncInfo(unsigned long base_addr, const char *funcName, funcInfo *info) &#123;</span><br><span class="line">    Elf32_Ehdr *ehdr;</span><br><span class="line">    Elf32_Phdr *phdr;</span><br><span class="line">    &#x2F;** elf header **&#x2F;</span><br><span class="line">    ehdr &#x3D; (Elf32_Ehdr *) base_addr;</span><br><span class="line">    &#x2F;** 程序头部表结构 **&#x2F;</span><br><span class="line">    phdr &#x3D; (Elf32_Phdr *) (base_addr + ehdr-&gt;e_phoff);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;phdr &#x3D;  0x%p, size &#x3D; 0x%x\n&quot;, phdr, ehdr-&gt;e_phnum);</span><br><span class="line">    int i &#x3D; 0, isFind &#x3D; 1;</span><br><span class="line">    &#x2F;** 在程序头部表结构定位.dynamic段 **&#x2F;</span><br><span class="line">    for (i &#x3D; 0; i &lt; ehdr-&gt;e_phnum; ++i) &#123;</span><br><span class="line">		__android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;phdr &#x3D;  0x%p\n&quot;, phdr);</span><br><span class="line">        if (phdr-&gt;p_type &#x3D;&#x3D; PT_DYNAMIC) &#123;</span><br><span class="line">            isFind &#x3D; 0;</span><br><span class="line">            print_debug(&quot;Find .dynamic segment&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        phdr++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isFind &#x3D;&#x3D; 0) goto _error;</span><br><span class="line">    &#x2F;** 找到.dynamic的虚拟地址和大小 **&#x2F;</span><br><span class="line">    Elf32_Off dynamic_vaddr &#x3D; base_addr + phdr-&gt;p_vaddr;</span><br><span class="line">    Elf32_Off dynamic_size &#x3D; phdr-&gt;p_filesz;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;dynamic_vaddr &#x3D;  0x%x, dynamic_size &#x3D;  0x%x&quot;, dynamic_vaddr, dynamic_size);</span><br><span class="line">    &#x2F;** 查找.dynsym和.dynstr以及.hash节区的信息**&#x2F;</span><br><span class="line">    Elf32_Dyn *dyn;</span><br><span class="line">    Elf32_Addr dyn_symtab_offset, dyn_strtab_offset, dyn_hash_offset;</span><br><span class="line">    int flag &#x3D; 0;</span><br><span class="line">    for(i &#x3D; 0; i &lt; (dynamic_size &#x2F; sizeof(Elf32_Dyn)); i++)&#123;</span><br><span class="line">        dyn &#x3D; (Elf32_Dyn *)(dynamic_vaddr + i * sizeof(Elf32_Dyn));</span><br><span class="line">        if (dyn-&gt;d_tag &#x3D;&#x3D; DT_SYMTAB) &#123;</span><br><span class="line">            dyn_symtab_offset &#x3D; (dyn-&gt;d_un).d_ptr;</span><br><span class="line">            flag +&#x3D; 1;</span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find .dynsym section, addr &#x3D; 0x%x\n&quot;, dyn_symtab_offset);</span><br><span class="line">        &#125;</span><br><span class="line">        if (dyn-&gt;d_tag &#x3D;&#x3D; DT_HASH) &#123;</span><br><span class="line">            dyn_hash_offset &#x3D; (dyn-&gt;d_un).d_ptr;</span><br><span class="line">            flag +&#x3D; 2;</span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find .hash section, addr &#x3D; 0x%x\n&quot;, dyn_hash_offset);</span><br><span class="line">        &#125;</span><br><span class="line">        if (dyn-&gt;d_tag &#x3D;&#x3D; DT_STRTAB) &#123;</span><br><span class="line">            dyn_strtab_offset &#x3D; (dyn-&gt;d_un).d_ptr;</span><br><span class="line">            flag +&#x3D; 4;</span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find .dynstr section, addr &#x3D; 0x%x\n&quot;, dyn_strtab_offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 如果没有找到，则出错，无法进行解密操作 **&#x2F;</span><br><span class="line">    if ((flag &amp; 0x0f) !&#x3D; 0x0f) &#123;</span><br><span class="line">        print_debug(&quot;Find needed .section failed\n&quot;);</span><br><span class="line">        goto _error;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 各个偏移加上虚拟基地址定位到实际映射的虚拟地址 **&#x2F;</span><br><span class="line">    dyn_symtab_offset +&#x3D; base_addr;</span><br><span class="line">    dyn_hash_offset +&#x3D; base_addr;</span><br><span class="line">    dyn_strtab_offset +&#x3D; base_addr;</span><br><span class="line"></span><br><span class="line">    unsigned funHash, nbucket;</span><br><span class="line">    unsigned *bucket, *chain;</span><br><span class="line">    funHash &#x3D; getElfHash(funcName);</span><br><span class="line">    &#x2F;** .dynsym结构信息 **&#x2F;</span><br><span class="line">    Elf32_Sym *funSym &#x3D; (Elf32_Sym *)dyn_symtab_offset;</span><br><span class="line">    &#x2F;** .dynstr结构信息 **&#x2F;</span><br><span class="line">    char *dynstr &#x3D; (char *)dyn_strtab_offset;</span><br><span class="line">    &#x2F;** .nbucket **&#x2F;</span><br><span class="line">    nbucket &#x3D; *((int *) dyn_hash_offset);</span><br><span class="line">    &#x2F;** 指向bucket，nbucket和nchian的两个值的大小为8，跳过这两个字段 **&#x2F;</span><br><span class="line">    bucket &#x3D; (unsigned int *) (dyn_hash_offset + 8);</span><br><span class="line">    &#x2F;** 指向chain**&#x2F;</span><br><span class="line">    chain &#x3D; (unsigned int *) (dyn_hash_offset + 4 * (2 + nbucket));</span><br><span class="line">    flag &#x3D; -1;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;hash &#x3D; 0x%x, nbucket &#x3D; 0x%x\n&quot;, funHash, nbucket);</span><br><span class="line">    &#x2F;** 得到funcName的哈希值为funHash的符号索引 **&#x2F;</span><br><span class="line">    int sym_index &#x3D; (funHash % nbucket);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;mod &#x3D; %d\n&quot;, sym_index);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;i &#x3D; 0x%d\n&quot;, bucket[sym_index]);</span><br><span class="line">    &#x2F;** 循环查找funcName在符号表中的索引 **&#x2F;</span><br><span class="line">    for (i &#x3D; bucket[sym_index]; i !&#x3D; 0; i &#x3D; chain[i]) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find index &#x3D; %d\n&quot;, i);</span><br><span class="line">        if (strcmp(dynstr + (funSym + i)-&gt;st_name, funcName) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find %s\n&quot;, funcName);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag) goto _error;</span><br><span class="line">    info-&gt;st_value &#x3D; (funSym + i)-&gt;st_value;</span><br><span class="line">    info-&gt;st_size &#x3D; (funSym + i)-&gt;st_size;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;st_value &#x3D; %d, st_size &#x3D; %d&quot;, info-&gt;st_value, info-&gt;st_size);</span><br><span class="line">    return 0;</span><br><span class="line">    _error:</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/07/%E5%9F%BA%E4%BA%8Esection%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/%E5%9F%BA%E4%BA%8Esection%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">基于section加密的.so加固学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-07 21:38:19 / 修改时间：21:39:26" itemprop="dateCreated datePublished" datetime="2020-01-07T21:38:19+08:00">2020-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">移动安全</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/07/%E5%9F%BA%E4%BA%8Esection%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="基于section加密的.so加固学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/07/%E5%9F%BA%E4%BA%8Esection%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/07/%E5%9F%BA%E4%BA%8Esection%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>标签（空格分隔）： APK逆向与保护</p>
<hr>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>APK的加固技术研究已有很多年了，有很多成熟的厂商提供相关的服务，加固的目的一方面是为了保护应用不被恶意反编译和篡改，得到应用的源代码。另一方面防止应用中为发现的漏洞被攻击者发现利用。早期的加固技术主要是基于Dex文件实现的，通过将源程序的dex文件加密，在运行的过程中由解壳程序动态加载、解密和运行。但是由于基于dex的加固技术，很容易被破解，在内存中dump出dex文件，因此衍生了基于.so的加固技术，虽然基于.so的加固技术的安全性有所提高，但是道高一尺，魔高一丈，基于各种断点调试的人肉脱壳也是很容易恢复出dex文件，据说目前厂商又在研究基于vmp的加固技术，通过自定义指令和解释器等各种技术实现更高级保护等。作为一名“入坑”不久的菜鸟，在这里不谈那么多，先简单学习下基于so加固的基本原理，安全、逆向任重而道远啦<del>~</del></p>
<h2 id="2-so加固的基本思路"><a href="#2-so加固的基本思路" class="headerlink" title="2. so加固的基本思路"></a>2. so加固的基本思路</h2><p>前段时间，折腾了下ELF文件，对ELF文件有了基本的认识，虽然有些地方理解的还是比较模糊，比如ELF文件在动态加载、链接的细节方面，看了《深入理解计算机系统》之后，理解的还是不到位，期待神作《程序员的自我修养-链接、加载和库》到货，认真研读，以求理解的更加透彻。</p>
<p>古人学问无遗力，少壮工夫老始成。<br>纸上得来终觉浅，绝知此事要躬行。<br>                    ————陆游</p>
<p>看书归看书，还是得彻彻底底实践一遍</p>
<p>首先得感谢这些博主的无私分享<br>[<a href="http://bbs.pediy.com/thread-191649.htm][1]" target="_blank" rel="noopener">http://bbs.pediy.com/thread-191649.htm][1]</a><br>[<a href="http://blog.csdn.net/jiangwei0910410003/article/details/49966719][2]" target="_blank" rel="noopener">http://blog.csdn.net/jiangwei0910410003/article/details/49966719][2]</a><br>[<a href="http://zke1ev3n.me/2015/12/27/Android-So%E7%AE%80%E5%8D%95%E5%8A%A0%E5%9B%BA/][3]" target="_blank" rel="noopener">http://zke1ev3n.me/2015/12/27/Android-So%E7%AE%80%E5%8D%95%E5%8A%A0%E5%9B%BA/][3]</a><br>在这里，菜鸟我也是照着你们的神作，依葫芦画瓢，把整个过程梳理一遍，顺便写写自己的感受。<br>学习逆向的过程是艰辛的，<strong>But, 人皆向死而生，又有何所惧？</strong></p>
<p>好了，废话少说，言归正传</p>
<p>先来看实现so加固的两种基本思路：</p>
<h3 id="2-1-通过将核心函数实现在自定义section中，并进行加密"><a href="#2-1-通过将核心函数实现在自定义section中，并进行加密" class="headerlink" title="2.1 通过将核心函数实现在自定义section中，并进行加密"></a><strong>2.1 通过将核心函数实现在自定义section中，并进行加密</strong></h3><p>基本的思路是自定义一个section，然后将核心函数的实现放在自定义的section中，并且对其进行加密。然后我们再来看ELF文件的格式：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA0MTkyMTIzOTE4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>我们可以看到其中有两个section，分别是.init_array和.fini_array,前面一个在动态链接库加载到进程映像后执行一些初始化操作，后面的终止的时候执行。</p>
<p>也就是.init_array节中的代码先与程序的Main函数开始之前执行，因此我们只要将解密函数定义成.init_array属性的节中，就可以在main函数开始之前解密我们先已加密的section，正常调用其中的函数。</p>
<h3 id="2-2-1-加密过程"><a href="#2-2-1-加密过程" class="headerlink" title="2.2.1 加密过程"></a><strong>2.2.1 加密过程</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 实现对so的section进行加密操作</span><br><span class="line">     *</span><br><span class="line">     * @param elfFilePath       输入的ELF文件路径</span><br><span class="line">     * @param outPath           加密操作完成后输出路径</span><br><span class="line">     * @param encodeSectionName 要进行加密的节区名称</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void doShell(String elfFilePath, String outPath, String encodeSectionName) &#123;</span><br><span class="line">        byte[] fileContent &#x3D; Utils.readFile(elfFilePath);</span><br><span class="line">        if (fileContent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;read file byte failed...&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 首先将ELF文件解析成 ElfType32的对象格式，ElfType32封装了ELF文件各个部分的属性信息 *&#x2F;</span><br><span class="line">        ElfType32 type_32 &#x3D; ELFParser.parseElfToType32(fileContent);</span><br><span class="line">        &#x2F;** 对我们指定的section进行加密操作 *&#x2F;</span><br><span class="line">        doEncryptionSection(fileContent, type_32, encodeSectionName);</span><br><span class="line"></span><br><span class="line">        ElfType32 otype_32 &#x3D; ELFParser.parseElfToType32(fileContent);</span><br><span class="line"></span><br><span class="line">        Utils.saveFile(outPath, fileContent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>具体加密过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">     * 执行具体的加密操作</span><br><span class="line">     *</span><br><span class="line">     * @param fileByteArys</span><br><span class="line">     * @param type_32</span><br><span class="line">     * @param encodeSectionName</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void doEncryptionSection(byte[] fileByteArys, ElfType32 type_32, String encodeSectionName) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;** ELFheader 定义了.shstrtab节区在节区头部表中的索引，也就是第几个表项 *&#x2F;</span><br><span class="line">        int shstrab_index &#x3D; Utils.byte2Short(type_32.hdr.e_shstrndx);</span><br><span class="line"></span><br><span class="line">        &#x2F;** 获取.shstrtab节区的结构,.shstrtab节区保存了各个节区的名称 *&#x2F;</span><br><span class="line">        elf32_shdr shdr &#x3D; type_32.shdrList.get(shstrab_index);</span><br><span class="line">        &#x2F;**.shstrtab节区的大小**&#x2F;</span><br><span class="line">        int shstrab_size &#x3D; Utils.byte2Int(shdr.sh_size);</span><br><span class="line">        &#x2F;**.shstrtab节区的偏移，相对于文件**&#x2F;</span><br><span class="line">        int shstrab_offset &#x3D; Utils.byte2Int(shdr.sh_offset);</span><br><span class="line">        &#x2F;** 记录要找的节区偏移**&#x2F;</span><br><span class="line">        int mySectionOffset &#x3D; 0;</span><br><span class="line">        &#x2F;** 记录要找的节区大小**&#x2F;</span><br><span class="line">        int mySectionSize &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;** 找到名称为encodeSectionName的节区，并执行加密操作 *&#x2F;</span><br><span class="line">        for(elf32_shdr t_shdr : type_32.shdrList)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;** t_shdr.sh_name定义了节区名称在.shstrtab节区中的大小偏移，可以理解为索引 **&#x2F;</span><br><span class="line">            int sectionNameOffset &#x3D; shstrab_offset + Utils.byte2Int(t_shdr.sh_name);</span><br><span class="line"></span><br><span class="line">            &#x2F;** 如果.shstrtab节区在sectionNameOffset偏移出的字符串与encodeSectionName相等，说明找到了**&#x2F;</span><br><span class="line">            if (Utils.isEqualByteAry(fileByteArys, sectionNameOffset, encodeSectionName)) &#123;</span><br><span class="line">                &#x2F;** 这里需要读取section段然后进行数据加密 **&#x2F;</span><br><span class="line">                mySectionOffset &#x3D; Utils.byte2Int(t_shdr.sh_offset);</span><br><span class="line">                mySectionSize &#x3D; Utils.byte2Int(t_shdr.sh_size);</span><br><span class="line">                byte[] sectionAry &#x3D; Utils.copyBytes(fileByteArys, mySectionOffset, mySectionSize);</span><br><span class="line">                for (int i &#x3D; 0; i &lt; sectionAry.length; i++) &#123;</span><br><span class="line">                    sectionAry[i] &#x3D; (byte) (sectionAry[i] ^ 0xFF);</span><br><span class="line">                &#125;</span><br><span class="line">                Utils.replaceByteAry(fileByteArys, mySectionOffset, sectionAry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(mySectionOffset &#x3D;&#x3D; 0 &amp;&amp; mySectionSize &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Can not find the section of &#39;encodeSectionName&#39; !&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 修改Elf Header中的e_entry和e_shoff值 为加密的section的offset和size</span><br><span class="line">         *</span><br><span class="line">         * 为什么要修改Header中的e_entry和e_shoff值呢？</span><br><span class="line">         *</span><br><span class="line">         * 1.方便解密的时候快速定位到加密的section，方便解密</span><br><span class="line">         *</span><br><span class="line">         * 既然修改了Header中的e_entry和e_shoff值，难道程序的加载运行的时候找不到入口地址，不会报错吗？</span><br><span class="line">         *</span><br><span class="line">         * 2.在这里我们又要理解下目标文件的装载视图和链接视图，首先对于动态库来说，程序被加载时，设定的跳转地址是动态连接器的地址</span><br><span class="line">         * 通过GOT表和PLT表实现动态调用，与e_entry无关，另外在装载过程中，用不到链接视图中的一些字段，比如e_shoff</span><br><span class="line">         * 所以这两个字段可以被额外数据填充.</span><br><span class="line">         *</span><br><span class="line">         * **&#x2F;</span><br><span class="line">        int nSize &#x3D; mySectionSize&#x2F;4096 + (mySectionSize%4096 &#x3D;&#x3D; 0 ? 0 : 1);</span><br><span class="line">        byte[] entry &#x3D; new byte[4];</span><br><span class="line">        entry &#x3D; Utils.int2Byte((mySectionSize&lt;&lt;16) + nSize);</span><br><span class="line">        Utils.replaceByteAry(fileByteArys, 24, entry);</span><br><span class="line">        byte[] offsetAry &#x3D; new byte[4];</span><br><span class="line">        offsetAry &#x3D; Utils.int2Byte(mySectionOffset);</span><br><span class="line">        Utils.replaceByteAry(fileByteArys, 32, offsetAry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-解密过程"><a href="#2-2-2-解密过程" class="headerlink" title="2.2.2 解密过程"></a><strong>2.2.2 解密过程</strong></h3><p>由于很多细节的描述的代码中一一称述，这里就不啰嗦了</p>
<p><strong>1.首先我们见解密函数定义为</strong></p>
<pre><code>void init_decryption() __attribute__((constructor));</code></pre><p>函数声明为<strong>attribute</strong>((constructor))属性会先于Main函数之前执行</p>
<p><strong>2.然后，获取动态库加载在进程内存映像中的虚拟首地址</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">unsigned long getLibVPAddr()&#123;</span><br><span class="line">    unsigned long ret &#x3D; 0;</span><br><span class="line">    char name[] &#x3D; &quot;libdemo.so&quot;;</span><br><span class="line">    char buf[4096], *temp;</span><br><span class="line">    int pid;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    pid &#x3D; getpid();</span><br><span class="line">    &#x2F;** 获取当前进程的虚拟地址映射表 **&#x2F;</span><br><span class="line">    sprintf(buf, &quot;&#x2F;proc&#x2F;%d&#x2F;maps&quot;, pid);</span><br><span class="line">    fp &#x3D; fopen(buf, &quot;r&quot;);</span><br><span class="line">    if(fp &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;open failed&quot;);</span><br><span class="line">        goto _error;</span><br><span class="line">    &#125;</span><br><span class="line">    while(fgets(buf, sizeof(buf), fp))&#123;</span><br><span class="line">        &#x2F;** 找到当前进程加载的so库的虚拟地址 **&#x2F;</span><br><span class="line">        if(strstr(buf, name))&#123;</span><br><span class="line">            temp &#x3D; strtok(buf, &quot;-&quot;);</span><br><span class="line">            ret &#x3D; strtoul(temp, NULL, 16);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _error:</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.执行具体的解密过程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void init_decryption()&#123;</span><br><span class="line">    unsigned int nblock;</span><br><span class="line">    unsigned int nsize;</span><br><span class="line">    unsigned long base;</span><br><span class="line">    unsigned long text_addr;</span><br><span class="line">    &#x2F;** ELF Header 结构体指针 **&#x2F;</span><br><span class="line">    Elf32_Ehdr *elfHeader;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 获取加载进内存的so的起始地址 **&#x2F;</span><br><span class="line">    base &#x3D; getLibVPAddr();</span><br><span class="line"></span><br><span class="line">    &#x2F;** 获取指定section的偏移值和size **&#x2F;</span><br><span class="line">    elfHeader &#x3D; (Elf32_Ehdr *)base;</span><br><span class="line">    &#x2F;** 在我们加密的过程中e_shoff保存的是目标section的偏移，此时加上基址就是目标section在内存中的虚拟地址 **&#x2F;</span><br><span class="line">    text_addr &#x3D; elfHeader-&gt;e_shoff + base;</span><br><span class="line">    &#x2F;** 获取目标section的字节空间大小 **&#x2F;</span><br><span class="line">    nblock &#x3D; elfHeader-&gt;e_entry &gt;&gt; 16;</span><br><span class="line">    &#x2F;** 获取目标section所占的页数，每页对应4 X 1024B **&#x2F;</span><br><span class="line">    nsize &#x3D; elfHeader-&gt;e_entry &amp; 0xffff;</span><br><span class="line"></span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;nblock &#x3D;  0x%x,nsize:%d&quot;, nblock,nsize);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;base &#x3D;  0x%x&quot;, text_addr);</span><br><span class="line">    printf(&quot;nblock &#x3D; %d\n&quot;, nblock);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 修改内存的操作权限，因为不同的虚拟地址空间的内存段是有权限限制的，比如代码段是只读，数据段：可读可写**&#x2F;</span><br><span class="line">    if(mprotect((void *) (text_addr &#x2F; PAGE_SIZE * PAGE_SIZE), 4096 * nsize, PROT_READ | PROT_EXEC | PROT_WRITE) !&#x3D; 0)&#123;</span><br><span class="line">        puts(&quot;mem privilege change failed&quot;);</span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;mem privilege change failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    &#x2F;** 执行具体的解密操作 **&#x2F;</span><br><span class="line">    for(i&#x3D;0;i&lt; nblock; i++)&#123;</span><br><span class="line">        char *addr &#x3D; (char*)(text_addr + i);</span><br><span class="line">        *addr &#x3D; ~(*addr);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 解密完成后，要修改会权限 **&#x2F;</span><br><span class="line">    if(mprotect((void *) (text_addr &#x2F; PAGE_SIZE * PAGE_SIZE), 4096 * nsize, PROT_READ | PROT_EXEC) !&#x3D; 0)&#123;</span><br><span class="line">        puts(&quot;mem privilege change failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Decrypt success&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/05/Android-Studio%E8%B0%83%E8%AF%95smali%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/Android-Studio%E8%B0%83%E8%AF%95smali%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">Android Studio调试smali代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-05 21:27:12 / 修改时间：21:30:16" itemprop="dateCreated datePublished" datetime="2020-01-05T21:27:12+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">移动安全</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/05/Android-Studio%E8%B0%83%E8%AF%95smali%E4%BB%A3%E7%A0%81/" class="post-meta-item leancloud_visitors" data-flag-title="Android Studio调试smali代码" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/05/Android-Studio%E8%B0%83%E8%AF%95smali%E4%BB%A3%E7%A0%81/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/05/Android-Studio%E8%B0%83%E8%AF%95smali%E4%BB%A3%E7%A0%81/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Android-Studio调试smali代码"><a href="#Android-Studio调试smali代码" class="headerlink" title="Android Studio调试smali代码"></a>Android Studio调试smali代码</h3><p>标签： APK逆向分析</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>经过一段时间的学习，现在总结下针对APK逆向的一些基本调试技术，以阿里移动安全比赛题目为例</p>
<h2 id="2-使用Android-Studio调试smali代码"><a href="#2-使用Android-Studio调试smali代码" class="headerlink" title="2. 使用Android Studio调试smali代码"></a>2. 使用Android Studio调试smali代码</h2><p>步骤一：下载安全Android Stuio,下载地址<a href="http://www.android-studio.org/" target="_blank" rel="noopener">http://www.android-studio.org/</a></p>
<p>步骤二：下载插件smalidea<br>地址: <a href="https://bitbucket.org/JesusFreke/smali/downloads" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads</a></p>
<p>步骤三：下载完成后，打开Android studio的Settings——&gt;Plugins，选择 Install plugin from disk</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzNjUzMDA3?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>步骤四：反编译apk，修改AndroidManifest.xml文件的属性android:debuggable=”true”</p>
<pre><code>java -jar apktool.jar d -d ./apk/AliCrackme_1.apk -o out</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzNzEzMzk0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>修改完成之后，回编译apk</p>
<pre><code>java -jar apktool.jar b -d out -o debug.apk</code></pre><p>回编之后，进行签名</p>
<pre><code>java -jar .\sign\signapk.jar .\sign\testkey.x509.pem .\sign\testkey.pk8 debug.apk debug.sig.apk</code></pre><p>步骤五：安装签名之后的应用</p>
<pre><code>adb install debug.sig.apk</code></pre><p>使用backsmali得到apk的smali代码</p>
<pre><code>java -jar backsmali.jar debug.sig.apk</code></pre><p>将得到的smali代码导入Android Studio中</p>
<p>步骤六：配置远程调试的选项，选择Run–&gt;Edit Configurations：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzNzM4NzA0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>增加一个Remote调试的调试选项，端口选择:8700</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzNzU3OTg4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>步骤七：下好断点，针对本APK我们在button的onclik函数出下断点（点击鼠标右键）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzODI0Nzg2?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>步骤八：以调试状态启动app</p>
<pre><code>adb shell am start -D -n com.example.simpleencryption/.MainActivity</code></pre><p>下好断点之后Run-&gt;Debug<br>执行完</p>
<pre><code>invoke-virtual {v6}, Lcom/example/simpleencryption/MainActivity;-&gt;getTableFromPic()Ljava/lang/String;</code></pre><p>得到图6内容</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzOTE5MzM4?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>通过分析我们大体知道个整个函数的执行逻辑</p>
<ol>
<li>通过MainActivity中的getTableFromPic方法，获取一个类似密码表的东西</li>
<li>通过MainActivity中的getPwdFromPic方法，获取正确的密码”义弓么丸广之”</li>
<li>获取我们输入内容的utf-8的字节码，然后调用MainActivity的access$0方法，获取加密之后的内容</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzOTQzNzIy?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<ol start="4">
<li>再看MainActivity的access$0方法的实现</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDg0MDE0MTcw?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>里面又调用了bytesToAliSmsCode，传了两个参数，一个是我们输入的qwer的bytes数组，一个是获取的密码表</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDg0MTI3Mzk5?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<p>具体的逻辑如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.method private static bytesToAliSmsCode(Ljava&#x2F;lang&#x2F;String;[B)Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">    .registers 5</span><br><span class="line">    .param p0, &quot;table&quot;    # Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">    .param p1, &quot;data&quot;    # [B</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 144</span><br><span class="line">    new-instance v1, Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v1&#125;, Ljava&#x2F;lang&#x2F;StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    .line 145</span><br><span class="line">    .local v1, &quot;sb&quot;:Ljava&#x2F;lang&#x2F;StringBuilder;    &#x2F;&#x2F;创建一个StringBuilder的变量sb</span><br><span class="line">    const&#x2F;4 v0, 0x0</span><br><span class="line"></span><br><span class="line">    .local v0, &quot;i&quot;:I    &#x2F;&#x2F; 定义一个int变量i &#x3D; 0</span><br><span class="line">    :goto_6</span><br><span class="line">    array-length v2, p1</span><br><span class="line"></span><br><span class="line">    if-lt v0, v2, :cond_e   &#x2F;&#x2F; 比较i和data数组的长度，如果小于，跳到cond_e</span><br><span class="line"></span><br><span class="line">    .line 148</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava&#x2F;lang&#x2F;StringBuilder;-&gt;toString()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    return-object v2</span><br><span class="line"></span><br><span class="line">    .line 146</span><br><span class="line">    :cond_e</span><br><span class="line">    aget-byte v2, p1, v0   &#x2F;&#x2F; 取出data[i]</span><br><span class="line"></span><br><span class="line">    and-int&#x2F;lit16 v2, v2, 0xff</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0, v2&#125;, Ljava&#x2F;lang&#x2F;String;-&gt;charAt(I)C   &#x2F;&#x2F; 获取data[i]在table数组的字符</span><br><span class="line"></span><br><span class="line">    move-result v2</span><br><span class="line">    &#x2F;&#x2F; 调用sb的append函数进行拼接</span><br><span class="line">    invoke-virtual &#123;v1, v2&#125;, Ljava&#x2F;lang&#x2F;StringBuilder;-&gt;append(C)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line"></span><br><span class="line">    .line 145</span><br><span class="line">    add-int&#x2F;lit8 v0, v0, 0x1</span><br><span class="line"></span><br><span class="line">    goto :goto_6</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>整体逻辑就是一个循环，将输入字符转化为utf-8格式的bye数组，然后取出data[i]table表中所对应的字符，然后拼接返回<br> 5. 返回字符串与正确密码”义弓么丸广之”比较<br> invoke-virtual {v4, v6}, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z<br> 此时我们输入的qwer加密后与”义弓么丸广之”<br>肯定不相等，所以这里我们可以想办法是的输入的字符串加密等于”义弓么丸广之”</p>
<p><strong>怎么办呢？</strong></p>
<p>我们可以将bytesToAliSmsCode进行反向实现，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">		String table &#x3D; &quot;一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐&quot;;</span><br><span class="line">		String dataString &#x3D; &quot;义弓么丸广之&quot;;</span><br><span class="line">		String passwd  &#x3D; &quot;&quot;;</span><br><span class="line">		for(int i &#x3D; 0 ; i &lt; dataString.length(); i++)&#123;</span><br><span class="line">			passwd +&#x3D; (char)table.indexOf(dataString.charAt(i));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;passwd &#x3D; &quot; + passwd);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行出的结果为passwd = 581026就是我们输入框里面要输入的字符串</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/05/Android%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/Android%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">Android组件安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-05 21:24:56 / 修改时间：21:25:38" itemprop="dateCreated datePublished" datetime="2020-01-05T21:24:56+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">移动安全</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/05/Android%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/" class="post-meta-item leancloud_visitors" data-flag-title="Android组件安全" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/05/Android%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/05/Android%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Android组件安全"><a href="#Android组件安全" class="headerlink" title="Android组件安全"></a><strong>Android组件安全</strong></h2><p>做过Android开发的攻城狮都知道Android四大组件，在开发过程中打交道最多的也是这四大组件，在开发Android应用的过程中我们最基本的要求是要对这四大组件有一个清晰的认识，包括组件的功能特性、生命周期、与系统的交互模型，以及组件之间如何配合使用等等。本文内容主要是关于组件的安全模型以及如何正确的使用组件来降低应用的安全风险的一个学习笔记。</p>
<h3 id="一、Android四大组件简介"><a href="#一、Android四大组件简介" class="headerlink" title="一、Android四大组件简介"></a><strong>一、Android四大组件简介</strong></h3><h4 id="1-Service组件"><a href="#1-Service组件" class="headerlink" title="1. Service组件"></a><strong>1. Service组件</strong></h4><p>Service是没有界面且能长时间运行于后台的应用组件，是Android中实现程序后台运行的解决方案，非常适合用于去执行那些不需要和用户交互而且还要求长期运行的任务。这也是为了不阻塞主进程，然而主进程依然能够流畅的处理UI事件，提供良好的用户体验。</p>
<p>根据Service的生命周期不同又分为两种类型：</p>
<pre><code>（1）start类型：应用程序组件（如activity）调用startService()方法启动服务时，服务处于started状态
（2）bound类型：组件调用bindService()方法绑定到服务时，服务处于bound状态</code></pre><p><strong>两者的区别：</strong>调用startService()启动的Service其生命周期与启动它的组件无关，调用bindService()启动的Service会在启动它的组件消亡后消亡</p>
<p><strong>1.1 Service安全</strong></p>
<p>关于Service安全规范请参照博客：<a href="http://www.droidsec.cn/android-service-security/" target="_blank" rel="noopener">http://www.droidsec.cn/android-service-security/</a></p>
<h4 id="2-Activity组件"><a href="#2-Activity组件" class="headerlink" title="2. Activity组件"></a><strong>2. Activity组件</strong></h4><p>Activity是一个Android应用程序和用户进行交互界面的Android组件，相当于应用程序的一个交互屏幕，Activity之间通过Intent进行通信。下图是Activity的生命周期变迁图</p>
<p><strong>2.1 Activity生命周期</strong></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bXGiHv3W-1578230663807)(<a href="http://i.imgur.com/CH4adYo.jpg)]" target="_blank" rel="noopener">http://i.imgur.com/CH4adYo.jpg)]</a></p>
<p><strong>onCreate :</strong> Activity被创建时调用，是生命周期第一个被调用的方法</p>
<p><strong>onStart :</strong>表示Activity正在启动，还没有到达可见、交互的地步</p>
<p><strong>onResume :</strong>表示Activity已在前台可见，可与用户交互</p>
<p><strong>onPause :</strong> 表示Activity正在停止</p>
<p><strong>onStop :</strong> 一般在onPause方法执行完成直接执行，表示Activity即将停止或者完全被覆盖，此时Activity不可见，仅在后台运行</p>
<p><strong>onRestart :</strong>表示Activity正在重新启动，当Activity由不可见变为可见状态时，该方法被回调</p>
<p><strong>onDestroy :</strong>此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做一些回收工作和最终的资源释放。</p>
<p><strong>2.2 Activity组件的加载模式</strong></p>
<ul>
<li><strong>standard模式</strong>：无论Activity栈中是否存在改Activity实例，系统都将创建一个实例</li>
<li><strong>singleTop模式</strong>：如果目标activity的实例已经存在于栈顶，系统会直接使用该实例，不会重新创建，否则会创建一个实例，入栈</li>
<li><strong>singleTask模式</strong>：在同一应用程序中，如果目标activity的实例已经存在于栈顶，系统会直接使用该实例，不会重新创建，否则弹出栈顶实例，直到使目标activity位于栈顶，在不同应用程序中启动Activity时，会创建一个新的task栈，用于保存被启动的Activity实例</li>
<li><strong>singleInstance模式</strong>：只有一个实例，并且这个实例独立运行在一个task栈中，这个task只有这个实例，不允许有别的Activity存在</li>
</ul>
<p><strong>2.2 Activity组件权限</strong></p>
<p>Activity权限的使用主要用于从其他应用中调用该应用的Activity进行一些操作，比如第三方登录：进行权限的设置后可以调用该应用中的Activity进行操作。下图是权限的格式定义：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SAbH4nAO-1578230663808)(<a href="http://i.imgur.com/MSPOUeC.png)]" target="_blank" rel="noopener">http://i.imgur.com/MSPOUeC.png)]</a></p>
<pre><code>android:protectionLevel 一共有四种</code></pre><ul>
<li><p><strong>normal：</strong>表示权限是低风险的，不会对系统、用户或其他应用程序造成危害</p>
</li>
<li><p><strong>dangerous：</strong>比normal级别要高一等级,可能会赋予应用程序访问敏感数据或控制设备等功能</p>
</li>
<li><p><strong>signature：</strong>表示只有当应用程序所用数字签名与声明该权限的应用程序所用数字签名相同时，才能将权限授给它</p>
</li>
<li><p><strong>signatureOrSystem ：</strong>表示将权限授给具有相同数字签名的应用程序或android 系统映像/系统app。这一保护级别适和于非常特殊的情况，比如多个供应商需要通过系统映像共享功能时</p>
</li>
</ul>
<p><strong>2.2 exported属性</strong></p>
<p>一个Activity组件能否被外部应用启动取决于此属性，设置为true时Activity可以被外部应用启动，设置为false则不能，此时Activity只能被自身app启动。（同user id或者root也能启动）</p>
<p>没有配置intent-filter属性exported默认为false（没有filter只能通过明确的类名来启动activity故相当于只有程序本身能启动），配置了intent-filter属性exported默认为true。</p>
<p>exported属性只是用于限制Activity是否暴露给其他app，通过配置文件中的权限申明也可以限制外部启动activity。</p>
<p><strong>2.3 activity的声明</strong></p>
<pre><code>&lt;activity
        android:name=&quot;Activity&quot;
        android:label=&quot;@string/title_activity&quot;
        android:permission=&quot;packagename.permission.Activity&quot;
        &gt;
        &lt;intent-filter&gt;
            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
            &lt;action android:name=&quot;packagename.intent.action.Activity&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;</code></pre><p>配置了intent-filter属性，则exported为true，说明别的应用程序可以在外部启动该Activity，可根据action的name发起隐式intent，启动声明了该action的Activity</p>
<p><strong>2.4 activity的分类</strong></p>
<p><strong>2.4.1 private activity</strong></p>
<p>私有Activity不应被其他应用启动相对是安全的<br>关于private activity的使用和设置规范请参照：<a href="http://www.bugsec.org/7195.html" target="_blank" rel="noopener">http://www.bugsec.org/7195.html</a></p>
<p><strong>2.4.2 public activity</strong></p>
<p>公开暴露的Activity组件，可以被任意应用启动<br>关于public activity的使用和设置规范请参照：<a href="http://www.bugsec.org/7195.html" target="_blank" rel="noopener">http://www.bugsec.org/7195.html</a></p>
<h4 id="3-Broadcast-Recevier组件"><a href="#3-Broadcast-Recevier组件" class="headerlink" title="3. Broadcast Recevier组件"></a><strong>3. Broadcast Recevier组件</strong></h4><p>Broadcast Recevier 广播接收器是一个专注于接收广播通知信息，并做出对应处理的组件，广播机制是一个典型的发布—订阅模式，即观察者模式。 广播接收器没有用户界面。然而，它们可以启动一个activity来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。</p>
<p><strong>3.1 广播注册形式</strong></p>
<p><strong>静态注册：</strong></p>
<p>静态注册是在AndroidManifest.xml中声明广播注册，直接在Manifest.xml文件的<application>节点中配置广播接收者。</p>
<pre><code>&lt;receiver android:name=&quot;.MyBroadCastReceiver&quot;&gt;  
        &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;
        &lt;intent-filter android:priority=&quot;20&quot;&gt;
        &lt;actionandroid:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt;  
        &lt;/intent-filter&gt;  
&lt;/receiver&gt;</code></pre><p>还要在<application>同级的位置配置可能使用到的权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;&gt;&lt;/uses-permission&gt;</code></pre><p><strong>动态注册：</strong></p>
<p>通过使用代码进行注册</p>
<p><strong>区别：</strong></p>
<ul>
<li><p>第一种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行</p>
</li>
<li><p>第二种是非常驻型广播，也就是说广播跟随程序的生命周期</p>
</li>
</ul>
<p>关于Broadcast Recevier安全编码规范，参照：<a href="http://www.droidsec.cn/android-broadcast-security/" target="_blank" rel="noopener">http://www.droidsec.cn/android-broadcast-security/</a></p>
<h4 id="3-Content-Provider组件"><a href="#3-Content-Provider组件" class="headerlink" title="3. Content Provider组件"></a><strong>3. Content Provider组件</strong></h4><p>为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。使用ContentProvider，应用程序可以实现数据共享，android内置的许多数据都是使用ContentProvider形式，供开发者调用的(如视频，音频，图片，通讯录等)</p>
<p>关于Content Provider组件的安全问题，参照：<a href="http://blog.csdn.net/alimobilesecurity/article/details/51564968" target="_blank" rel="noopener">http://blog.csdn.net/alimobilesecurity/article/details/51564968</a></p>
<h3 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a><strong>参考博文</strong></h3><p><a href="http://www.cnblogs.com/smyhvae/p/4070518.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/p/4070518.html</a></p>
<p><a href="http://blog.csdn.net/javazejian/article/details/51932554" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/51932554</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/05/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">Redis底层数据结构之简单动态字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-05 21:23:18 / 修改时间：21:24:10" itemprop="dateCreated datePublished" datetime="2020-01-05T21:23:18+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">redis学习</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/05/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-meta-item leancloud_visitors" data-flag-title="Redis底层数据结构之简单动态字符串" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/05/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/05/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Redis底层数据结构之简单动态字符串"><a href="#Redis底层数据结构之简单动态字符串" class="headerlink" title="Redis底层数据结构之简单动态字符串"></a><strong>Redis底层数据结构之简单动态字符串</strong></h2><p>我们知道在C语言中常常使用空字符’\0’作为字符串的结尾标志，也就是使用N+1的字符数组来表示长度为N的字符串，Redis没有直接使用C语言中的字符串表示，而是构建了自己的一套字符串表示抽象，称为简单动态字符串SDS(simple dynamic string)，至于为什么Redis不采用C语言中的字符串表示方法，这也是我们接下来要探讨的问题，我们首先给出Redis简单动态字符串的数据结构，然后说明相比C语言的字符串表示方法具有的优势</p>
<h3 id="一、Redis简单动态字符串的数据结构"><a href="#一、Redis简单动态字符串的数据结构" class="headerlink" title="一、Redis简单动态字符串的数据结构"></a><strong>一、Redis简单动态字符串的数据结构</strong></h3><p>接下来我们来看Redis中是如何定义字符串的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &#x2F;* Redis简单动态字符串的数据结构 *&#x2F;</span><br><span class="line">struct sdshdr &#123;</span><br><span class="line">		&#x2F;&#x2F;字符长度，记录buf数组中已使用的字节数量</span><br><span class="line">   		unsigned int len;</span><br><span class="line">   		&#x2F;&#x2F;当前可用空间，记录buf数组中未使用的字节数量</span><br><span class="line">   		unsigned int free;</span><br><span class="line">   		&#x2F;&#x2F;具体存放字符的buf</span><br><span class="line">   		char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、Redis采用这种结构保存字符串的原因"><a href="#二、Redis采用这种结构保存字符串的原因" class="headerlink" title="二、Redis采用这种结构保存字符串的原因"></a><strong>二、Redis采用这种结构保存字符串的原因</strong></h3><p>C语言中的字符表示，并不能满足Redis对字符串在安全性、效率以及功能方面的要求，具体体现在一下几点：</p>
<ul>
<li><p><strong>获取字符串长度的时间复杂度</strong></p>
<p>  在C语言中，要获取一个字符串的长度使用strlen函数，要对字符串进行遍历，其时间复杂度为O(N)，而SDS本身记录了字符串的长度即len属性，所以获取一个字符串的长度的实践复杂度为O(1)，特别是Redis的使用环境中存在大量、频繁的字符串操作，如果每次都调用strlen将会严重影响系统性能。</p>
</li>
<li><p><strong>缓冲区溢出</strong></p>
<p>  在C语言中，我们要对一个字符串进行连接操作是，很容易造成缓冲区溢出，比如字符串char A[10] = {‘a’,’b’,’c’,’d’,’\n’}，现在使用连接操作strcat(A,B)，如果在进行连接操作之前未能检查A和B的长度，就会产生缓冲区溢出，这使得程序员在写程序的时候要非常小心，一不小心手滑，就是一个严重的Bug</p>
<p>  而在redis中，则不存在这样的问题，因为Redis保存了字符串的当前长度和可用空间，在进行连接操作的时候，会自动检查空间是否足够，不够空间系统会自动分配，程序员无需手动修改空间大小，也不会造成缓冲区溢出</p>
</li>
<li><p><strong>内存分配与释放</strong></p>
<p>  在C语言中，我们对字符串进行拼接操作时，容易造成缓冲区溢出，对字符串进行缩减/截断操作时候，如果未能及时释放未使用的字节空间，又很容易造成内存泄露，因此，在Redis中如果每次对字符串的操作都涉及空间重分配，并且在分配的过程中可能涉及到系统调用，通常将是一个非常耗时的操作；</p>
<p>  <strong>因此在Redis中使用两种优化手段，进行优化</strong></p>
<p>  <strong>(1) 空间预分配：</strong><br>  当对字符串进行拼接操作时，Redis不仅分配给满足拼接操作所必要的空间，通常还会额外分配一定量的空间供下次拼接操作使用，避免每次拼接操作进行过多的内存重分配。</p>
<p>  <strong>(2) 分配原则：</strong><br>  如果操作后的字符串长度 &lt; 1MB ，则len的长度和free的长度一样，也就是会额外的分配一倍的空间（具体为什么这么设定还有待考究）<br>  如果操作后的字符串长度 &gt;= 1MB，则Redis会分配额外的1MB未使用空间</p>
<p>  <strong>(3) 惰性空间释放：</strong><br>  在对字符串进行缩减操作时，Redis不会立即回收缩减掉的部分空间，而是使用free字段记录下来，供下次使用，同时，Redis也提供了相应的API，可以在需要的时候释放掉这些空间，以免造成内存浪费。</p>
</li>
</ul>
<h3 id="三、源码实例分析"><a href="#三、源码实例分析" class="headerlink" title="三、源码实例分析"></a><strong>三、源码实例分析</strong></h3><h4 id="3-1-返回字符串长度的函数sdslen"><a href="#3-1-返回字符串长度的函数sdslen" class="headerlink" title="3.1 返回字符串长度的函数sdslen"></a><strong>3.1 返回字符串长度的函数sdslen</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  	&#x2F;* 计算sds的长度，返回的size_t类型的数值 *&#x2F;</span><br><span class="line">&#x2F;* size_t,它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 *&#x2F;</span><br><span class="line">static inline size_t sdslen(const sds s) &#123;</span><br><span class="line">   		struct sdshdr *sh &#x3D; (void*)(s-(sizeof(struct sdshdr)));</span><br><span class="line">   		return sh-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 根据sdshdr中的free标记获取可用空间 *&#x2F;</span><br><span class="line">static inline size_t sdsavail(const sds s) &#123;</span><br><span class="line">   		struct sdshdr *sh &#x3D; (void*)(s-(sizeof(struct sdshdr)));</span><br><span class="line">   		return sh-&gt;free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来看定义内联函数的好处：</p>
<pre><code>因为定义为内联函数，所有要用到的地方可能不止一个文件。为了避免多个文件中定义同一个函数出错，所以放到头文件中。</code></pre><p>看到这里大家应该还会有疑问，返回长度为什么要这样操作？我们首先看sds的定义</p>
<pre><code>typedef char *sds;</code></pre><p>sds是一个char * 类型的指针，这和我们得sdshdr有什么关系呢？我们再看sds的构造过程函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 根据init函数指针创建字符串 *&#x2F;</span><br><span class="line">sds sdsnew(const char *init) &#123;</span><br><span class="line">    size_t initlen &#x3D; (init &#x3D;&#x3D; NULL) ? 0 : strlen(init);</span><br><span class="line">    return sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 创建新字符串方法，传入目标长度，初始化方法 *&#x2F;</span><br><span class="line">sds sdsnewlen(const void *init, size_t initlen) &#123;</span><br><span class="line">    struct sdshdr *sh;</span><br><span class="line"></span><br><span class="line">    if (init) &#123;</span><br><span class="line">		&#x2F;* 调用zmalloc申请size个大小的空间 *&#x2F;  </span><br><span class="line">        sh &#x3D; zmalloc(sizeof(struct sdshdr)+initlen+1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	&#x2F;&#x2F;当init函数为NULL时候，调用系统函数calloc函数申请空间 *&#x2F;  </span><br><span class="line">        sh &#x3D; zcalloc(sizeof(struct sdshdr)+initlen+1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (sh &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line">    sh-&gt;len &#x3D; initlen;</span><br><span class="line">    sh-&gt;free &#x3D; 0;</span><br><span class="line">    if (initlen &amp;&amp; init)</span><br><span class="line">        memcpy(sh-&gt;buf, init, initlen);</span><br><span class="line">   &#x2F;&#x2F;最末端同样要加‘\0’结束符</span><br><span class="line">    sh-&gt;buf[initlen] &#x3D; &#39;\0&#39;;</span><br><span class="line">    &#x2F;&#x2F;最后是通过返回字符串结构体sdshdr中的buf代表新的字符串的地址</span><br><span class="line">    return (char*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可以看出sdsnewlen函数的返回值是buf的首地址，这样在看sdslen函数，通过给定的sds首地址减去sizeof(sdshdr)，那么就应该是该sds所对应的sdshdr数据结构首地址，自然就能得到sh-&gt;len与sh-&gt;free。</p>
<h4 id="3-2-字符串的拼接操作"><a href="#3-2-字符串的拼接操作" class="headerlink" title="3.2 字符串的拼接操作"></a><strong>3.2 字符串的拼接操作</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 以t作为新添加的len长度buf的数据，实现追加操作 *&#x2F;</span><br><span class="line">	sds sdscatlen(sds s, const void *t, size_t len) &#123;</span><br><span class="line">	    struct sdshdr *sh;</span><br><span class="line">	    size_t curlen &#x3D; sdslen(s);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;为原字符串扩展len长度空间</span><br><span class="line">	    s &#x3D; sdsMakeRoomFor(s,len);</span><br><span class="line">	    if (s &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line">	    sh &#x3D; (void*) (s-(sizeof(struct sdshdr)));</span><br><span class="line">	    &#x2F;&#x2F;多余的数据以t作初始化</span><br><span class="line">	    memcpy(s+curlen, t, len);</span><br><span class="line">	    &#x2F;&#x2F;更改相应的len,free值</span><br><span class="line">	    sh-&gt;len &#x3D; curlen+len;</span><br><span class="line">	    sh-&gt;free &#x3D; sh-&gt;free-len;</span><br><span class="line">	    s[curlen+len] &#x3D; &#39;\0&#39;;</span><br><span class="line">	    return s;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;* Append the specified null termianted C string to the sds string &#39;s&#39;.</span><br><span class="line">	 *</span><br><span class="line">	 * After the call, the passed sds string is no longer valid and all the</span><br><span class="line">	 * references must be substituted with the new pointer returned by the call. *&#x2F;</span><br><span class="line">	&#x2F;* 追加t字符串 *&#x2F;</span><br><span class="line">	sds sdscat(sds s, const char *t) &#123;</span><br><span class="line">	    return sdscatlen(s, t, strlen(t));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考书籍："><a href="#参考书籍：" class="headerlink" title="参考书籍："></a><strong>参考书籍：</strong></h4><p>黄健宏的《Redis设计与实现》</p>
<h4 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a><strong>参考博客：</strong></h4><p><a href="http://blog.csdn.net/androidlushangderen/article/" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/</a></p>
<p><a href="http://blog.csdn.net/xiejingfa/article" target="_blank" rel="noopener"> http://blog.csdn.net/xiejingfa/article</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/05/LCA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/LCA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">LCA算法详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-05 21:18:57 / 修改时间：21:19:36" itemprop="dateCreated datePublished" datetime="2020-01-05T21:18:57+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">算法练习</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/05/LCA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="LCA算法详解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/05/LCA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/05/LCA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LCA算法详解"><a href="#LCA算法详解" class="headerlink" title="LCA算法详解"></a>LCA算法详解</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>LCA（Least Common Ancestors），即最近公共祖先，是指这样一个问题：在有根树中，找出某两个结点u和v最近的公共祖先（另一种说法，离树根最远的公共祖先）。对于该问题，最容易想到的解决方案是遍历，复杂度是O(n)。但当数据量非常大且查询很频繁时，该算法也许会存在问题。</p>
<h3 id="2-在线ST算法"><a href="#2-在线ST算法" class="headerlink" title="2. 在线ST算法"></a>2. 在线ST算法</h3><p>解决此问题存在两种经典的算法，一种是在线ST算法，另外一种是离线的Tarjan算法，<br>所谓在线算法是指用户每输入一个查询便马上处理一个查询，该算法一般用较长的时间做预处理，待信息充足以后便可以用较少的时间回答每个查询。<br>所谓离线算法，是指首先读入所有的询问（求一次LCA叫做一次询问），然后重新组织查询处理顺序以便得到更高效的处理方法<br>在线算法DFS+ST描述：将树看成一个无向图，u和v的公共祖先一定在u与v之间的最短路径上</p>
<p>  ● DFS：从树的根节点T开始，深度遍历树，并记录下每次到达的顶点。第一个的结点是root(T)，每经过一条边都记录它的端点。由于每条边恰好经过2次，因此一共记录了2n-1个结点，用E[1, … , 2n-1]来表示。</p>
<p>  ● 计算R[]：用R[i]表示E数组中值为i的元素第一次出现的下标，即如果R[u] &lt; R[v]时，DFS访问的顺序是E[R[u], R[u]+1, …, R[v]]。虽然其中包含u的后代，但深度最小的还是u与v的公共祖先。</p>
<p>  ● RMQ：当R[u] ≥ R[v]时，LCA[T, u, v] = RMQ(L, R[v], R[u])；否则LCA[T, u, v] = RMQ(L, R[u], R[v])，计算RMQ。</p>
<h4 id="在线算法DFS-ST代码如下："><a href="#在线算法DFS-ST代码如下：" class="headerlink" title="在线算法DFS+ST代码如下："></a>在线算法DFS+ST代码如下：</h4><h5 id="1-数据结构描述："><a href="#1-数据结构描述：" class="headerlink" title="1.数据结构描述："></a>1.数据结构描述：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 头结点信息</span><br><span class="line">private Node heads[];</span><br><span class="line">&#x2F;&#x2F; 边信息</span><br><span class="line">private Edge edges[];</span><br><span class="line">&#x2F;&#x2F; 深度遍历过程中每个节点第一次出现的序号</span><br><span class="line">private int first[];</span><br><span class="line">&#x2F;&#x2F; 每个节点出现的深度</span><br><span class="line">private int depth[];</span><br><span class="line">&#x2F;&#x2F; 深度遍历序列</span><br><span class="line">private int travel[];</span><br><span class="line">&#x2F;&#x2F; 保存节点到根节点的距离</span><br><span class="line">private int dir[];</span><br><span class="line">&#x2F;&#x2F; 访问记录矩阵</span><br><span class="line">private boolean vis[];</span><br><span class="line">private RMQ mRmq;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 邻接表头结点信息</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Node &#123;</span><br><span class="line">	private int sno;&#x2F;&#x2F; 节点编号</span><br><span class="line">	private Edge firstEdge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 邻接表边信息</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Edge &#123;</span><br><span class="line">	private int sno;</span><br><span class="line">	private int from;</span><br><span class="line">	private int to;</span><br><span class="line">	private int wight;</span><br><span class="line">	private Edge next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-算法步骤描述："><a href="#1-算法步骤描述：" class="headerlink" title="1.算法步骤描述："></a>1.算法步骤描述：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#####     1.根据输入的节点和权重信息建立邻接表</span><br><span class="line">    &#x2F;**</span><br><span class="line">	 * 无向图创建路径</span><br><span class="line">	 * </span><br><span class="line">	 * @param from</span><br><span class="line">	 * @param to</span><br><span class="line">	 * @param wight</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void createEdge(int from, int to, int wight) &#123;</span><br><span class="line">		addEdge(from, to, wight);</span><br><span class="line">		addEdge(to, from, wight);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 头插法创建邻接表</span><br><span class="line">	 * </span><br><span class="line">	 * @param from</span><br><span class="line">	 * @param to</span><br><span class="line">	 * @param wight</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private void addEdge(int from, int to, int wight) &#123;</span><br><span class="line">		Edge edge &#x3D; new Edge();</span><br><span class="line">		edge.from &#x3D; from;</span><br><span class="line">		edge.to &#x3D; to;</span><br><span class="line">		edge.wight &#x3D; wight;</span><br><span class="line">		edge.sno &#x3D; edgeNum;</span><br><span class="line">		edges[edgeNum++] &#x3D; edge;</span><br><span class="line">		edge.next &#x3D; heads[from].firstEdge;</span><br><span class="line">		heads[from].sno &#x3D; from;</span><br><span class="line">		heads[from].firstEdge &#x3D; edge;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">#####     2.深度优先遍历，计算访问序列、深度信息、节点第一次出现的位置信息等</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">	 * 深度遍历邻接表</span><br><span class="line">	 * </span><br><span class="line">	 * @param u</span><br><span class="line">	 * @param dep</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void travelInDepth(int u, int dep) &#123;</span><br><span class="line">		vis[u] &#x3D; true;</span><br><span class="line">		travel[++index] &#x3D; u;</span><br><span class="line">		first[u] &#x3D; index;</span><br><span class="line">		depth[index] &#x3D; dep;</span><br><span class="line">		for (Edge edge &#x3D; heads[u].firstEdge; edge !&#x3D; null; edge &#x3D; edge.next) &#123;</span><br><span class="line">			if (!vis[edge.to]) &#123;</span><br><span class="line">				int v &#x3D; edge.to;</span><br><span class="line">				dir[v] &#x3D; dir[u] + edge.wight;</span><br><span class="line">				travelInDepth(v, dep + 1);</span><br><span class="line">				travel[++index] &#x3D; u;</span><br><span class="line">				depth[index] &#x3D; dep;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">#####     3.根据输入的查询，回答结果</span><br><span class="line">    &#x2F;**</span><br><span class="line">	 * 回答节点的最近公共祖先节点</span><br><span class="line">	 * @param u</span><br><span class="line">	 * @param v</span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public int getLCANode(int u, int v) &#123;</span><br><span class="line">		if (mRmq &#x3D;&#x3D; null) &#123;</span><br><span class="line">			mRmq &#x3D; new RMQ();</span><br><span class="line">			mRmq.RMQInit(depth);</span><br><span class="line">		&#125;</span><br><span class="line">		u &#x3D; first[u];</span><br><span class="line">		v &#x3D; first[v];</span><br><span class="line">		if (u &lt; v) &#123;</span><br><span class="line">			return mRmq.getMax(u, v);</span><br><span class="line">		&#125;</span><br><span class="line">		return mRmq.getMax(v, u);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.kaide0521.cn/2020/01/05/%E6%89%A9%E5%B1%95KMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
      <meta itemprop="name" content="芝麻酱">
      <meta itemprop="description" content="芝麻酱的技术学习踩坑记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芝麻酱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/%E6%89%A9%E5%B1%95KMP/" class="post-title-link" itemprop="url">扩展KMP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-05 21:18:04 / 修改时间：21:18:34" itemprop="dateCreated datePublished" datetime="2020-01-05T21:18:04+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">算法练习</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/05/%E6%89%A9%E5%B1%95KMP/" class="post-meta-item leancloud_visitors" data-flag-title="扩展KMP" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/05/%E6%89%A9%E5%B1%95KMP/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/05/%E6%89%A9%E5%B1%95KMP/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h2><ul>
<li><p>什么是扩展KMP</p>
</li>
<li><p>扩展KMP的原理</p>
</li>
<li><p>扩展KMP的编程实现</p>
</li>
<li><p>扩展KMP的用途</p>
</li>
</ul>
<h6 id="参照-http-blog-csdn-net-dyx404514-article-details-41831947"><a href="#参照-http-blog-csdn-net-dyx404514-article-details-41831947" class="headerlink" title="参照 ++http://blog.csdn.net/dyx404514/article/details/41831947++"></a>参照 ++<a href="http://blog.csdn.net/dyx404514/article/details/41831947++" target="_blank" rel="noopener">http://blog.csdn.net/dyx404514/article/details/41831947++</a></h6><hr>
<h3 id="1-什么是扩展KMP"><a href="#1-什么是扩展KMP" class="headerlink" title="1 什么是扩展KMP"></a>1 什么是扩展KMP</h3><p>给出模板串S和T，长度分别为Slen和Tlen，要求在线性时间内，对于每个S[i]（0&lt;=i&lt;Slen），</p>
<p>求出S[i..Slen-1]与T的最长公共前缀长度，记为extend[i]</p>
<p>（或者说，extend[i]为满足S[i..i+z-1]==T[0..z-1]的最大的z值）。</p>
<p>扩展KMP可以用来解决很多字符串问题，如求一个字符串的最长回文子串和最长重复子串。</p>
<h3 id="2-扩展KMP的原理"><a href="#2-扩展KMP的原理" class="headerlink" title="2 扩展KMP的原理"></a>2 扩展KMP的原理</h3><pre><code>记母串为S,模式串为T，next[i]表示模式串S的后缀</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T[i...len(T)]</span><br></pre></td></tr></table></figure>
<pre><code>与模式串T的最长公共前缀。记为extend[i]为满足</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[i..i+z-1]&#x3D;T[0..z-1]</span><br></pre></td></tr></table></figure>
<pre><code>的最大的z值，即S串以i开头的后缀与T的最长公共前缀。</code></pre><h4 id="2-1-拓展kmp算法一般步骤"><a href="#2-1-拓展kmp算法一般步骤" class="headerlink" title="2.1 拓展kmp算法一般步骤"></a>2.1 拓展kmp算法一般步骤</h4><p>首先我们从左到右依次计算extend数组，在某一时刻，设extend[0…k]已经计算完毕，并且之</p>
<p>前匹配过程中所达到的最远位置为P，所谓最远位置，严格来说就是i+extend[i]-1的最大值</p>
<p>（0&lt;=i&lt;=k）,并且设取这个最大值的位置为P</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">S ：0......p0.....k k+1......p.......len(s) 现在要计算extend[k+1],根据extend的定义</span><br><span class="line"></span><br><span class="line">有S[p0....p] &#x3D; T[0...p-p0] ——&gt; S[k+1,P] &#x3D; T[k-p0+1,P-po]</span><br><span class="line"></span><br><span class="line">令 len &#x3D; next[k-p0+1]</span><br><span class="line"></span><br><span class="line">（前面介绍了next数组的含义,表示T串与T[k-p0+1,len(T)]的最长公共前缀）;</span><br><span class="line"></span><br><span class="line">下面通过两种情况讨论：</span><br><span class="line"></span><br><span class="line">    1. if k+len &lt; P : </span><br><span class="line">            </span><br><span class="line">        S[k+1,k+len] &#x3D; T[0,len] ——&gt; 则S[k+len+1]一定与T[len]不相等，为什么呢？</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 因为T[k-p0+1+len] &#x3D; S[k+1+len]，由next数组可知T[k-p0+1+len-1] &#x3D; T[len-1]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; T[k-p0+1+len] ！&#x3D; T[len] ——&gt; S[k+len+1] !&#x3D;  T[len] </span><br><span class="line">        </span><br><span class="line">        即 extend[k+1] &#x3D; len</span><br><span class="line">        </span><br><span class="line">    2. if k + len &gt; p : </span><br><span class="line">    </span><br><span class="line">        S[p+1]之后的字符都是未知的，也就是还未进行过匹配的字符串，</span><br><span class="line">        </span><br><span class="line">        所以在这种情况下，就要从S[P+1]和T[P-k+1]开始一一匹配，直到发生失配为止，</span><br><span class="line">        </span><br><span class="line">        当匹配完成后，如果得到的extend[k+1]+(k+1)大于P则要更新未知P和p0</span><br><span class="line"></span><br><span class="line">    至此，拓展kmp算法的过程已经描述完成</span><br></pre></td></tr></table></figure>

<h3 id="扩展KMP的编程实现"><a href="#扩展KMP的编程实现" class="headerlink" title="扩展KMP的编程实现"></a>扩展KMP的编程实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const int maxn&#x3D;100010;   &#x2F;&#x2F;字符串长度最大值  </span><br><span class="line">int next[maxn],ex[maxn]; &#x2F;&#x2F;ex数组即为extend数组  </span><br><span class="line">&#x2F;&#x2F;预处理计算next数组  </span><br><span class="line">void GETNEXT(char *str)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i &#x3D; 0,j,po,len&#x3D;strlen(str);  </span><br><span class="line">    next[0] &#x3D; len;&#x2F;&#x2F;初始化next[0]  </span><br><span class="line">    while( str[i] &#x3D;&#x3D; str[i+1] &amp;&amp; i+1 &lt; len)&#x2F;&#x2F;计算next[1]  </span><br><span class="line">    i++;  </span><br><span class="line">    next[1] &#x3D; i;  </span><br><span class="line">    po &#x3D; 1;&#x2F;&#x2F;初始化po的位置  </span><br><span class="line">    for( i &#x3D; 2; i &lt; len; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">        if( next[i-po]+i &lt; next[po]+po )&#x2F;&#x2F;第一种情况，可以直接得到next[i]的值  </span><br><span class="line">        next[i] &#x3D; next[i-po];  </span><br><span class="line">        else&#x2F;&#x2F;第二种情况，要继续匹配才能得到next[i]的值  </span><br><span class="line">        &#123;  </span><br><span class="line">            j &#x3D; next[po]+po-i;  </span><br><span class="line">            if( j &lt; 0 )j &#x3D; 0;&#x2F;&#x2F;如果i&gt;po+next[po],则要从头开始匹配  </span><br><span class="line">            while( i+j &lt; len &amp;&amp; str[j] &#x3D;&#x3D; str[j+i] )&#x2F;&#x2F;计算next[i]  </span><br><span class="line">            j++;  </span><br><span class="line">            next[i] &#x3D; j;  </span><br><span class="line">            po &#x3D; i;&#x2F;&#x2F;更新po的位置  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;计算extend数组  </span><br><span class="line">void EXKMP(char *s1,char *s2)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i &#x3D; 0,j,po,len &#x3D; strlen(s1),l2 &#x3D; strlen(s2);  </span><br><span class="line">    GETNEXT(s2);&#x2F;&#x2F;计算子串的next数组  </span><br><span class="line">    while ( s1[i] &#x3D;&#x3D; s2[i] &amp;&amp; i &lt; l2 &amp;&amp; i &lt; len )&#x2F;&#x2F;计算ex[0]  </span><br><span class="line">    i++;  </span><br><span class="line">    ex[0] &#x3D; i;  </span><br><span class="line">    po &#x3D; 0;&#x2F;&#x2F;初始化po的位置  </span><br><span class="line">    for( i &#x3D; 1; i &lt; len; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if( next[i-po]+i &lt; ex[po]+po )&#x2F;&#x2F;第一种情况，直接可以得到ex[i]的值  </span><br><span class="line">        ex[i] &#x3D; next[i-po];  </span><br><span class="line">        else&#x2F;&#x2F;第二种情况，要继续匹配才能得到ex[i]的值  </span><br><span class="line">        &#123;  </span><br><span class="line">            j &#x3D; ex[po]+po-i;  </span><br><span class="line">            if( j &lt; 0 ) j &#x3D; 0;&#x2F;&#x2F;如果i&gt;ex[po]+po则要从头开始匹配  </span><br><span class="line">            while( i+j &lt; len &amp;&amp; j &lt; l2 &amp;&amp; s1[j+i] &#x3D;&#x3D; s2[j] )&#x2F;&#x2F;计算ex[i]  </span><br><span class="line">            j++;  </span><br><span class="line">            ex[i] &#x3D; j;  </span><br><span class="line">            po &#x3D; i;&#x2F;&#x2F;更新po的位置  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="芝麻酱"
      src="https://avatars2.githubusercontent.com/u/12148927?s=400&u=db4cba304b11bb561b4be7f7dd95ee1a06568e7e&v=4">
  <p class="site-author-name" itemprop="name">芝麻酱</p>
  <div class="site-description" itemprop="description">芝麻酱的技术学习踩坑记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="简书 → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>简书</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://yoursite.com/" title="http:&#x2F;&#x2F;yoursite.com" rel="noopener" target="_blank">link1</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://yoursite.com/" title="http:&#x2F;&#x2F;yoursite.com" rel="noopener" target="_blank">link2</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">芝麻酱</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">50k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">45 分钟</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'LpsgHIFEz84XLYiGosVKYzao-9Nh9j0Va',
      appKey: 'xO0mP6JY1zufGMfFA4isXpca',
      placeholder: "Just go go",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
